<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>OpenGL绘制一个三角形</title>
    <link href="undefined2019/11/28/learn-opengl-triangle/"/>
    <url>2019/11/28/learn-opengl-triangle/</url>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>这里我会使用刚刚学习到的知识点，尝试绘制一个三角形。使用Android提供的GLSurfaceView配合OpenGL ES完成这个任务。</p><a id="more"></a><ul><li>GLSurfaceView</li><li>实现GLSurfaceView.Renderer</li><li>glFrustumf，glViewport，glVertexPointer</li><li>glDrawArrays</li></ul><h2 id="编码"><a href="#编码" class="headerlink" title="编码"></a>编码</h2><h3 id="1-创建TriangleActivity"><a href="#1-创建TriangleActivity" class="headerlink" title="1.创建TriangleActivity"></a>1.创建TriangleActivity</h3><pre><code class="xml">&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;&lt;androidx.constraintlayout.widget.ConstraintLayout xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;        xmlns:app=&quot;http://schemas.android.com/apk/res-auto&quot;        xmlns:tools=&quot;http://schemas.android.com/tools&quot;        android:layout_width=&quot;match_parent&quot;        android:layout_height=&quot;match_parent&quot;        tools:context=&quot;.opengl.triangle.TriangleActivity&quot;&gt;    &lt;android.opengl.GLSurfaceView            android:id=&quot;@+id/gl_surface_view&quot;            android:layout_width=&quot;match_parent&quot;            android:layout_height=&quot;match_parent&quot;            app:layout_constraintBottom_toBottomOf=&quot;parent&quot;            app:layout_constraintEnd_toEndOf=&quot;parent&quot;            app:layout_constraintStart_toStartOf=&quot;parent&quot;            app:layout_constraintTop_toTopOf=&quot;parent&quot; /&gt;&lt;/androidx.constraintlayout.widget.ConstraintLayout&gt;</code></pre><p>加载布局,设置TriangleRenderer</p><pre><code class="kotlin">@Route(path = IRoute.MEDIA_OPENGL_TRIANGLE)class TriangleActivity : BaseActivity() {    override fun getLayoutId(): Int = R.layout.activity_triangle    override fun initViews(savedInstanceState: Bundle?) {        gl_surface_view.setRenderer(TriangleRenderer())    }}</code></pre><h3 id="2-实现TriangleRenderer"><a href="#2-实现TriangleRenderer" class="headerlink" title="2.实现TriangleRenderer"></a>2.实现TriangleRenderer</h3><p>这里的注释写的很完善了，不做其他的补充</p><pre><code class="kotlin">/** * If you have any questions, you can contact by email {wangzhumoo@gmail.com} * * @author 王诛魔 2019-11-29  10:49 * * 三角形的renderer */class TriangleRenderer : GLSurfaceView.Renderer {    private var ratio = 0F    override fun onDrawFrame(gl: GL10?) {        //切换到模型矩阵        gl?.apply {            //清屏,清除颜色缓冲区            glClear(GL10.GL_COLOR_BUFFER_BIT)            //gluLookAt 需要操作的是模型矩阵            glMatrixMode(GL10.GL_MODELVIEW)            //加载单位矩阵 - 初始化            glLoadIdentity()        }      /*         * @param gl a GL10 interface   gl对象         *         * @param eyeX eye point X         * @param eyeY eye point Y      观察者的位置，最好是与平截头体在一个原点上         * @param eyeZ eye point Z         *         * @param centerX center of view X         * @param centerY center of view Y   观察者的观察方向（朝向0，0，0 原点）         * @param centerZ center of view Z         *         * @param upX up vector X         * @param upY up vector Y    观察者向上的位置         * @param upZ up vector Z         */        //确定观察的空间坐标        GLU.gluLookAt(gl, 0F, 0F, 5F, 0F, 0F, 0F, 0F, 1F, 0F)        //顶点数组        val trianglePoint = floatArrayOf(            0F, ratio, 1F,            -1F, -ratio, 1F,            1F, -ratio, 1F        )        //创建顶点缓冲区        val pointBuffer = ByteBuffer.allocateDirect(trianglePoint.size * 4)        val floatBuffer = TextureUtils.loadVertexBuffer(pointBuffer,trianglePoint)        //设置绘图的颜色,使用红色        gl?.glColor4f(1F,0F,0F,1F)        //指定3个值确定一个点        //Must use a native order direct Buffer        gl?.glVertexPointer(3, GL10.GL_FLOAT, 0, floatBuffer)        //画一个三角        gl?.glDrawArrays(GL10.GL_TRIANGLES,0,3)    }    override fun onSurfaceChanged(gl: GL10?, width: Int, height: Int) {        gl?.apply {            //viewport视口   也就是opengl可以显示的区域大小            glViewport(0, 0, width, height)            //投影矩阵 - 矩阵模式            glMatrixMode(GL10.GL_PROJECTION)            //加载单位矩阵 - 初始化            glLoadIdentity()            //计算比例，避免缩放后显示变形            ratio = width.toFloat() / height            //设置平截头体，为了投射到viewport上时，不超出viewport，top/bottom 按照我们viewport的比例设置              //此处,  bottom = -left * ratio    top = left * ratio            //zNear 近平面距离            //zFar  远平面距离            glFrustumf(-1F, 1F, -ratio, ratio, 3F, 7F)        }    }    override fun onSurfaceCreated(gl: GL10?, config: EGLConfig?) {        gl?.apply {            //清屏颜色设置            glClearColor(0F, 0F, 0F, 1F)            //开启顶点缓冲区            glEnableClientState(GL10.GL_VERTEX_ARRAY)        }    }}</code></pre><p><code>TextureUtils</code>是在渲染Camera时就已经写好的工具了，不重复写了。</p><h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><h4 id="顶点坐标"><a href="#顶点坐标" class="headerlink" title="顶点坐标"></a>顶点坐标</h4><pre><code>val trianglePoint = floatArrayOf(            0F, ratio, 1F,            -1F, -ratio, 1F,            1F, -ratio, 1F        )</code></pre><ul><li><p>x  [-1,1]   我们在平截头体中的比例，最大也就是[-1,1]</p></li><li><p>y  [-ratio,ratio]  这里我们计算了屏幕的比例，得出的ratio</p></li><li><p>z  这个指定了，我们在平截头体中的z位置，在这个例子中，我们的<code>glFrustumf(-1F, 1F, -ratio, ratio, 3F, 7F)</code>中，用远平面减去近平面， 7 -3 = 4   [0,4]</p></li></ul><h4 id="平截头体"><a href="#平截头体" class="headerlink" title="平截头体"></a>平截头体</h4><pre><code>glFrustumf(-1F, 1F, -ratio, ratio, 3F, 7F)</code></pre><ul><li>Left / right  分别为 -1  1</li><li>bottom = -left * ratio</li><li>top = left * ratio</li><li>zNear 近平面距离</li><li>zFar  远平面距离</li></ul><h2 id="效果"><a href="#效果" class="headerlink" title="效果"></a>效果</h2><pre><code>val trianglePoint = floatArrayOf(            0F, ratio, 1F,            -1F, -ratio, 1F,            1F, -ratio, 1F        )</code></pre><p><img src="/Users/wangzhumo/Develop/hexo/source/images/opengl_result1_1.png" srcset="/img/loading.gif" alt="opengl_result1_1"></p><pre><code>val trianglePoint = floatArrayOf(            0F, ratio, 2F,            -1F, -ratio, 2F,            1F, -ratio, 2F        )</code></pre><p><img src="/Users/wangzhumo/Develop/hexo/source/images/opengl_result1_2.png" srcset="/img/loading.gif" alt="opengl_result1_2"></p>]]></content>
    
    
    <categories>
      
      <category>Media</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Media</tag>
      
      <tag>OpenGL</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>OpenGL的模型以及渲染管线Pipeline</title>
    <link href="undefined2019/11/27/learn-opengl-pipeline/"/>
    <url>2019/11/27/learn-opengl-pipeline/</url>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>OpenGL的学习难度还是很大的。</p><p>这里一一记录学习的整个过程，首先我想要先简单了解OpenGL的大概工作流程OpenGL Pipeline，后面会慢慢的完善这个笔记。</p><a id="more"></a><p>找到一张比较老的图，这里是以opengl1.1的标准来画的，看起来更容易一些，所以不妨先看看。</p><p><img src="/Users/wangzhumo/Develop/hexo/source/images/gl1_pipeline_image.png" srcset="/img/loading.gif" alt="gl1_pipeline_image"></p><h2 id="Pipeline"><a href="#Pipeline" class="headerlink" title="Pipeline"></a>Pipeline</h2><blockquote><p><a href="https://www.khronos.org/opengl/wiki/Rendering_Pipeline_Overview" target="_blank" rel="noopener">https://www.khronos.org/opengl/wiki/Rendering_Pipeline_Overview</a></p></blockquote><p>这张管线图来自官方的wiki,可以说是比较权威的。</p><p><img src="/Users/wangzhumo/Develop/hexo/source/images/opengl_render_pipeline.png" srcset="/img/loading.gif" alt="opengl_render_pipeline"></p><ol><li><p><strong>顶点数据</strong></p><ul><li><p>VAO(Vertex Array Objects)每个顶点包含的信息</p></li><li><p>VBO(Vertex Buffer Objects)顶点数据的Buffer</p></li></ul></li><li><p><strong>顶点处理</strong> —OpenGL将调用vertex shader来处理顶点</p><ul><li><p>顶点的变换，比如投影矩阵变化</p></li><li><p>光照，有时还会有光照的处理</p></li><li><p>顶点着色器</p></li></ul></li></ol><p>  可能会有多个vertex shader，但每次只能执行一个</p><ol><li><p><strong>Tesselation Shading</strong>    [可选]</p></li><li><p><strong>Geometry Shading</strong>    [可选]</p></li><li><p><strong>图元组装</strong></p><p>图元组装阶段会把顶点组装成一组相关联的几何图元</p></li><li><p><strong>裁剪</strong></p><p>有的时候，我们的顶点会跑到可显示范围之外去，OpenGL会帮我们把这些不可显示的部分裁切掉，以提高效果，节省资源</p></li><li><p><strong>栅格化</strong></p><p>裁切后的图元经过栅格化，生成fragment,并且会存放在frameBuffer中，这些数据还可以被下面的两部进行加工处理</p></li><li><p><strong>Fragment Shading</strong></p><p>fragment shading用前面的信息来决定fragment的颜色，是否需要停止，以及可以处理texture mapping.</p></li><li><p><strong>Per-Fragment Operations</strong></p></li></ol><p>现在对它们的具体含义并不非常清楚，然而我们知道了整个框架，后面的学习过程就是慢慢填充，修改这个框架的过程。</p><h2 id="Model"><a href="#Model" class="headerlink" title="Model"></a>Model</h2><p>OpenGl的架构，也是很经典的C-S架构。</p><blockquote><p><a href="https://cloud.tencent.com/developer/news/223343" target="_blank" rel="noopener">https://cloud.tencent.com/developer/news/223343</a></p></blockquote><p><img src="/Users/wangzhumo/Develop/hexo/source/images/opengl_model_image.jpeg" srcset="/img/loading.gif" alt="opengl_model_image"></p><h3 id="END"><a href="#END" class="headerlink" title="END"></a>END</h3>]]></content>
    
    
    <categories>
      
      <category>Media</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Media</tag>
      
      <tag>OpenGL</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>MediaExtractor与MediaMuxer的简单使用</title>
    <link href="undefined2019/11/26/mediaextractor-and-mediamuxer-sample/"/>
    <url>2019/11/26/mediaextractor-and-mediamuxer-sample/</url>
    
    <content type="html"><![CDATA[<p><code>MediaExtractor</code>可以说是一个非常好用的封装了，支持很多输入格式，可以对我们的多媒体文件进行分解，可以用来分离容器中的视频track和音频track。</p><p><code>MediaMuxer</code>用于封装编码后的视频流和音频流。虽然有一些限制条件，但是对于一般的使用还是可以胜任的。</p><a id="more"></a><h2 id="初步认识"><a href="#初步认识" class="headerlink" title="初步认识"></a>初步认识</h2><h3 id="MediaExtractor"><a href="#MediaExtractor" class="headerlink" title="MediaExtractor"></a>MediaExtractor</h3><blockquote><p><a href="https://developer.android.google.cn/reference/android/media/MediaExtractor?hl=en" target="_blank" rel="noopener">https://developer.android.google.cn/reference/android/media/MediaExtractor?hl=en</a></p></blockquote><p>MediaExtractor facilitates extraction of demuxed, typically encoded, media data from a data source.</p><p>简单的描述它，就是一个解封装的工具。</p><pre><code class="java"> MediaExtractor extractor = new MediaExtractor(); //设置来源 extractor.setDataSource(...); //获取媒体文件的track数量 int numTracks = extractor.getTrackCount(); for (int i = 0; i &lt; numTracks; ++i) {   MediaFormat format = extractor.getTrackFormat(i);   String mime = format.getString(MediaFormat.KEY_MIME);   //获取到你想要使用的Track   if (weAreInterestedInThisTrack) {           //标记这个Track     extractor.selectTrack(i);   } } ByteBuffer inputBuffer = ByteBuffer.allocate(...) while (extractor.readSampleData(inputBuffer, ...) &gt;= 0) {   int trackIndex = extractor.getSampleTrackIndex();   long presentationTimeUs = extractor.getSampleTime();   ...   //下一帧   extractor.advance(); } //释放 extractor.release(); extractor = null;</code></pre><p>doc上提供了一段比较简单的使用方式</p><p>几个比较常用的<code>setDataSource</code>,<code>MediaFormat</code>,<code>selectTrack</code>,<code>release</code></p><h3 id="MediaMuxer"><a href="#MediaMuxer" class="headerlink" title="MediaMuxer"></a>MediaMuxer</h3><blockquote><p><a href="https://developer.android.google.cn/reference/android/media/MediaMuxer?hl=en" target="_blank" rel="noopener">https://developer.android.google.cn/reference/android/media/MediaMuxer?hl=en</a></p></blockquote><p>MediaMuxer facilitates muxing elementary streams. Currently MediaMuxer supports MP4, Webm and 3GP file as the output. It also supports muxing B-frames in MP4 since Android Nougat.</p><p>支持的格式有MP4，而我们经常使用的封装也就是MP4啦，比较遗憾的是只能支持单个的Video Track 和 Audio Track。</p><h2 id="分离MP4的Video-Audio-Track"><a href="#分离MP4的Video-Audio-Track" class="headerlink" title="分离MP4的Video/Audio Track"></a>分离MP4的Video/Audio Track</h2><pre><code class="kotlin">        /**     * @param path 媒体文件地址     *     */    fun extractorMedia(path: String) {        val extractor = MediaExtractor()        //设置来源        extractor.setDataSource(path)        //获取媒体文件的track数量        val numTracks = extractor.trackCount        for (index in 0 until numTracks){            val format = extractor.getTrackFormat(index)            //获取到你想要使用的Track            appendLogs(format.toString())        }    }</code></pre><p>明确的看到，这个MP4中有一条音频轨，一条视频轨道。</p><pre><code>{        track-id=2,       max-bitrate=129051,       //码率、比特率      sample-rate=44100,        //采样率      file-format=video/mp4,       mime=audio/mp4a-latm,     //类型是 audio      bitrate=129051,       language=,       aac-profile=2,       durationUs=95087233,       aac-format-adif=0,                   channel-count=2,                     //声道      max-input-size=65541,       csd-0=java.nio.HeapByteBuffer[pos=0 lim=5 cap=5]}</code></pre><pre><code>{      track-id=1,     file-format=video/mp4,     level=2048,     mime=video/avc,             //类型是 audio    profile=2,     language=,     display-width=1920,     csd-1=java.nio.HeapByteBuffer[pos=0 lim=8 cap=8],     durationUs=95041666,     display-height=1080,     width=1920,     rotation-degrees=0,     max-input-size=1555201,     frame-rate=24,     height=1080,     csd-0=java.nio.HeapByteBuffer[pos=0 lim=41 cap=41]}</code></pre><p>我们继续，下面的操作把这个MP4分离为一个 <code>ouput_video_mp4</code> , 一个 <code>ouput_audio_mp4</code></p><pre><code class="java">        /**     * @param path 媒体文件地址     *     */    fun extractorMedia(path: String) {        val extractor = MediaExtractor()        //设置来源        extractor.setDataSource(path)        //视频文件        val videoStream = File(OUTPUT_DIR, &quot;output_video_mp4.mp4&quot;).outputStream()        //音频文件        val audioStream = File(OUTPUT_DIR, &quot;output_audio_mp4&quot;).outputStream()        //记录音频/视屏轨道的index        var videoTrackIndex = -1        var audioTrackIndex = -1        //获取媒体文件的track数量        val numTracks = extractor.trackCount        for (index in 0 until numTracks) {            val format = extractor.getTrackFormat(index)            val mimeType = format.getString(MediaFormat.KEY_MIME)            //标记视频轨道            if (mimeType.startsWith(&quot;video/&quot;)) {                videoTrackIndex = index            }            //标记音频轨道            if (mimeType.startsWith(&quot;audio/&quot;)) {                audioTrackIndex = index            }            appendLogs(&quot;视频分离 - 任务开始&quot;)            // 切换到视频            extractor.selectTrack(videoTrackIndex)            readTrackStream(videoStream,extractor)            videoStream.close()            appendLogs(&quot;视频分离 - 任务结束&quot;)            appendLogs(&quot;音频分离 - 任务开始&quot;)            // 切换到音频            extractor.selectTrack(audioTrackIndex)            readTrackStream(audioStream,extractor)            audioStream.close()            appendLogs(&quot;音频分离 - 任务结束&quot;)        }        appendLogs(&quot;任务结束&quot;)        extractor.release()    }        /**     * 读取数据，写入到文件中     */    private fun readTrackStream(fileInput: FileOutputStream, extractor: MediaExtractor) {        //Buffer        val byteBuffer = ByteBuffer.allocate(1024 * 500)        var readCount = 0        do {            //读取数据            readCount = extractor.readSampleData(byteBuffer,0)            if (readCount &lt; 0){                break            }            //写入文件            val buffer = ByteArray(readCount)            byteBuffer.get(buffer)            fileInput.write(buffer)            byteBuffer.clear()            //移动到下一帧            extractor.advance()        }while (readCount &gt; 0)        byteBuffer.clear()    }</code></pre><h3 id="将音频-视频合并为MP4"><a href="#将音频-视频合并为MP4" class="headerlink" title="将音频/视频合并为MP4"></a>将音频/视频合并为MP4</h3><pre><code class="java">        /**     * 合并音视频     */    fun muxerMediaStream(path: String){        appendLogs(&quot;任务开始&quot;)        val mOutputVideoPath = File(OUTPUT_DIR, &quot;output_mp4_file.mp4&quot;).absolutePath        //指定输出目录，指定Format格式        appendLogs(&quot;输出目录：$mOutputVideoPath&quot; )        val mMediaMuxer = MediaMuxer(            mOutputVideoPath,            MediaMuxer.OutputFormat.MUXER_OUTPUT_MPEG_4        )        //获取两个轨道，并且添加到mMediaMuxer        val extractor = MediaExtractor()        //设置来源        extractor.setDataSource(path)        //记录音频/视屏轨道的index        var videoTrackIndex = -1        var audioTrackIndex = -1        //获取媒体文件的track数量        val numTracks = extractor.trackCount        for (index in 0 until numTracks) {            val format = extractor.getTrackFormat(index)            val mimeType = format.getString(MediaFormat.KEY_MIME)            //标记视频轨道            if (mimeType.startsWith(&quot;video/&quot;)) {                videoTrackIndex = index                appendLogs(&quot;videoTrackIndex ：$videoTrackIndex&quot; )            }            //标记音频轨道            if (mimeType.startsWith(&quot;audio/&quot;)) {                audioTrackIndex = index                appendLogs(&quot;audioTrackIndex ：$audioTrackIndex&quot; )            }        }        //添加Track        mMediaMuxer.addTrack(extractor.getTrackFormat(videoTrackIndex))        mMediaMuxer.addTrack(extractor.getTrackFormat(audioTrackIndex))        //添加完毕开始        mMediaMuxer.start()        //读取数据，并且写入MediaMuxer        //写入视频文件        readTrackAndMuxer(videoTrackIndex,mMediaMuxer,extractor)        //写入音频文件        readTrackAndMuxer(audioTrackIndex,mMediaMuxer,extractor)        //释放MediaExtractor        extractor.release()        //释放MediaMuxer        mMediaMuxer.stop();        mMediaMuxer.release();    }    /**     * 读取文件，并且写入mMediaMuxer.     */    private fun readTrackAndMuxer(trackIndex: Int,mMediaMuxer: MediaMuxer, extractor: MediaExtractor) {        appendLogs(&quot;readTrackAndMuxer 开始写入&quot; )        //读取数据        extractor.selectTrack(trackIndex)        val byteBuffer = ByteBuffer.allocate(1024 * 500)        val info: MediaCodec.BufferInfo = MediaCodec.BufferInfo()        info.presentationTimeUs = 0        var readCount = 0        do {            //读取数据            readCount = extractor.readSampleData(byteBuffer,0)            if (readCount &lt; 0){                break            }            //写入文件            info.offset = 0            info.size = readCount            info.flags = MediaCodec.BUFFER_FLAG_KEY_FRAME            info.presentationTimeUs = extractor.sampleTime            mMediaMuxer.writeSampleData(trackIndex,byteBuffer,info)            byteBuffer.clear()            //移动到下一帧            extractor.advance()        }while (readCount &gt; 0)        appendLogs(&quot;readTrackAndMuxer 结束写入&quot; )    }</code></pre><p>代码的逻辑已经很清晰。</p><h3 id="END"><a href="#END" class="headerlink" title="END."></a>END.</h3>]]></content>
    
    
    <categories>
      
      <category>Media</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Android</tag>
      
      <tag>Media</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>使用Textureview预览相机</title>
    <link href="undefined2019/11/19/camera-with-textureview/"/>
    <url>2019/11/19/camera-with-textureview/</url>
    
    <content type="html"><![CDATA[<h2 id="流程分析"><a href="#流程分析" class="headerlink" title="流程分析"></a>流程分析</h2><h4 id="实现思路"><a href="#实现思路" class="headerlink" title="实现思路"></a>实现思路</h4><p>使用TextureView显示相机的预览，渲染使用opengl实现，仿照GLSurfaceView的方式来预览这个相机。</p><a id="more"></a><p>相机 —-生产—&gt;  SurfaceTexture  (OpenGL  + GLThread 处理) —&gt; TextureView(SurfaceTextView)关联的GL环境</p><p>onSurfaceTextureAvailable(surface)—显示–&gt;  TextureView(SurfaceTextView)关联的GL环境</p><h4 id="大概流程"><a href="#大概流程" class="headerlink" title="大概流程"></a>大概流程</h4><ol><li><p>Activity 提供一个 TextureView</p></li><li><p>初始化相机硬件（权限/Camera1/2），准备开始预览</p></li><li><p>添加TextureView <code>setSurfaceTextureListener</code></p></li><li><p>setSurfaceTextureListener</p><ol><li><p>加载loadOESTexture</p></li><li><p>创建Renderer Thread</p></li><li><p>initEGLContext   使用TextureView中的surfaceTexture  </p></li><li><p>创建一个TextureEGLRenderer用于预览</p><blockquote><p> 完成GL环境的建立</p></blockquote></li><li><p>创建一个SurfaceTexture(mOESTextureId) ,用于相机的预览</p></li><li><p>开启预览</p></li></ol></li><li><p>setPreviewTexture(surfaceTexture)  -&gt;  创建的surfaceTexture -&gt; setOnFrameAvailableListener</p></li></ol><h4 id="TextureView"><a href="#TextureView" class="headerlink" title="TextureView"></a>TextureView</h4><p>几个常用的<code>SurfaceView</code>，<code>SurfaceTexture</code>  ,<code>GlSurfaceView</code>中</p><p><code>TextureView</code>是唯一一个可以当做View使用，支持动画效果，在5.0前在主线程渲染，在5.0后在单独线程渲染</p><p>但是它的性能没有其他几个好，耗费的内存也比较大，常用在List中，而且必须要在硬件</p><table><thead><tr><th></th><th>TextureView</th><th>SurfaceView</th></tr></thead><tbody><tr><td>绘制</td><td>1-3帧延迟</td><td>低</td></tr><tr><td>内存</td><td>高</td><td>低</td></tr><tr><td>动画和截图</td><td>支持</td><td>不支持</td></tr><tr><td>耗电</td><td>高</td><td>低</td></tr></tbody></table><blockquote><p>以上是网络上的资料图表</p></blockquote><h2 id="编码分析"><a href="#编码分析" class="headerlink" title="编码分析"></a>编码分析</h2><h5 id="CameraActivity"><a href="#CameraActivity" class="headerlink" title="CameraActivity"></a>CameraActivity</h5><p>用于承载这个Demo,其中根布局只有一个TextureView</p><h5 id="CameraOpenHelper"><a href="#CameraOpenHelper" class="headerlink" title="CameraOpenHelper"></a>CameraOpenHelper</h5><p>相机的帮助类，用于打开Camera以及处理Camera与TextureView的关联</p><h5 id="ITextureRenderer"><a href="#ITextureRenderer" class="headerlink" title="ITextureRenderer"></a>ITextureRenderer</h5><h5 id="TextureEGLRenderer"><a href="#TextureEGLRenderer" class="headerlink" title="TextureEGLRenderer"></a>TextureEGLRenderer</h5><pre><code>fun onSurfaceCreated()  //加载GL的一些东西，opengl的程序，着色器fun onSurfaceChanged(width: Int, height: Int)fun onDrawFrame(surfaceTexture: SurfaceTexture?)   //渲染</code></pre><h5 id="TextureEGLHelper"><a href="#TextureEGLHelper" class="headerlink" title="TextureEGLHelper"></a>TextureEGLHelper</h5><p><code>class TextureEGLHelper : SurfaceTexture.OnFrameAvailableListener</code></p><ul><li>提供 SurfaceTexture 给Camera</li><li>initEGLContext</li><li>HandlerThread  初始化/渲染</li></ul><h2 id="源码"><a href="#源码" class="headerlink" title="源码"></a>源码</h2><h4 id="CameraActivity-1"><a href="#CameraActivity-1" class="headerlink" title="CameraActivity"></a>CameraActivity</h4><p><code>com.wangzhumo.app.module.media.opengl.camera.CameraActivity</code></p><pre><code>    @SuppressLint(&quot;RestrictedApi&quot;)    override fun initViews(savedInstanceState: Bundle?) {        super.initViews(savedInstanceState)        val cameraOpenHelper = CameraOpenHelper(this)        cameraOpenHelper.bindCameraUseCases(viewFinder)    }</code></pre><p>这个<code>CameraActivity</code>很简单，只有xml里也只有一个<code>TextureView</code></p><h4 id="CameraOpenHelper-1"><a href="#CameraOpenHelper-1" class="headerlink" title="CameraOpenHelper"></a>CameraOpenHelper</h4><p><code>com.wangzhumo.app.module.media.opengl.camera.CameraOpenHelper</code></p><pre><code>class CameraOpenHelper constructor(private val lifeOwner: FragmentActivity) :    TextureView.SurfaceTextureListener{    private var textureEGLHelper: TextureEGLHelper? = null    private var viewFinder : TextureView? = null    private var mCamera: ICamera? = null    private var mCameraId = 0    fun bindCameraUseCases(textureView: TextureView) {        this.viewFinder = textureView        this.textureEGLHelper = TextureEGLHelper()        textureView.surfaceTextureListener = this    }    override fun onSurfaceTextureSizeChanged(surface: SurfaceTexture?, width: Int, height: Int) {        textureEGLHelper?.onSurfaceChanged(width, height)    }    override fun onSurfaceTextureUpdated(surface: SurfaceTexture?) {}    override fun onSurfaceTextureDestroyed(surface: SurfaceTexture?): Boolean {        onDestroy()        return false    }    override fun onSurfaceTextureAvailable(surface: SurfaceTexture?, width: Int, height: Int) {        //当外部的TextureView可用之后，开启摄像头，打开渲染线程        val textureId = TextureUtils.loadOESTexture()        textureEGLHelper?.initEGL(viewFinder,textureId)        //通过传递的textureId,构建一个SurfaceTexture，用于相机的预览        val surfaceTexture = textureEGLHelper?.loadOESTexture()        //不使用自己的SurfaceView，另外构建一个SurfaceView来接收Camera的预览数据        //前置摄像头        mCameraId = Camera.CameraInfo.CAMERA_FACING_FRONT        mCamera = CameraV1(lifeOwner)        mCamera?.apply {            openCamera(mCameraId)            setPreviewTexture(surfaceTexture)            enablePreview(true)        }    }</code></pre><h4 id="ITextureRenderer-1"><a href="#ITextureRenderer-1" class="headerlink" title="ITextureRenderer"></a>ITextureRenderer</h4><h4 id="TextureEGLRenderer-1"><a href="#TextureEGLRenderer-1" class="headerlink" title="TextureEGLRenderer"></a>TextureEGLRenderer</h4><pre><code>/** * If you have any questions, you can contact by email {wangzhumoo@gmail.com} * * @author 王诛魔 2019-11-22  21:31 * * 渲染实现 */class TextureEGLRenderer constructor(val textureId: Int) : ITextureRenderer {    /**     * 程序     */    private var mShaderProgram = -1    private var mOESTextureId = -1    private var mVertexBuffer: FloatBuffer    /**     * 变换矩阵     */    private val transformMatrix = FloatArray(16)    private var aPositionLocation = -1    private var aTextureCoordLocation = -1    private var uTextureMatrixLocation = -1    private var uTextureSamplerLocation = -1    init {        mVertexBuffer = TextureUtils.loadVertexBuffer(VERTEX_DATA)        mOESTextureId = textureId    }    override fun onSurfaceCreated() {        //加载GL的一些东西        val vertexShader = ShaderUtils.compileVertexShader(RawUtils.readResource(R.raw.vertex_texture_shader))        val fragmentShader = ShaderUtils.compileFragmentShader(RawUtils.readResource(R.raw.fragment_texture_shader))        Log.d(TAG,&quot;com.wangzhumo.app.module.media.opengl.camera.TextureEGLRenderer&quot;,&quot;onSurfaceCreated&quot;,56,&quot;vertexShader = $vertexShader , fragmentShader = $fragmentShader&quot;)        mShaderProgram = ShaderUtils.linkProgram(vertexShader, fragmentShader)        aPositionLocation = GLES30.glGetAttribLocation(mShaderProgram, POSITION_ATTRIBUTE)        aTextureCoordLocation = GLES30.glGetAttribLocation(mShaderProgram, TEXTURE_COORD_ATTRIBUTE)        uTextureMatrixLocation = GLES30.glGetUniformLocation(mShaderProgram, TEXTURE_MATRIX_UNIFORM)        uTextureSamplerLocation = GLES30.glGetUniformLocation(mShaderProgram, TEXTURE_SAMPLER_UNIFORM)        Log.d(TAG,&quot;com.wangzhumo.app.module.media.opengl.camera.TextureEGLRenderer&quot;,&quot;onSurfaceCreated&quot;,63,            &quot;mShaderProgram = $mShaderProgram , aPositionLocation = $aPositionLocation , aTextureCoordLocation = $aTextureCoordLocation , uTextureMatrixLocation = $uTextureSamplerLocation , uTextureSamplerLocation = $uTextureSamplerLocation&quot;)    }    override fun onSurfaceChanged(width: Int, height: Int) {        GLES30.glViewport(0, 0, width, height)    }    override fun onDrawFrame(surfaceTexture: SurfaceTexture?) {        GLES20.glClear(GLES20.GL_COLOR_BUFFER_BIT)        GLES30.glUseProgram(mShaderProgram)  //开始使用程序        surfaceTexture?.updateTexImage()        surfaceTexture?.getTransformMatrix(transformMatrix)        GLES30.glActiveTexture(GLES30.GL_TEXTURE0)        GLES30.glBindTexture(GLES11Ext.GL_TEXTURE_EXTERNAL_OES, mOESTextureId)        GLES30.glUniform1i(uTextureSamplerLocation, 0)        GLES30.glUniformMatrix4fv(            uTextureMatrixLocation,            1,            false,            transformMatrix,            0        )        mVertexBuffer.position(0)        GLES30.glEnableVertexAttribArray(aPositionLocation)        GLES30.glVertexAttribPointer(            aPositionLocation,            2,            GLES30.GL_FLOAT,            false,            STRIDE,            mVertexBuffer        )        mVertexBuffer.position(2)        GLES30.glEnableVertexAttribArray(aTextureCoordLocation)        GLES30.glVertexAttribPointer(            aTextureCoordLocation,            2,            GLES30.GL_FLOAT,            false,            STRIDE,            mVertexBuffer        )        GLES30.glDrawArrays(GLES30.GL_TRIANGLES, 0, 6)    }    companion object {        private const val TAG = &quot;TextureEGLRenderer&quot;        private const val POSITION_ATTRIBUTE = &quot;aPosition&quot;        private const val TEXTURE_COORD_ATTRIBUTE = &quot;aTextureCoord&quot;        private const val TEXTURE_MATRIX_UNIFORM = &quot;uTextureMatrix&quot;        private const val TEXTURE_SAMPLER_UNIFORM = &quot;uTextureSampler&quot;        private const val POSITION_SIZE = 2        private const val TEXTURE_SIZE = 2        private const val STRIDE = (POSITION_SIZE + TEXTURE_SIZE) * 4        /**         * 顶点数组         */        private val VERTEX_DATA = floatArrayOf(            1.0f, 1.0f, 1.0f, 1.0f,            -1.0f, 1.0f, 0.0f, 1.0f,            -1.0f, -1f, 0.0f, 0.0f,            1.0f, 1.0f, 1.0f, 1.0f,            -1.0f, -1.0f, 0f, 0.0f,            1.0f, -1.0f, 1.0f, 0.0f        )    }}</code></pre><p>这个<code>TextureEGLRenderer</code>中的GL渲染，大部分内容不是很熟，所以不做太多的解读，当姑且先当做固定的用法，先开始使用</p><h4 id="TextureEGLHelper-1"><a href="#TextureEGLHelper-1" class="headerlink" title="TextureEGLHelper"></a>TextureEGLHelper</h4><p><code>com.wangzhumo.app.module.media.opengl.camera.TextureEGLHelper</code></p><pre><code>class TextureEGLHelper : SurfaceTexture.OnFrameAvailableListener {    /**     * 渲染/初始化 线程     */    private var mHandlerThread: HandlerThread? = null    /**     * 渲染器     */    private var mRenderer: ITextureRenderer? = null    /**     * mHandlerThread 内部的Handler     */    private var mHandler: Handler? = null    /**     * 最终显示的TextureView     */    private var mTextureView: TextureView? = null    /**     * 纹理ID     */    private var mOESTextureId = 0    /**     * 显示设备     */    private var mEGLDisplay = EGL14.EGL_NO_DISPLAY    /**     * EGL上下文     */    private var mEGLContext = EGL14.EGL_NO_CONTEXT    /**     * EGL绘图surface     */    private var mEglSurface: EGLSurface? = null    /**     * 自定义的SurfaceTexture - 实际上接收Camera上的数据     */    private var mOESSurfaceTexture: SurfaceTexture? = null    /**     * @param textureView  外部的TextureView     * @param textureId    提供的TextureID     */    fun initEGL(textureView: TextureView?, textureId: Int) {        mTextureView = textureView        mOESTextureId = textureId        Log.d(TAG,&quot;com.wangzhumo.app.module.media.opengl.camera.TextureEGLHelper&quot;,&quot;initEGL&quot;,84,&quot;initEGL HandlerThread 创建&quot;)        mHandlerThread = HandlerThread(&quot;Renderer Thread&quot;)        Log.d(TAG,&quot;com.wangzhumo.app.module.media.opengl.camera.TextureEGLHelper&quot;,&quot;initEGL&quot;,85,&quot;initEGL HandlerThread 开始运行&quot;)        mHandlerThread?.start()        //此处的Handler，用于处理各种发送过来的命令        mHandler = object : Handler(mHandlerThread?.looper) {            override fun handleMessage(msg: Message) {                when (msg.what) {                    MSG_INIT -&gt; {                        //initEGLContext                        initEGLContext()   //初始化EGL环境                        initEGLRenderer()   //初始化渲染器                        //初始化 Renderer.                    }                    MSG_RENDER -&gt; {                        //开始渲染，onFrameAvailable中发送，由mHandlerThread负责渲染的调用。                        drawFrame()                    }                    MSG_DESTROY -&gt; {                        //mHandlerThread 关闭                        //停止mHandler                        //销毁资源                    }                    else -&gt; return                }            }        }        Log.d(TAG,&quot;com.wangzhumo.app.module.media.opengl.camera.TextureEGLHelper&quot;,&quot;initEGL&quot;,113,&quot;initEGL HandlerThread 开始运行 -- sendEmptyMessage(MSG_INIT)&quot;)        mHandler?.sendEmptyMessage(MSG_INIT)    }    /**     * 初始化EGLContext     */    private fun initEGLContext() {        Log.d(TAG,&quot;com.wangzhumo.app.module.media.opengl.camera.TextureEGLHelper&quot;,&quot;initEGLContext&quot;,122,&quot;initEGL initEGLContext start&quot;)        mEGLDisplay = EGL14.eglGetDisplay(EGL14.EGL_DEFAULT_DISPLAY)        //需判断是否成功获取EGLDisplay        if (mEGLDisplay == EGL14.EGL_NO_DISPLAY) {            throw  RuntimeException(&quot;Unable to get EGL14 display&quot;)        }        val versions = IntArray(2)        versions[0] = 3        if (!EGL14.eglInitialize(mEGLDisplay, versions, 0, versions, 1)) {            throw RuntimeException(&quot;eglInitialize failed! &quot; + EGL14.eglGetError())        }        //egl的一些配置        val eglConfigAttribute = intArrayOf(            EGL14.EGL_BUFFER_SIZE, 32,            EGL14.EGL_RED_SIZE, 8,            EGL14.EGL_GREEN_SIZE, 8,            EGL14.EGL_BLUE_SIZE, 8,            EGL14.EGL_ALPHA_SIZE, 8,            EGL14.EGL_RENDERABLE_TYPE, 4,            EGL14.EGL_SURFACE_TYPE, EGL14.EGL_WINDOW_BIT,            EGL14.EGL_NONE        )        val numConfig = IntArray(1)        val eglConfig = arrayOfNulls&lt;EGLConfig&gt;(1)        //EGL配置        val eglChooseFlag = EGL14.eglChooseConfig(            mEGLDisplay,            eglConfigAttribute,            0,            eglConfig,            0,            eglConfig.size,            numConfig,            0        )        if (!eglChooseFlag) {            throw RuntimeException(&quot;eglChooseConfig failed! &quot; + EGL14.eglGetError())        }        //创建EGL显示的窗口        val surfaceAttribute = intArrayOf(            EGL14.EGL_NONE        )        val surfaceTexture = mTextureView?.surfaceTexture        if (surfaceTexture == null) {            throw RuntimeException(&quot;surfaceTexture is null&quot;)        }        mEglSurface = EGL14.eglCreateWindowSurface(            mEGLDisplay,            eglConfig[0],            mTextureView?.surfaceTexture,            surfaceAttribute, 0        )        //创建上下文        val ctxAttribute = intArrayOf(            EGL14.EGL_CONTEXT_CLIENT_VERSION,            3,            EGL14.EGL_NONE        )        mEGLContext = EGL14.eglCreateContext(            mEGLDisplay,            eglConfig[0],            EGL14.EGL_NO_CONTEXT,            ctxAttribute, 0        )        //校验1        if (mEGLDisplay === EGL14.EGL_NO_DISPLAY || mEGLContext === EGL14.EGL_NO_CONTEXT) {            throw RuntimeException(&quot;eglCreateContext fail failed! &quot; + EGL14.eglGetError())        }        //校验2        val makeFlag = EGL14.eglMakeCurrent(mEGLDisplay, mEglSurface, mEglSurface, mEGLContext)        if (!makeFlag) {            throw RuntimeException(&quot;eglMakeCurrent failed! &quot; + EGL14.eglGetError())        }        Log.d(TAG,&quot;com.wangzhumo.app.module.media.opengl.camera.TextureEGLHelper&quot;,&quot;initEGLContext&quot;,191,&quot;initEGL initEGLContext end&quot;)    }    /**     * 初始化Renderer     */    private fun initEGLRenderer() {        Log.d(TAG,&quot;com.wangzhumo.app.module.media.opengl.camera.TextureEGLHelper&quot;,&quot;initEGLRenderer&quot;,220,&quot;initEGLRenderer  创建 TextureEGLRenderer&quot;)        mRenderer = TextureEGLRenderer(mOESTextureId)        mRenderer?.onSurfaceCreated()    }    /**     * 创建可以放在外部，但是为了加入监听方便，就放在这里初始化     */    fun loadOESTexture(): SurfaceTexture? {        Log.d(TAG,&quot;com.wangzhumo.app.module.media.opengl.camera.TextureEGLHelper&quot;,&quot;loadOESTexture&quot;,198,&quot;loadOESTexture 提供SurfaceTexture&quot;)        mOESSurfaceTexture = SurfaceTexture(mOESTextureId)        mOESSurfaceTexture?.setOnFrameAvailableListener(this)        Log.d(TAG,&quot;com.wangzhumo.app.module.media.opengl.camera.TextureEGLHelper&quot;,&quot;loadOESTexture&quot;,200,&quot;loadOESTexture 添加setOnFrameAvailableListener&quot;)        return mOESSurfaceTexture    }    /*     * setOnFrameAvailableListener   给 loadOESTexture 提供的SurfaceTexture使用     */    override fun onFrameAvailable(surfaceTexture: SurfaceTexture?) {        //frame可用之后，开始渲染        if (mHandler != null) {            //不能直接调用，需要在mHandlerThread中去渲染            mHandler?.sendEmptyMessage(MSG_RENDER)        }    }    /**     * 实际上渲染画面的方法     */    private fun drawFrame() {        if (mRenderer != null) {            EGL14.eglMakeCurrent(mEGLDisplay, mEglSurface, mEglSurface, mEGLContext)            mRenderer?.onDrawFrame(mOESSurfaceTexture)            EGL14.eglSwapBuffers(mEGLDisplay, mEglSurface)        }    }    /**     * onSurfaceChanged 回调     */    fun onSurfaceChanged(width: Int, height: Int) {        mRenderer?.onSurfaceChanged(width, height)    }    /**     * 释放资源     */    fun onDestroy() {        mHandler?.removeCallbacksAndMessages(null)        mHandlerThread?.quitSafely()    }    companion object {        var MSG_INIT = 100        var MSG_RENDER = 200        var MSG_DESTROY = 300        const val TAG = &quot;TextureEGLHelper&quot;    }}</code></pre><h3 id="工具类"><a href="#工具类" class="headerlink" title="工具类"></a>工具类</h3><h4 id="TextureUtils"><a href="#TextureUtils" class="headerlink" title="TextureUtils"></a>TextureUtils</h4><pre><code>/** * If you have any questions, you can contact by email {wangzhumoo@gmail.com} * * @author 王诛魔 2019-08-23$  23:31$ */object TextureUtils {    /**     * 加载OES Texture     *     * @return     */    @JvmStatic    fun loadOESTexture(): Int {        val textureIds = IntArray(1)        //textureIds 中存放一个textures中的可用值        GLES20.glGenTextures(1, textureIds, 0)        //当调用glBindTexture        //如果是第一次调用这个函数textureIds[0] ，会创建一个新的纹理对象        //如果textureIds[0]已经创建过了，把这个纹理置为 活动        //如果texture为0，就停止使用这个纹理对象，并返回无名称的默认纹理        GLES20.glBindTexture(GLES11Ext.GL_TEXTURE_EXTERNAL_OES, textureIds[0])        //设置参数        GLES20.glTexParameterf(            GLES11Ext.GL_TEXTURE_EXTERNAL_OES,            GLES20.GL_TEXTURE_MIN_FILTER,            GLES20.GL_NEAREST.toFloat()        )        GLES20.glTexParameterf(            GLES11Ext.GL_TEXTURE_EXTERNAL_OES,            GLES20.GL_TEXTURE_MAG_FILTER,            GLES20.GL_LINEAR.toFloat()        )        GLES20.glTexParameterf(            GLES11Ext.GL_TEXTURE_EXTERNAL_OES,            GLES20.GL_TEXTURE_WRAP_S,            GLES20.GL_CLAMP_TO_EDGE.toFloat()        )        GLES20.glTexParameterf(            GLES11Ext.GL_TEXTURE_EXTERNAL_OES,            GLES20.GL_TEXTURE_WRAP_T,            GLES20.GL_CLAMP_TO_EDGE.toFloat()        )        //取消绑定纹理，并且返回一个默认的纹理        GLES20.glBindTexture(GLES11Ext.GL_TEXTURE_EXTERNAL_OES, 0)        return textureIds[0]    }    /**     * 创建一个顶点Buffer     */    fun loadVertexBuffer(vertexData: FloatArray): FloatBuffer {        val buffer = ByteBuffer.allocateDirect(vertexData.size * 4)            .order(ByteOrder.nativeOrder())            .asFloatBuffer()        buffer.put(vertexData, 0, vertexData.size).position(0)        return buffer    }    /**     * 创建一个新的SurfaceTexture     */    fun loadOESTexture(mOESTextureId: Int): SurfaceTexture {        return SurfaceTexture(mOESTextureId)    }}</code></pre><h4 id="ShaderUtils"><a href="#ShaderUtils" class="headerlink" title="ShaderUtils"></a>ShaderUtils</h4><pre><code>/** * If you have any questions, you can contact by email {wangzhumoo@gmail.com} * * @author 王诛魔 2019-09-28  16:16 */object ShaderUtils {    /**     * 编译顶点着色器     *     * @param shaderCode     * @return     */    @JvmStatic    fun compileVertexShader(shaderCode: String): Int {        return compileShader(GLES30.GL_VERTEX_SHADER, shaderCode)    }    /**     * 编译片段着色器     *     * @param shaderCode     * @return     */    @JvmStatic    fun compileFragmentShader(shaderCode: String): Int {        return compileShader(GLES30.GL_FRAGMENT_SHADER, shaderCode)    }    /**     * 编译     *     * @param type       顶点着色器:GLES30.GL_VERTEX_SHADER     * 片段着色器:GLES30.GL_FRAGMENT_SHADER     * @param shaderCode     * @return     */    @JvmStatic    private fun compileShader(type: Int, shaderCode: String): Int {        //创建一个着色器        val shaderId = GLES30.glCreateShader(type)        if (shaderId != 0) {            GLES30.glShaderSource(shaderId, shaderCode)            GLES30.glCompileShader(shaderId)            //检测状态            val compileStatus = IntArray(1)            GLES30.glGetShaderiv(shaderId, GLES30.GL_COMPILE_STATUS, compileStatus, 0)            if (compileStatus[0] == 0) {                val logInfo = GLES30.glGetShaderInfoLog(shaderId)                System.err.println(logInfo)                //创建失败                GLES30.glDeleteShader(shaderId)                return 0            }            return shaderId        } else {            //创建失败            return 0        }    }    /**     * 链接小程序     *     * @param vertexShaderId   顶点着色器     * @param fragmentShaderId 片段着色器     * @return     */    @JvmStatic    fun linkProgram(vertexShaderId: Int, fragmentShaderId: Int): Int {        val programId = GLES30.glCreateProgram()        if (programId != 0) {            //将顶点着色器加入到程序            GLES30.glAttachShader(programId, vertexShaderId)            //将片元着色器加入到程序中            GLES30.glAttachShader(programId, fragmentShaderId)            //链接着色器程序            GLES30.glLinkProgram(programId)            val linkStatus = IntArray(1)            GLES30.glGetProgramiv(programId, GLES30.GL_LINK_STATUS, linkStatus, 0)            if (linkStatus[0] == 0) {                val logInfo = GLES30.glGetProgramInfoLog(programId)                System.err.println(logInfo)                GLES30.glDeleteProgram(programId)                return 0            }            return programId        } else {            //创建失败            return 0        }    }    /**     * 验证程序片段是否有效     *     * @param programObjectId     * @return     */    @JvmStatic    fun validProgram(programObjectId: Int): Boolean {        GLES30.glValidateProgram(programObjectId)        val programStatus = IntArray(1)        GLES30.glGetProgramiv(programObjectId, GLES30.GL_VALIDATE_STATUS, programStatus, 0)        return programStatus[0] != 0    }}</code></pre><h3 id="输出日志"><a href="#输出日志" class="headerlink" title="输出日志"></a>输出日志</h3><p>CameraActivity onCreated &lt;&lt;&lt;</p><p>CameraActivity, createTextureView, 69]:创建帮助类 CameraOpenHelper()</p><p>CameraActivity, createTextureView, 71]:绑定TextureView  bindCameraUseCases（textureView）</p><p>CameraOpenHelper, bindCameraUseCases, 39]:创建EGLHelper TextureEGLHelper（）</p><p>CameraOpenHelper, bindCameraUseCases, 36]:添加 surfaceTextureListener</p><p>CameraActivity onResumed &lt;&lt;&lt;</p><p>CameraOpenHelper, onSurfaceTextureAvailable, 85]:onSurfaceTextureAvailable  loadOESTexture = 0</p><p>TextureEGLHelper, initEGL, 84]:initEGL HandlerThread 创建</p><p>TextureEGLHelper, initEGL, 85]:initEGL HandlerThread 开始运行</p><p>TextureEGLHelper, initEGL, 113]:initEGL HandlerThread 开始运行 – sendEmptyMessage(MSG_INIT)</p><p>TextureEGLHelper, loadOESTexture, 198]:loadOESTexture 提供SurfaceTexture</p><p>TextureEGLHelper, loadOESTexture, 200]:loadOESTexture 添加setOnFrameAvailableListener</p><p>TextureEGLHelper, initEGLContext, 122]:initEGL initEGLContext start</p><p>TextureEGLHelper, initEGLContext, 191]:initEGL initEGLContext end</p><p>TextureEGLHelper, initEGLRenderer, 220]:initEGLRenderer  创建 TextureEGLRenderer</p><p>TextureEGLRenderer, init, 49]:mOESTextureId = 0 , mVertexBuffer = 24</p><p>TextureEGLRenderer, onSurfaceCreated, 63]:mShaderProgram = 3 , aPositionLocation = 0 , aTextureCoordLocation = 1 , uTextureMatrixLocation = 1 , uTextureSamplerLocation = 1</p><p>CameraOpenHelper, onSurfaceTextureAvailable, 95]:onSurfaceTextureAvailable  enablePreview  开启摄像头</p><p><img src="/Users/wangzhumo/Develop/hexo/source/images/camera_texture_img.png" srcset="/img/loading.gif" alt="效果图"></p>]]></content>
    
    
    <categories>
      
      <category>Media</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Media</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Ubuntu安装coturn服务</title>
    <link href="undefined2019/11/06/coturn-install-ubuntu/"/>
    <url>2019/11/06/coturn-install-ubuntu/</url>
    
    <content type="html"><![CDATA[<h2 id="coturn-project"><a href="#coturn-project" class="headerlink" title="coturn project"></a>coturn project</h2><p>This project evolved from rfc5766-turn-server project (<a href="https://code.google.com/p/rfc5766-turn-server/" target="_blank" rel="noopener">https://code.google.com/p/rfc5766-turn-server/</a>).</p><p>这是一个穿透服务，为webrtc的链接做服务,按照rfc5766-turn-server实现。</p><a id="more"></a><p><strong>项目地址</strong>：<a href="https://github.com/coturn/coturn" target="_blank" rel="noopener">https://github.com/coturn/coturn</a></p><p><strong>安装Wiki</strong>: <a href="https://github.com/coturn/coturn/wiki/CoturnConfig" target="_blank" rel="noopener">https://github.com/coturn/coturn/wiki/CoturnConfig</a></p><h2 id="依赖库Third-party-libraries"><a href="#依赖库Third-party-libraries" class="headerlink" title="依赖库Third-party libraries"></a>依赖库Third-party libraries</h2><h3 id="libevent"><a href="#libevent" class="headerlink" title="libevent"></a>libevent</h3><pre><code>$ wget https://github.com/downloads/libevent/libevent/libevent-2.0.21-stable.tar.gz# 需要sodu权限$ tar xvfz libevent-2.0.21-stable.tar.gz$ cd libevent-2.0.21-stable$ ./configure$ make$ make install</code></pre><p>安装完毕 <code>/usr/local/lib</code></p><h2 id="coturn-install"><a href="#coturn-install" class="headerlink" title="coturn install"></a>coturn install</h2><p><strong>下载地址</strong>：<a href="https://github.com/coturn/coturn/wiki/Downloads" target="_blank" rel="noopener">https://github.com/coturn/coturn/wiki/Downloads</a></p><h3 id="下载"><a href="#下载" class="headerlink" title="下载"></a>下载</h3><h4 id="方式一："><a href="#方式一：" class="headerlink" title="方式一："></a>方式一：</h4><p>我选择了最新的版本，4.5.0.8</p><pre><code>$ wget https://coturn.net/turnserver/v4.5.0.8/turnserver-4.5.0.8.tar.gz</code></pre><p>一直下载失败..所以我在本地下载了，上传到服务器  <code>home/wangzhumo/source</code></p><h4 id="方式二："><a href="#方式二：" class="headerlink" title="方式二："></a>方式二：</h4><pre><code>$ cd /home/wangzhumo/source$ git clone https://github.com/coturn/coturn</code></pre><h3 id="编译"><a href="#编译" class="headerlink" title="编译"></a>编译</h3><pre><code># 解压$ tar -xvf turnserver-4.5.0.8.tar$ cd turnserver-4.5.0.8$ ./configure$ make$ sudo make install</code></pre><pre><code># 记录安装位置install -d /usr/localinstall -d /usr/local/bininstall -d /usr/local/var/dbinstall -d /usr/local/man/man1install -d /usr/local/etcinstall -d /usr/local/libinstall -d /usr/local/share/examples/turnserverinstall -d /usr/local/share/doc/turnserverinstall -d /usr/local/share/turnserverinstall -d /usr/local/include/turn1) If your system supports automatic start-up system daemon services, then to enable the turnserver as a system service that is automaticallystarted, you have to:    a) Create and edit /etc/turnserver.conf or     /usr/local/etc/turnserver.conf .     Use /usr/local/etc/turnserver.conf.default as an example.    b) For user accounts settings: set up SQLite or PostgreSQL or     MySQL or MongoDB or Redis database for user accounts.    Use /usr/local/share/turnserver/schema.sql as SQL database schema,    or use /usr/local/share/turnserver/schema.userdb.redis as Redis    database schema description and/or     /usr/local/share/turnserver/schema.stats.redis    as Redis status &amp; statistics database schema description.    If you are using SQLite, the default database location is in     /var/db/turndb or in /usr/local/var/db/turndb or in /var/lib/turn/turndb.    c) add whatever is necessary to enable start-up daemon for the     /usr/local/bin/turnserver.2) If you do not want the turnserver to be a system service,    then you can start/stop it &quot;manually&quot;, using the &quot;turnserver&quot;    executable with appropriate options (see the documentation).3) To create database schema, use schema in file /usr/local/share/turnserver/schema.sql.4) For additional information, run:   $ man turnserver   $ man turnadmin   $ man turnutils</code></pre><h2 id="coturn-配置"><a href="#coturn-配置" class="headerlink" title="coturn 配置"></a>coturn 配置</h2><h3 id="turnserver-conf"><a href="#turnserver-conf" class="headerlink" title="turnserver.conf"></a>turnserver.conf</h3><pre><code>$ sudo vim /usr/local/etc/turnserver.conf.default</code></pre><p>要修改的地方只有5处：</p><ul><li><p>listening-port=3478</p></li><li><p>external-ip=[服务器的ip]</p></li><li><p>min-port=50001  </p><p>max-port=65535</p></li><li><p>user=wangzhumo:webrtcpwd</p></li><li><p>realm=stun.wangzhumo.com</p></li></ul><pre><code>$ sudo mv /usr/local/etc/turnserver.conf.default /usr/local/etc/turnserver.conf</code></pre><h3 id="防火墙"><a href="#防火墙" class="headerlink" title="防火墙"></a>防火墙</h3><p>1.打开云服务器的 安全组 ，加入  3478 ，50001—65535</p><p>2.本机的防火墙</p><h2 id="coturn-开启"><a href="#coturn-开启" class="headerlink" title="coturn 开启"></a>coturn 开启</h2><pre><code>$ turnserver -o -c /usr/local/etc/turnserver.conf</code></pre><h3 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h3><p>测试地址：<a href="https://webrtc.github.io/samples/src/content/peerconnection/trickle-ice/" target="_blank" rel="noopener">https://webrtc.github.io/samples/src/content/peerconnection/trickle-ice/</a></p><p>1.输入：</p><p>STUN or TURN URI:   turn:stun.wangzhumo.com</p><p>TURN username:  wangzhumo</p><p>TURN password:  webrtcpwd</p><p>2.Add Server</p><p>3.Gather candidates</p><p>测试结果：</p><pre><code>Time    Component    Type    Foundation    Protocol    Address    Port    Priority0.003    rtp    host    2749607730    udp    172.30.21.85    60720    126 | 30 | 2557.794    rtp    srflx    842163049    udp    221.221.255.18    33338    100 | 30 | 2557.825    rtp    relay    1676812102    udp    171.51.157.190    65032    2 | 30 | 2557.825    Done7.827</code></pre><p>看到relay类型的就说明成功了</p><h2 id="END"><a href="#END" class="headerlink" title="END"></a>END</h2>]]></content>
    
    
    <categories>
      
      <category>Media</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Server</tag>
      
      <tag>Media</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>JNI 认识JNI的基本概念</title>
    <link href="undefined2018/10/28/jni-basic-conception/"/>
    <url>2018/10/28/jni-basic-conception/</url>
    
    <content type="html"><![CDATA[<h4 id="JNIEnv"><a href="#JNIEnv" class="headerlink" title="JNIEnv"></a>JNIEnv</h4><p>在Android的世界中,我们编写完成的源代码都被编译成class文件，而Android又为了避免一些问题，提供了Dalvik VM，Dalvik虚拟机负责把dex文件载入。</p><p>那么 .so 文件怎么运行那？</p><p>肯定也是要在Dalvik VM中的,要不怎么互相调用那？总不能靠意念把</p>]]></content>
    
    
    <categories>
      
      <category>JNI</category>
      
    </categories>
    
    
    <tags>
      
      <tag>JNI</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>JNI-从Android Studio默认工程认识JNI</title>
    <link href="undefined2018/10/28/taste-jni-default-project/"/>
    <url>2018/10/28/taste-jni-default-project/</url>
    
    <content type="html"><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>对于JNI,Google为我们提供了一个入门文档</p><blockquote><p><a href="https://developer.android.com/ndk/guides/" target="_blank" rel="noopener">https://developer.android.com/ndk/guides/</a></p></blockquote><p>我们为什么要使用JNI那？Google已经很明确的为我们指明了：</p><ul><li>在平台之间移植其应用。</li><li>重复使用现有库，或者提供其自己的库供重复使用。</li><li>在某些情况下提高性能，特别是像游戏这种计算密集型应用。</li></ul><a id="more"></a><p>本来是打算学习NDK的老一套的，不过最近学习的课程刚好讲到这个部分，使用CMake的方式的，所以我就直接学习最新的JNI使用方式了。</p><h3 id="工程结构"><a href="#工程结构" class="headerlink" title="工程结构"></a>工程结构</h3><pre><code class="shell">.├── CMakeLists.txt├── build.gradle└── src    ├── main        ├── AndroidManifest.xml        ├── cpp        │   └── native-lib.cpp        ├── java</code></pre><p>当我们创建好一个支持C++的Android项目后，会得到这样的一个项目结构（不重要的省略掉了）</p><ul><li>CMakeLists.txt  是CMake的配置文件</li><li>build.gradle       Android的构建工具</li><li>Src   是Java &amp; C 的源码文件目录<ul><li>cpp 是C源码</li><li>java 是Java的源码</li></ul></li></ul><h3 id="CMakeLists-txt"><a href="#CMakeLists-txt" class="headerlink" title="CMakeLists.txt"></a>CMakeLists.txt</h3><pre><code class="shell"># Sets the minimum version of CMake required to build the native library.cmake_minimum_required(VERSION 3.4.1)# 根据C文件生成库文件# 可以添加其他的非系统库add_library( # Sets the name of the library.        native-lib        # Sets the library as a shared(动态库) library.        SHARED        # Provides a relative path to your source(源文件) file(s).        src/main/cpp/native-lib.cpp)# 添加你需要使用的系统库find_library( # Sets the name of the path variable.        log-lib        # Specifies(指定一个名字) the name of the NDK library that        # you want CMake to locate.        log)# 将库链接起来# 下面写你需要链接的库target_link_libraries( # Specifies the target library.        native-lib        # Links the target library to the log library        # included in the NDK.        ${log-lib})</code></pre><p>当你编译成功后，可以在<code>app/build/intermediates/cmake/</code>的目录下看到你编译成功生成的.so文件</p><h3 id="Android部分"><a href="#Android部分" class="headerlink" title="Android部分"></a>Android部分</h3><pre><code class="java">public class MainActivity extends AppCompatActivity {    // Used to load the &#39;native-lib&#39; library on application startup.    // 把库读取到java中来 libnative-lib.so  ,注意要去掉lib这个前缀    static {        System.loadLibrary(&quot;native-lib&quot;);    }    @Override    protected void onCreate(Bundle savedInstanceState) {        super.onCreate(savedInstanceState);        setContentView(R.layout.activity_main);        // Example of a call to a native method        TextView tv = (TextView) findViewById(R.id.sample_text);        // 可以看到这里直接调用了 ·native· 方法        tv.setText(stringFromJNI());    }    /**     * A native method that is implemented by the &#39;native-lib&#39; native library,     * which is packaged with this application.     */    public native String stringFromJNI();}</code></pre><h3 id="native部分"><a href="#native部分" class="headerlink" title="native部分"></a>native部分</h3><pre><code class="c">#include &lt;jni.h&gt;#include &lt;string&gt;extern &quot;C&quot; JNIEXPORT jstring JNICALLJava_com_wangzhumo_jni_MainActivity_stringFromJNI(   //注意这个,是制定的格式                                                    // javah可以生成 or 手写        JNIEnv *env,        jobject /* this */) {    std::string hello = &quot;Hello from C++&quot;;    return env-&gt;NewStringUTF(hello.c_str());}</code></pre>]]></content>
    
    
    <categories>
      
      <category>JNI</category>
      
    </categories>
    
    
    <tags>
      
      <tag>JNI</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>认识时域与频域</title>
    <link href="undefined2018/09/21/time-and-frequency-domain/"/>
    <url>2018/09/21/time-and-frequency-domain/</url>
    
    <content type="html"><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>我也没想到我有一天会捡起这些东西，我一个数学弱鸡压力山大。</p><p>起因是最近在学习音视频开发，我发现一涉及到理论知识这块，总会有几个 <code>时域</code>，<code>频域</code>，<code>傅里叶变化</code>这样的名词出现，我能怎么办，学呗</p><p>链接：</p><blockquote><p>信号频域和时域的关系？</p><p><a href="https://www.zhihu.com/question/21040374" target="_blank" rel="noopener">https://www.zhihu.com/question/21040374</a></p></blockquote><p>想学习一个东西，首先要搞明白是什么？然后才能继续去认识它。</p><p>而我始终认为，学习也是由浅入深的，由点及面的，不可能一上来就认识到了它的核心理论。</p><h3 id="简单的认识"><a href="#简单的认识" class="headerlink" title="简单的认识"></a>简单的认识</h3><blockquote><p>@航空航天迷 </p><p><a href="https://www.zhihu.com/people/jin-it/activities" target="_blank" rel="noopener">https://www.zhihu.com/people/jin-it/activities</a></p></blockquote><p>这位大兄弟的图是我的启蒙。</p><p><img src="/images/time_domain.png" srcset="/img/loading.gif" alt="时域"></p><p>这张图就是一个时域图，可以看到这个正弦波，x轴上是时间的变化，y轴就是振幅了</p><ul><li><p>频率 ：6Hz</p></li><li><p>振幅 ：5V</p></li></ul><p><img src="/images/frequency_domain.png" srcset="/img/loading.gif" alt="频域"></p><p>这里就是图1中正弦波的频域图</p><p>我们可以看到x轴是频率了，y轴就是振幅了</p><p>其中绿色的线，其x轴的交点是指这个正弦波的频率是6,它的高度就是这个正弦波的波峰了5V</p><h3 id="进一步认识"><a href="#进一步认识" class="headerlink" title="进一步认识"></a>进一步认识</h3><p>来自：</p><blockquote><p>@一二</p><p><a href="https://www.zhihu.com/people/yier-64/activities" target="_blank" rel="noopener">https://www.zhihu.com/people/yier-64/activities</a></p><p><a href="https://zh.wikipedia.org/wiki/%E5%82%85%E9%87%8C%E5%8F%B6%E5%8F%98%E6%8D%A2#" target="_blank" rel="noopener">https://zh.wikipedia.org/wiki/%E5%82%85%E9%87%8C%E5%8F%B6%E5%8F%98%E6%8D%A2#</a></p></blockquote><p><img src="/images/fuliye_gif.gif" srcset="/img/loading.gif" alt="git"></p><p>傅里叶变换将函数的时域（红色）与频域（蓝色）相关联</p><p>刚开始的时候我没看前面 <code>@航空航天迷</code>的答案，直接在CSDN上查的，然后就我懵逼了。</p><blockquote><p><a href="https://blog.csdn.net/jiujiaobusiniao/article/details/53321491" target="_blank" rel="noopener">https://blog.csdn.net/jiujiaobusiniao/article/details/53321491</a></p></blockquote><p>盯着这几张图看了很久，很久。。。</p><h3 id="开始理解"><a href="#开始理解" class="headerlink" title="开始理解"></a>开始理解</h3><blockquote><p>@Heinrich</p><p><a href="https://www.zhihu.com/people/Erdnussoelbearbeiter/activities" target="_blank" rel="noopener">https://www.zhihu.com/people/Erdnussoelbearbeiter/activities</a></p><p>傅里叶分析之掐死教程</p><p><a href="https://zhuanlan.zhihu.com/p/19763358?refer=wille" target="_blank" rel="noopener">https://zhuanlan.zhihu.com/p/19763358?refer=wille</a></p></blockquote><p>真的是给大佬递烟。</p><p>大佬，火</p><p><img src="/images/time_frequency_domain.jpg" srcset="/img/loading.gif" alt="time_frequency_domain"></p><p>下一步我们就看看傅里叶变换</p>]]></content>
    
    
    <categories>
      
      <category>Other</category>
      
    </categories>
    
    
    <tags>
      
      <tag>frequency</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>音视频-FFmpeg的编译与安装</title>
    <link href="undefined2018/09/20/ffmpeg-build-install/"/>
    <url>2018/09/20/ffmpeg-build-install/</url>
    
    <content type="html"><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>正如FFmpeg的简介所说</p><blockquote><p>FFmpeg is a collection of libraries and tools to process multimedia content such as audio, video, subtitles and related metadata.</p></blockquote><p>FFmpeg在音视频领域算得上是集大成者，功能丰富，并且可以自行替换添加编码标准等</p><p>可以做到录制，播放，解码，转码，滤镜等等，所以它被很多公司采用。</p><a id="more"></a><ul><li><code>libavcodec</code> 编解码.</li><li><code>libavformat</code> 音视频的解封装</li><li><code>libavutil</code> 工具函数</li><li><code>libavfilter</code> 音视频滤波器（滤镜）</li><li><code>libavdevice</code> 硬件的音视频采集、加速和显示</li><li><code>libswresample</code> 重采样，采样格式转换和混合</li><li><code>libswscale</code> 原始视频的缩放，色彩映射转换，图像颜色空间或格式转换</li></ul><p>FFmpeg </p><blockquote><p>官方网站 <a href="https://ffmpeg.org/" target="_blank" rel="noopener">https://ffmpeg.org/</a></p><p>Github    <a href="https://github.com/FFmpeg/FFmpeg" target="_blank" rel="noopener">https://github.com/FFmpeg/FFmpeg</a></p></blockquote><h4 id="Homebrew"><a href="#Homebrew" class="headerlink" title="Homebrew"></a>Homebrew</h4><pre><code class="shell"># phyooos @ wangzhumo in ~ [20:58:24] C:127$ brew install ffmpeg --with-sdl2 --with-fdk-aac --with-freetype --with-libass  --with-libvorbis --with-libvpx --with-opus --with-x265 #经过一段时间的下载==&gt; ./configure --prefix=/usr/local/Cellar/ffmpeg/4.0.2 --enable-shared --enable-pthreads --ena==&gt; make install🍺  /usr/local/Cellar/ffmpeg/4.0.2: 251 files, 53.2MB, built in 8 minutes 1 second#好了已经安装成功了</code></pre><p>注意<code>--with-sdl2</code> 其实就是<code>ffplay</code></p><p><code>--with-ffplay</code>已经过时被<code>--with-sdl2</code>替代了，所以一定要替换掉，要不然<code>ffplay</code>的安装会失败</p><p>如果你不想自己手动编译安装，那么这里已经够了，下文是手动的编译安装记录。</p><h3 id="编译"><a href="#编译" class="headerlink" title="编译"></a>编译</h3><h4 id="下载"><a href="#下载" class="headerlink" title="下载"></a>下载</h4><p>官方网站：</p><blockquote><p><a href="http://ffmpeg.org/download.html" target="_blank" rel="noopener">http://ffmpeg.org/download.html</a></p></blockquote><p>下载解压，目录ffmpeg</p><p>Git:</p><pre><code class="shell">git clone https://git.ffmpeg.org/ffmpeg.git ffmpeg</code></pre><h4 id="准备其他库"><a href="#准备其他库" class="headerlink" title="准备其他库"></a>准备其他库</h4><h5 id="brew-insatll"><a href="#brew-insatll" class="headerlink" title="brew insatll"></a>brew insatll</h5><blockquote><p>brew install pkg-config</p><p>brew install speex</p><p>brew install x264</p><p>brew install x265</p><p>brew install libsoxr</p></blockquote><h5 id="opencore"><a href="#opencore" class="headerlink" title="opencore"></a>opencore</h5><blockquote><p><a href="https://sourceforge.net/projects/opencore-amr/" target="_blank" rel="noopener">https://sourceforge.net/projects/opencore-amr/</a></p></blockquote><pre><code class="shell">$ ./configure$ make$ make install</code></pre><h5 id="fdk-acc"><a href="#fdk-acc" class="headerlink" title="fdk-acc"></a>fdk-acc</h5><blockquote><p><a href="https://sourceforge.net/projects/opencore-amr/files/fdk-aac/" target="_blank" rel="noopener">https://sourceforge.net/projects/opencore-amr/files/fdk-aac/</a></p></blockquote><p>##### </p><h4 id="编译开始"><a href="#编译开始" class="headerlink" title="编译开始"></a>编译开始</h4><h6 id="编写build-mac-os-sh"><a href="#编写build-mac-os-sh" class="headerlink" title="编写build_mac_os.sh"></a>编写build_mac_os.sh</h6><pre><code class="shell">#进入ffmpeg目录cd ~/ffmpeg#创建文件build_mac_os.shvim ./build_mac_os.sh#文件写入./configure --cc=/usr/bin/clang  \    --prefix=/usr/local/ffmpeg \    --enable-gpl \    --enable-nonfree \    --enable-libfdk-aac \    --enable-libx264 \    --enable-libmp3lame \    --enable-libopencore-amrnb \    --enable-libopencore-amrwb \    --enable-libx265 \    --enable-filter=delogo \    --enable-debug \    --disable-optimizations \    --enable-libspeex \    --enable-videotoolbox \    --enable-shared \    --enable-pthreads \    --enable-version3 \    --enable-hardcoded-tables \    --host-cflags= \    --host-ldflags= make clean#执行文件sudo ./build_mac_os.sh</code></pre><h3 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h3><h6 id="make-amp-amp-make-install"><a href="#make-amp-amp-make-install" class="headerlink" title="make &amp;&amp; make install"></a>make &amp;&amp; make install</h6><p>等待上面的命令执行完毕，则</p><pre><code class="shell">make &amp;&amp; make install</code></pre><h3 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h3><h4 id="简单的录屏"><a href="#简单的录屏" class="headerlink" title="简单的录屏"></a>简单的录屏</h4><h5 id="查找设备"><a href="#查找设备" class="headerlink" title="查找设备"></a>查找设备</h5><pre><code class="shell"># phyooos @ wangzhumo in ~ [10:51:09] C:1$ ffmpeg -f avfoundation -list_devices true -i &quot;&quot; # 注意上面命令-i  的参数就是 ”“ 别忘了#输出：#...[AVFoundation input device @ 0x7fe495402280] AVFoundation video devices:[AVFoundation input device @ 0x7fe495402280] [0] FaceTime HD Camera[AVFoundation input device @ 0x7fe495402280] [1] Capture screen 0[AVFoundation input device @ 0x7fe495402280] [2] Capture screen 1[AVFoundation input device @ 0x7fe495402280] AVFoundation audio devices:[AVFoundation input device @ 0x7fe495402280] [0] Built-in Microphone: Input/output error</code></pre><p>可以看到<code>AVFoundation video devices</code>的设备有3个</p><p>[0] 摄像头</p><p>[1] 屏幕1</p><p>[2] 屏幕2</p><h5 id="录制"><a href="#录制" class="headerlink" title="录制"></a>录制</h5><pre><code class="shell">ffmpeg -f avfoundation -i 1 -r 30 ~/Downloads/out.yuv</code></pre><p>使用<code>Ctrl + c</code>终止录制</p><ul><li>-f  使用 <code>avfoundation</code>来录制</li><li>-i  指定了当前用来录制的设备，这里的<code>1</code></li><li>-r  帧率30</li><li>out.yuv 输出文件</li></ul><h4 id="简单的播放"><a href="#简单的播放" class="headerlink" title="简单的播放"></a>简单的播放</h4><p>在录制过程中，有打印录制的参数</p><pre><code class="shell">Metadata:    encoder         : Lavf58.12.100    Stream #0:0: Video: rawvideo (UYVY / 0x59565955), uyvy422, 2880x1800, q=2-31, 2488320 kb/s, 30 fps, 30 tbn, 30 tbc</code></pre><p>我们使用<code>ffplay</code>进行播放</p><pre><code class="shell">ffplay -s 2880x1800 -pixel_format uyvy422 ~/Downloads/out.yuv</code></pre><ul><li>-s 指定分辨率</li><li>-pixel_format 编码格式 </li></ul><p>添加至环境变量</p>]]></content>
    
    
    <categories>
      
      <category>Media</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Media</tag>
      
      <tag>FFmpeg</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>音视频-音频的基础理论</title>
    <link href="undefined2018/09/08/multimedia-learn-audio-base/"/>
    <url>2018/09/08/multimedia-learn-audio-base/</url>
    
    <content type="html"><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><h5 id="声音"><a href="#声音" class="headerlink" title="声音"></a>声音</h5><p>学过物理的我们都知道,声音其实就是一种物体的震动</p><p>而声音有三要素: 频率,振幅,波形</p><ul><li>频率,代表着声音的音阶高低</li><li>振幅,标志着音声的响度</li><li>波形,既是声色</li></ul><p>那么音频信号要做的就是把这些震动转化为数字信号,对模拟信号进行采样,在时间轴上对模拟信号数字化,根据采样的频率,每一秒对模拟信号采样n次.</p><a id="more"></a><h3 id="认识PCM"><a href="#认识PCM" class="headerlink" title="认识PCM"></a>认识PCM</h3><h5 id="PCM"><a href="#PCM" class="headerlink" title="PCM"></a>PCM</h5><p>既然要把声音采集为数字信号,那么肯定就有一种编码的格式,而常用的就是<code>PCM(Pulse Code Modulation)脉冲编码调制</code>格式.</p><p>PCM还有几个关键的概念,它们共同描述了一段PCM的数据.</p><ul><li><p>量化格式(sampleFormat) </p><p>也有叫采样位数的,代表着描述数字信号所使用的位数,8bit(已经很少用了)、16bit(一般使用这个)和24bit</p></li><li><p>采样率(sampleRate) </p><p>我们知道人的耳朵能听到的范围是20Hz - 20kHz,我们的采样率如果高于这个值,则必定可以保证声音的还原,</p><p>比如我们使用44.1kHz采样率</p></li><li><p>声道数(channel)</p><p>声道数就是指,声音在录制或播放时不同空间位置</p><ul><li>单声道 采样数据为8位的短整数(short)</li><li>双声道 采样数据为16位的整数(int)  <em>高八位(左声道)和低八位(右声道)</em></li></ul></li></ul><p>还有一个概念,<strong>比特率</strong>需要我们注意:它指的是每一秒的比特数,用来衡量单位时间内音频数据的容量大小</p><p>举个例子: 一个44.1kHz      双声道       16bit量化格式</p><pre><code class="java">44100 * 2 * 16 = 1411.2kbps//把bps装换为MB1411.2k / 8 / 1024  =  172Kb/s172 * 60   = 10.08Mb</code></pre><p>PCM其实一般并不用来编码传输,他经常是作为一个裸数据来使用的,没有经过压缩的.</p><h3 id="音频编码"><a href="#音频编码" class="headerlink" title="音频编码"></a>音频编码</h3><p>常见的比如<code>PCM</code>,<code>ACC</code>,<code>MP3</code>,<code>WAV</code>等等</p><h4 id="WAV"><a href="#WAV" class="headerlink" title="WAV"></a>WAV</h4><p>我们一般不会用这种格式来进行传输,经常是作为本地文件来使用的.</p><p><strong>特点</strong>:支持广泛,音质好</p><p><strong>用途</strong>:经常被用来做音乐素材,以及我们开发的中间文件</p><h4 id="MP3"><a href="#MP3" class="headerlink" title="MP3"></a>MP3</h4><p>MP3拥有不错的压缩比,这也是一种兼容非常广泛一种编码格式</p><p><strong>特点</strong>: 音质在128Kbit/s以上表现的较为不错,压缩比高,兼容性好</p><p><strong>用途</strong>:高比特率下的音乐.</p><h4 id="ACC"><a href="#ACC" class="headerlink" title="ACC"></a>ACC</h4><p>新一代的音频压缩编码技术,使用了有损压缩,可以在128kbit/s的高码率</p>]]></content>
    
    
    <categories>
      
      <category>Media</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Media</tag>
      
      <tag>Audio</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>音视频-入门路径</title>
    <link href="undefined2018/09/01/multimedia-learn/"/>
    <url>2018/09/01/multimedia-learn/</url>
    
    <content type="html"><![CDATA[<h3 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h3><p>雷神：</p><blockquote><p><a href="https://blog.csdn.net/column/details/ffmpeg-devel.html" target="_blank" rel="noopener">https://blog.csdn.net/column/details/ffmpeg-devel.html</a>   </p></blockquote><p>google提供的文档：</p><blockquote><p><a href="https://source.android.com/devices/graphics/" target="_blank" rel="noopener">https://source.android.com/devices/graphics/</a></p><p><a href="https://source.android.com/devices/audio" target="_blank" rel="noopener">https://source.android.com/devices/audio</a></p></blockquote><p>Jhuster的专栏</p><blockquote><p><a href="http://blog.51cto.com/ticktick/category15.html" target="_blank" rel="noopener">http://blog.51cto.com/ticktick/category15.html</a></p></blockquote><p>Android 音视频开发学习思路</p><blockquote><p><a href="https://www.cnblogs.com/renhui/p/7452572.html" target="_blank" rel="noopener">https://www.cnblogs.com/renhui/p/7452572.html</a></p></blockquote>]]></content>
    
    
    <categories>
      
      <category>Media</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Media</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Flutter在Mac上的安装</title>
    <link href="undefined2018/08/26/flutter-install-china/"/>
    <url>2018/08/26/flutter-install-china/</url>
    
    <content type="html"><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>换电脑了，重新安装环境，此篇作为一个笔记</p><p>之前的记录已经过时了，现在有更方便的安装方式，如下</p><p><strong>环境</strong></p><ul><li>macOS</li><li>git</li><li>终端</li></ul><a id="more"></a><h3 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h3><h4 id="安装文档"><a href="#安装文档" class="headerlink" title="安装文档"></a>安装文档</h4><p>最好的途径必然是官网，没啥悬念</p><blockquote><p><a href="https://flutter.io/setup-macos/" target="_blank" rel="noopener">https://flutter.io/setup-macos/</a></p></blockquote><p>但是作为中国的开发者，就有一个特殊的待遇，单独的安装文档。。(都是墙的锅)</p><blockquote><p><a href="https://github.com/flutter/flutter/wiki/Using-Flutter-in-China" target="_blank" rel="noopener">https://github.com/flutter/flutter/wiki/Using-Flutter-in-China</a></p></blockquote><h4 id="配置源"><a href="#配置源" class="headerlink" title="配置源"></a>配置源</h4><p>当我们拉取Flutter的资源的时候，是需要一个源提供资源的，通常都是去官方的服务起去拉取，但是还是因为墙的问题，及其难链接上服务器，甚至根本就无法链接。</p><p> 于是就有了部署在国内的镜像，需要添加到 <code>~/.bash_profile</code>或者直接在终端中指定</p><pre><code class="shell">export PUB_HOSTED_URL=https://pub.flutter-io.cn export FLUTTER_STORAGE_BASE_URL=https://storage.flutter-io.cn//source ~/.bash_profile</code></pre><p>在GitHub上的文档还指出，上海交通大学也有一个镜像</p><p>Shanghai Jiaotong University Linux User Group：</p><pre><code class="shell">FLUTTER_STORAGE_BASE_URL: https://mirrors.sjtug.sjtu.edu.cn/PUB_HOSTED_URL: https://dart-pub.mirrors.sjtug.sjtu.edu.cn/</code></pre><p>这个也是可以用的，同样的在<code>~/.bash_profile</code>中配置或者直接在终端中指定，替换掉</p><p><a href="https://pub.flutter-io.cn和https://storage.flutter-io.cn" target="_blank" rel="noopener">https://pub.flutter-io.cn和https://storage.flutter-io.cn</a></p><h4 id="BUG解决"><a href="#BUG解决" class="headerlink" title="BUG解决"></a>BUG解决</h4><pre><code class="shell">Building flutter tool...Because flutter_tools depends on file_testing 2.0.3 which doesn&#39;t match any versions, version solvingfailed.Error: Unable to &#39;pub upgrade&#39; flutter tool. Retrying in five seconds... (9 tries left)</code></pre><blockquote><p><a href="https://github.com/flutter/flutter/issues/20809" target="_blank" rel="noopener">https://github.com/flutter/flutter/issues/20809</a></p></blockquote><p>就很烦这种问题，明明是有了国内的镜像，但还是不可以完美使用。</p><p><strong>需要给终端开代理，并清除之前设置的镜像地址。</strong></p><pre><code class="shell">//remove that configexport PUB_HOSTED_URL=https://pub.flutter-io.cn export FLUTTER_STORAGE_BASE_URL=https://storage.flutter-io.cn</code></pre><p>如果是在终端里面声明的，退出重新进入即可。</p><h4 id="获取Flutter代码"><a href="#获取Flutter代码" class="headerlink" title="获取Flutter代码"></a>获取Flutter代码</h4><p>github拉取代码</p><pre><code class="shell"># phyooos @ wangzhumo in ~/develop [11:01:48] C:128$ git clone -b dev https://github.com/flutter/flutter.gitCloning into &#39;flutter&#39;...remote: Counting objects: 135228, done.remote: Compressing objects: 100% (5/5), done.remote: Total 135228 (delta 0), reused 1 (delta 0), pack-reused 135223Receiving objects: 100% (135228/135228), 43.82 MiB | 63.00 KiB/s, done.Resolving deltas: 100% (101879/101879), done.</code></pre><p>flutter doctor</p><pre><code class="shell"># phyooos @ wangzhumo in ~/develop/flutter on git:dev o [11:35:37] $ flutter doctorDoctor summary (to see all details, run flutter doctor -v):[✓] Flutter (Channel dev, v0.7.0, on Mac OS X 10.13.4 17E199, locale zh-Hans-CN)[✓] Android toolchain - develop for Android devices (Android SDK 28.0.2)[✓] iOS toolchain - develop for iOS devices[✓] Android Studio (version 3.1)[!] VS Code (version 1.26.1)[✓] Connected devices (1 available</code></pre><h3 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h3><p>刚入职新公司，忙的一批，根本没时间玩这个了，有时间还得看 音视频</p><p>残念。</p>]]></content>
    
    
    <categories>
      
      <category>Flutter</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Flutter</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>OkHttp源码分析-WebSocket</title>
    <link href="undefined2018/08/20/okhttp-source-code-websocket/"/>
    <url>2018/08/20/okhttp-source-code-websocket/</url>
    
    <content type="html"><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>OkHttp可以说是Android中一个非常重要的网络请求框架,最近的业务需要WebSocket的功能,看到有人说okhttp就可以做到了,于是我打开了源码,果然.</p><pre><code>Okhttp  - internal    - ws    okhttp3.internal.ws.RealWebSocket    okhttp3.internal.ws.WebSocketProtocol    okhttp3.internal.ws.WebSocketReader    okhttp3.internal.ws.WebSocketWriter  okhttp3.WebSocket  okhttp3.WebSocketListener</code></pre><p>那么接下来,让我来一探究竟 </p><a id="more"></a><h3 id="WebSocket创建"><a href="#WebSocket创建" class="headerlink" title="WebSocket创建"></a>WebSocket创建</h3><p><strong>okhttp3.WebSocket</strong></p><pre><code class="java">public interface WebSocket {  /** Returns the original request that initiated this web socket. */  Request request();  /**   * Returns the size in bytes of all messages enqueued to be transmitted to the server.    */  long queueSize();  /**   * Attempts to enqueue {@code text} to be UTF-8 encoded and sent as a the data of a text (type   */  boolean send(String text);  /**   * Attempts to enqueue {@code bytes} to be sent as a the data of a binary (type {@code 0x2})   * message.   * &lt;p&gt;This method returns immediately.   */  boolean send(ByteString bytes);  boolean close(int code, @Nullable String reason);  /**   * Immediately and violently release resources held by this web socket, discarding any enqueued   * messages. This does nothing if the web socket has already been closed or canceled.   */  void cancel();  interface Factory {    /**     * Creates a new web socket and immediately returns it. Creating a web socket initiates an asynchronous process to connect the socket     */    WebSocket newWebSocket(Request request, WebSocketListener listener);  }}</code></pre><p>哎,,,这注释写的,都舍不得删了.</p><p>可以看到,接口中的方法基本上都是对WebSocket的操作,如发送,关闭,取消,大小</p><p>需要关注的是<code>interface Factory</code> 中的<code>newWebSocket()</code>方法,实现在<code>OkHttpClient</code></p><p><strong>okhttp3.OkHttpClient</strong></p><pre><code class="java">  /**   * Uses {@code request} to connect a new web socket.   */  @Override public WebSocket newWebSocket(Request request, WebSocketListener listener) {    RealWebSocket webSocket = new RealWebSocket(request, listener, new Random(), pingInterval);    webSocket.connect(this);    return webSocket;  }</code></pre><p>发现是由<code>RealWebSocket</code>来创建<code>WebSocket</code>的连接的</p><p>它接收了一个<code>Request</code>,以及<code>WebSocketListener</code></p><p>其中的<code>pingInterval</code>是发送ping消息的时间,是由<code>OkhttpClient</code>去设置的.</p><p>接下来关注<code>connetc(this)</code>这个方法,我们去看看<code>RealWebSocket</code></p><p><strong>okhttp3.internal.ws.RealWebSocket</strong></p><pre><code class="java">public final class RealWebSocket implements WebSocket, WebSocketReader.FrameCallback {    //public interface FrameCallback {    //    void onReadMessage(String text) throws IOException;    //    void onReadMessage(ByteString bytes) throws IOException;    //    void onReadPing(ByteString buffer);    //    void onReadPong(ByteString buffer);    //    void onReadClose(int code, String reason);      //}}</code></pre><p>实现接口:</p><ol><li><p>实现了<code>WebSocket</code>接口中的方法</p></li><li><p>实现<code>WebSocketReader.FrameCallback</code>接口</p><p>可以看到,其中都是读取数据的回调</p></li></ol><p>属性字段:</p><ol><li><p><code>private final Request originalRequest;</code></p><p>是我们应用中传过来的原始请求</p></li><li><p><code>final WebSocketListener listener;</code></p><p>这是我们使用的过程中,比较关注的一个类,他是一个抽象类,主要负责把<code>WebSocket</code>中的通信</p><ul><li><code>onOpen(WebSocket webSocket, Response response)</code></li><li><code>onMessage(WebSocket webSocket, String text)</code></li><li><code>onMessage(WebSocket webSocket, ByteString bytes)</code></li><li><code>onClosing(WebSocket webSocket, int code, String reason)</code></li><li><code>onClosed(WebSocket webSocket, int code, String reason)</code></li><li><code>onFailure(WebSocket webSocket, Throwable t, @Nullable Response response)</code></li></ul></li></ol>]]></content>
    
    
    <categories>
      
      <category>Android</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Android</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>WebSocket的使用笔记-理论基础</title>
    <link href="undefined2018/08/19/websocket-note/"/>
    <url>2018/08/19/websocket-note/</url>
    
    <content type="html"><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>WebSocket 是HTML5一种新的web通信技术,实现了浏览器与服务器的全双工实时通信(full-duplex)</p><p>在WebSocket中,第一次还是采用Http的形式来通知服务器,准备使用WebSocket的协议,而如果服务器支持的话,会返回成功的通知<code>101</code>,而后就会长连接来进行全双工的通信,而不是<code>Request &amp; Response</code>,每一次请求完成都断开连接.</p><p>因此,WebSocket通常是使用在推送,即时通讯,等等需要即时性的通讯需求.</p><p><strong><a href="https://zh.wikipedia.org/wiki/WebSocket" target="_blank" rel="noopener">Wiki</a> </strong></p><blockquote><p>WebSocket 是独立的、创建在 TCP 上的协议.  WebSocket使得客户端和服务器之间的数据交换变得更加简单，允许服务端主动向客户端推送数据。在WebSocket API中，浏览器和服务器只需要完成一次握手，两者之间就直接可以创建持久性的连接，并进行双向数据传输。</p></blockquote><a id="more"></a><h3 id="WebSocket简介"><a href="#WebSocket简介" class="headerlink" title="WebSocket简介"></a>WebSocket简介</h3><p>我们先来看一张图:</p><p><img src="/images/websocket-http.png" srcset="/img/loading.gif" alt="websocket-http"></p><p>额,再来一张:</p><p><img src="/images/websocket-http-duibi.png" srcset="/img/loading.gif" alt="duibi"></p><p>先说第二张图,说明了WebSocket与Http的关系,其实两者除了都是基于<code>TCP</code>之外联系并不大,只是WebSocket的第一次握手申请升级协议的时候使用了Http的连接,而后的各种连接都是使用WebSocket的.</p><p>再来说第一张图,主要揭示了WebSocket的工作流程,通过握手后双方启用了WebSocket通信,而之后的一系列操作都是WebSocket自己来操作的.</p><p><strong>WebSocket客户端第一次请求</strong></p><pre><code class="xml">GET ws://echo.websocket.org/?encoding=text HTTP/1.1Origin: http://websocket.orgCookie: __utma=99asConnection: UpgradeHost: echo.websocket.orgSec-WebSocket-Key: uRovscZjNol/umbTt5uKmw==Upgrade: websocketSec-WebSocket-Version: 13</code></pre><p>这是WebSocket第一次发送的请求,只支持GET请求</p><ul><li>Upgrade 主要表明我需要升级协议,其后标明了需要升级的协议类型</li><li>Sec-WebSocket-Key  则是WebSocket 客户端发送的一个 base64 编码的密文,需要服务器端返一个对应加密<code>Sec-WebSocket-Accept</code>应答,如果不合法则抛出<code>Error during WebSocket handshake</code>错误,并关闭连接</li></ul><p><strong>WebSocket服务器返回</strong></p><pre><code class="xml">HTTP/1.1 101 WebSocket Protocol HandshakeDate: Fri, 10 Feb 2012 17:38:18 GMTConnection: UpgradeServer: Kaazing GatewayUpgrade: WebSocketAccess-Control-Allow-Origin: http://websocket.orgAccess-Control-Allow-Credentials: trueSec-WebSocket-Accept: rLHCkw/SKsO9GAH/ZSFhBATDKrU=Access-Control-Allow-Headers: content-type</code></pre><ul><li>Sec-WebSocket-Key的内容加上字符串258EAFA5-E914-47DA-95CA-C5AB0DC85B11</li><li>生成的字符串进行SHA1编码</li><li>再将生成的字符串进行Base64编码</li></ul><h3 id="WebSocket通信"><a href="#WebSocket通信" class="headerlink" title="WebSocket通信"></a>WebSocket通信</h3><p>WebSocket中所有数据均使用帧的形式发送。</p><p>客户端发送的数据帧都要经过掩码处理,服务端发送的所有数据帧都不能经过掩码处理,否则对方需要发送关闭帧。  一个帧包含一个帧类型的标识码,一个负载长度,和负载(包括扩展内容和应用内容)</p><p><strong>WebSocket数据帧的统一格式</strong></p><pre><code class="xml">  0                   1                   2                   3  0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 +-+-+-+-+-------+-+-------------+-------------------------------+ |F|R|R|R| opcode|M| Payload len |    Extended payload length    | |I|S|S|S|  (4)  |A|     (7)     |             (16/64)           | |N|V|V|V|       |S|             |   (if payload len==126/127)   | | |1|2|3|       |K|             |                               | +-+-+-+-+-------+-+-------------+ - - - - - - - - - - - - - - - + |     Extended payload length continued, if payload len == 127  | + - - - - - - - - - - - - - - - +-------------------------------+ |                               |Masking-key, if MASK set to 1  | +-------------------------------+-------------------------------+ | Masking-key (continued)       |          Payload Data         | +-------------------------------- - - - - - - - - - - - - - - - + :                     Payload Data continued ...                : + - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - + |                     Payload Data continued ...                | +---------------------------------------------------------------+</code></pre><ul><li><p><strong>FIN </strong> 1个比特。</p><p>如果是1,表示这是消息的最后一个分片,若是0表示不是最后一个</p></li><li><p><strong>RSV1, RSV2, RSV3</strong>各占1个比特</p><p>这三个都是留着扩展用的</p></li><li><p><strong>Opcode</strong> 4个比特</p><ul><li><p>0 表示此帧是一个继续帧,需要拼接在上一个收到的帧,组成一个完整的消息,所以非控制帧的发送和接收必须是相同的顺序</p></li><li><p>1 文本帧</p></li><li><p>2 二进制帧</p></li><li><p>3 - 7 保留</p></li><li><p>8 关闭连接控制帧</p><p>此帧可能会包含内容,以表示关闭连接的原因,注意必须是客户端与服务器端成对出现,而后关闭链接.</p></li><li><p>9 Ping<br>类似于心跳,收到Ping之后应立即发送Pong响应</p></li><li><p>10 Pong</p><p>如果通信一方并没有发送Ping,但是收到了Pong,并不要求它返回任何信息</p></li><li><p>11 - 15 保留</p></li></ul></li></ul><ul><li><p><strong>Mask</strong>  1个比特</p><p>表示是否要对数据载荷进行掩码操作</p></li><li><p><strong>Payload length</strong></p><p>7bit 数据的长度, length == 126 时,后面的2 个字节也是表示数据长度</p><p>当它 length == 127 时,后面的 8 个字节表示数据长度</p></li><li><p><strong>Masking-key</strong> 0或4字节</p><p>主要看Mask的值来决定</p></li><li><p><strong>Payload data</strong>   扩展数据+应用数据</p><p>应用数据,在扩展数据之后,帧数据的剩余长度就是应用数据的长度.</p></li></ul><h3 id="WebSocket保持心跳"><a href="#WebSocket保持心跳" class="headerlink" title="WebSocket保持心跳"></a>WebSocket保持心跳</h3><p>WebSocket保持客户端,服务端的实时双向通信,需要确保客户端,服务端之间的TCP连接没有断开。</p><p>但是又不能一直去发送数据,这样的话会浪费大量的资源.</p><p>此时就是心跳来保持连接:</p><ul><li>发送方  ping     opcode =  9 </li><li>接收方  pong   opcode =  A</li></ul><h3 id="WebSocket的使用"><a href="#WebSocket的使用" class="headerlink" title="WebSocket的使用"></a>WebSocket的使用</h3><p>这一部分我准备用另一篇笔记来记录</p><h4 id="OkHttp"><a href="#OkHttp" class="headerlink" title="OkHttp"></a>OkHttp</h4><p>这里单独说一下<code>okhttp</code>,竟然支持websocket的通信协议,而且还有一个扩展模块mockserver支持测试..简直完美</p><blockquote><p>implementation “com.squareup.okhttp3:okhttp:$okhttpVersion”</p><p>implementation “com.squareup.okhttp3:mockwebserver:$okhttpVersion”</p></blockquote><h4 id="Java-websocket"><a href="#Java-websocket" class="headerlink" title="Java-websocket"></a>Java-websocket</h4><p><a href="https://github.com/TooTallNate/Java-WebSocket" target="_blank" rel="noopener">Java-WebSocket</a>,这是使用java来实现的WebSocket客户端和服务端,也是6的飞起.</p><p>那么我下一篇笔记主要会记录Okhttp的使用,或者会分析一下okhttp中实现websocket的源码.</p>]]></content>
    
    
    <categories>
      
      <category>Server</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Android</tag>
      
      <tag>Server</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>MacOS装机必备</title>
    <link href="undefined2018/08/17/macos-change-list/"/>
    <url>2018/08/17/macos-change-list/</url>
    
    <content type="html"><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>更换工作的机器,所有的环境都要再搭一次,还是挺苦逼的</p><p>这里记录下来.</p><a id="more"></a><h3 id="环境"><a href="#环境" class="headerlink" title="环境"></a>环境</h3><h4 id="ssh-相关"><a href="#ssh-相关" class="headerlink" title="ssh 相关"></a>ssh 相关</h4><ul><li>~/.ssh/config 配置目录</li><li>~/.ssh/下的所有公钥/密钥</li></ul><h4 id="brew包管理"><a href="#brew包管理" class="headerlink" title="brew包管理"></a>brew包管理</h4><ul><li><p>安装</p><pre><code class="shell">/usr/bin/ruby -e &quot;$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/master/install)&quot;</code></pre></li></ul><h5 id="List"><a href="#List" class="headerlink" title="List"></a>List</h5><ul><li>brew install htop     //系统监控</li><li>brew install hexo    //博客系统</li><li>brew install kotlin   //kotlin编译环境</li><li>brew insatll zsh      //zsh</li><li>brew install vim     //vim</li><li>brew install tree     //tree 工具</li><li>brew install python3    //py</li><li>brew install polipo  //终端的代理工具</li><li>brew install git    //git</li><li>brew install cmake   //cmake编译</li><li>brew install hightlight  //高亮</li><li>brew install autojump   //autojump</li></ul><h4 id="终端"><a href="#终端" class="headerlink" title="终端"></a>终端</h4><h5 id="iterm2"><a href="#iterm2" class="headerlink" title="iterm2"></a>iterm2</h5><blockquote><p><a href="https://www.iterm2.com/" target="_blank" rel="noopener">https://www.iterm2.com/</a></p></blockquote><h5 id="go2Shell"><a href="#go2Shell" class="headerlink" title="go2Shell"></a>go2Shell</h5><blockquote><p><a href="http://zipzapmac.com/go2shell" target="_blank" rel="noopener">http://zipzapmac.com/go2shell</a></p></blockquote><h5 id="zsh"><a href="#zsh" class="headerlink" title="zsh"></a>zsh</h5><p>~/.zshrc</p><h4 id="环境变量"><a href="#环境变量" class="headerlink" title="环境变量"></a>环境变量</h4><pre><code class="shell">ulimit -S -n 1024export JAVA_HOME=/Library/Java/JavaVirtualMachines/jdk1.8.0_161.jdk/Contents/Homeexport ANDROID_HOME=/Users/phyooos/Library/Android/sdkexport TOMCAT_HOME=/Users/phyooos/develop/apache-tomcat-7.0.77export GRADLE_USER_HOME=/Users/phyooos/develop/gradleexport MYSQL_HOME=/usr/local/mysql-5.7.18-macos10.12-x86_64export GOROOT=/usr/local/goexport GOPATH=/Users/phyooos/develop/workspaceexport GOBIN=$GOPATH/binexport NDK_HOME=/Users/phyooos/Library/Android/sdk/ndk-bundleexport REPO_URL=&#39;https://mirrors.tuna.tsinghua.edu.cn/git/git-repo/&#39;export SCALA_HOME=/Users/phyooos/develop/scala-2.11.8export MAVEN_HOME=/Users/phyooos/develop/apache-maven-3.5.0export FLUTTER_HOME=/Users/phyooos/develop/flutterexport WEBP_HOME=/Users/phyooos/develop/libwebpexport DART_HOME=/Users/phyooos/develop/flutter/bin/cache/dart-sdkexport PATH=/usr/local/Cellar/gcc/8.1.0/bin:/usr/local/bin:$PATH:$JAVA_HOME/bin:$ANDROID_HOME/tools:$ANDROID_HOME/platform-tools:$TOMCAT_HOME/bin:$GRADLE_HOME/bin:$MYSQL_HOME/bin:$GOROOT/bin:$GOPATH:$GOBIN:$GOPATH/bin:$FLUTTER_HOME/bin:$DART_HOME/bin:$MAVEN_HOME/bin:$SCALA_HOME/bin:$NDK_HOME:$WEBP_HOME/bin</code></pre><h3 id="文件"><a href="#文件" class="headerlink" title="文件"></a>文件</h3><h4 id="桌面文件"><a href="#桌面文件" class="headerlink" title="桌面文件"></a>桌面文件</h4><ul><li>文件夹</li></ul><h5 id="Develop"><a href="#Develop" class="headerlink" title="Develop"></a>Develop</h5><ul><li>flutter 的安装</li><li>hexo </li><li>proxyee</li><li>workspace</li></ul><h5 id="图片"><a href="#图片" class="headerlink" title="图片"></a>图片</h5><h5 id="公共"><a href="#公共" class="headerlink" title="公共"></a>公共</h5><h5 id="音乐"><a href="#音乐" class="headerlink" title="音乐"></a>音乐</h5><h5 id="workspace"><a href="#workspace" class="headerlink" title="workspace"></a>workspace</h5><h3 id="软件"><a href="#软件" class="headerlink" title="软件"></a>软件</h3><h4 id="网络通讯"><a href="#网络通讯" class="headerlink" title="网络通讯"></a>网络通讯</h4><ul><li>Aira2GUI</li><li>Google Chrome</li><li>ShadowsocksX-NG-R8</li><li>LanScan Pro</li><li>Little Snitch Configuration</li><li>Charles</li><li>Foxmail</li><li>微信</li><li>QQ</li><li>钉钉</li><li>Zeplin</li></ul><h4 id="系统工具"><a href="#系统工具" class="headerlink" title="系统工具"></a>系统工具</h4><ul><li>Enpass</li><li>截图 - 腾讯</li><li>Dukto</li><li>Bartender 3</li><li>Go2Shell</li><li>Iterm2</li><li>Kaleidoscope</li><li>Cheat Sheet</li><li>TinyPNG4Mac</li><li>Pap.er</li><li>CleanMyMac</li><li>Tuxera Disk Manager</li></ul><h4 id="开发工具"><a href="#开发工具" class="headerlink" title="开发工具"></a>开发工具</h4><ul><li>Android Studio</li><li>Intellij IDEA</li><li>PyCharm</li><li>Xcode</li><li>Tower</li><li>GoLand</li><li>CodeRunner</li><li>Visual Studio Code</li><li>Postman</li><li>Yummy FTP Pro</li><li>Typora</li><li>有道词典</li><li>NWeb</li><li>Paw for Trello</li></ul><h4 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h4><ul><li>MindNode</li><li>IThoughtsX</li><li>Sketch</li><li>Xnip</li><li>网易云音乐</li><li>Acorn</li><li>IINA</li><li>PicGIF</li></ul>]]></content>
    
    
    <categories>
      
      <category>Tools</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Tools</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Kotlin学习笔记-高级函数</title>
    <link href="undefined2018/08/13/kotlin-learn-advance-fun/"/>
    <url>2018/08/13/kotlin-learn-advance-fun/</url>
    
    <content type="html"><![CDATA[<h3 id="常用高级函数"><a href="#常用高级函数" class="headerlink" title="常用高级函数"></a>常用高级函数</h3><h4 id="map"><a href="#map" class="headerlink" title="map"></a>map</h4><ul><li><p>一般方式</p><p>```kotlin<br>fun main(args: Array<string>) {</string></p><pre><code>val list = listOf(1,2,3,4,5,6,7)//函数引用的方式int转为doublelist.map(Int::toDouble)val newList = list.map{    //it 就是当前元素    it *2}</code></pre><p>}</p></li></ul><pre><code>  &lt;!--more--&gt;- 引用函数的map  ```kotlin  fun main(args: Array&lt;String&gt;) {      val list = listOf(1,2,3,4,5,6,7)      //函数引用的方式int转为double      list.map(Int::toDouble)  }  //源码 map  public inline fun &lt;T, R&gt; Iterable&lt;T&gt;.map(transform: (T) -&gt; R): List&lt;R&gt; {      return mapTo(ArrayList&lt;R&gt;(collectionSizeOrDefault(10)), transform)      //ArrayList&lt;R&gt;(collectionSizeOrDefault(10))   初始化一个和原来一样长的list      //transform 就是我们传进去的函数  }  //源码 mapTo  //destination  就是上面初始化好的List  //transform 也是上面传进来的函数,负责转换  public inline fun &lt;T, R, C : MutableCollection&lt;in R&gt;&gt; Iterable&lt;T&gt;.mapTo(destination: C, transform: (T) -&gt; R): C {      //一个for循环,遍历所有元素,并转换后添加到新List      for (item in this)          destination.add(transform(item))      return destination  //返回List  }</code></pre><h4 id="flatMap"><a href="#flatMap" class="headerlink" title="flatMap"></a>flatMap</h4><pre><code class="kotlin">fun main(args: Array&lt;String&gt;) {    //以上是一个元素为数组的List    val list = listOf(1..8,9..12,13..27 step 2,28..32)    //展开List,并把List中的每一个元素中的每一个元素 + 1    val newList = list.flatMap { intRange -&gt;        intRange.map { item -&gt;            item + 1        }    }    //同上     val newList2 = list.flatMap { it -&gt;        it.map {            it + 1        }    }    // 只是展开了List,其他什么也没做    val newList3 = list.flatMap { it -&gt;        it    }}//源码/** * Returns a single list of all elements yielded from results of [transform] function being invoked on each element of original collection. */public inline fun &lt;T, R&gt; Iterable&lt;T&gt;.flatMap(transform: (T) -&gt; Iterable&lt;R&gt;): List&lt;R&gt; {            //创建List  , 传入针对原List中元素的转换方法    return flatMapTo(ArrayList&lt;R&gt;(), transform)}/** * Appends all elements yielded from results of [transform] function being invoked on each element of original collection, to the given [destination]. */public inline fun &lt;T, R, C : MutableCollection&lt;in R&gt;&gt; Iterable&lt;T&gt;.flatMapTo(destination: C, transform: (T) -&gt; Iterable&lt;R&gt;): C {    //遍历原来List    for (element in this) {        //此处的transform,转换原List中的每一个元素        val list = transform(element)        destination.addAll(list)    }    //返回了新List    return destination}</code></pre><h4 id="reduce"><a href="#reduce" class="headerlink" title="reduce"></a>reduce</h4><pre><code class="kotlin">//实际就计算了所有元素的和newList.reduce { acc, i -&gt;        //acc 是上一次计算的结果        //i 是当前的元素                acc + i   // 这个是操作的函数}//源码/** * Accumulates value starting with the first element and applying [operation] from left to right to current accumulator value and each element. */public inline fun &lt;S, T: S&gt; Iterable&lt;T&gt;.reduce(operation: (acc: S, T) -&gt; S): S {    //获取了我们的迭代对象    val iterator = this.iterator()    //如果不是空List就继续执行    if (!iterator.hasNext()) throw UnsupportedOperationException(&quot;Empty collection can&#39;t be reduced.&quot;)    //取到List的第一个元素    var accumulator: S = iterator.next()    while (iterator.hasNext()) {        //这一步就是把上面一个进入操作的结果和下一个元素做了 operation 的操作,        //而这个 operation 就是你传进来的函数        //计算完毕之后,又把计算结果赋给了 accumulator         accumulator = operation(accumulator, iterator.next())    }    //最后返回结果    return accumulator}eg:val list = listOf(1,2,3,4)val accumulator = list[0] = 1while ( -- ){//第一次    1 = 1 + 2 = 3//第二次    3 = 3 + 3 = 6//第三次    6 = 6 + 6 = 10}return 10</code></pre><h4 id="flod"><a href="#flod" class="headerlink" title="flod"></a>flod</h4><pre><code class="kotlin">//源码表示,只是初始值是你指定的那个值,其他和reduce差不多一致的思路/** * Accumulates value starting with [initial] value and applying [operation] from left to right to current accumulator value and each element. */public inline fun &lt;T, R&gt; Iterable&lt;T&gt;.fold(initial: R, operation: (acc: R, T) -&gt; R): R {    var accumulator = initial    //operation 操作上次结构    for (element in this) accumulator = operation(accumulator, element)    return accumulator}//字符串拼接newList.fold(StringBuffer()){ acc, i -&gt;        acc.append(i).append(&quot;,&quot;)}输出:2,3,4,5,6,7,8,9,10,11,12,13,14,16,18,20,22,24,26,28,29,30,31,32,33,</code></pre><h4 id="filter"><a href="#filter" class="headerlink" title="filter"></a>filter</h4><p>过滤掉不符合条件的</p><h4 id="takeWhile"><a href="#takeWhile" class="headerlink" title="takeWhile"></a>takeWhile</h4><p>取第一个不符合条件元素之前的所有元素.</p><p>#### </p><h4 id="let"><a href="#let" class="headerlink" title="let"></a>let</h4><p>最常用的场景就是使用let函数处理需要针对一个可null的对象统一做判空处理</p><pre><code class="kotlin">fun main(args: Array&lt;String&gt;) {    //以上是一个元素为数组的List    val list = listOf(1..8,9..12,13..27 step 2,28..32)    val kc = KotlinClassA()    val per : DataClass? = DataClass(12,&quot;脑壳痛&quot;)    per?.copy()    per?.addWhat1(kc)    per?.addWhat2(kc)    per?.addWhat3(kc)    //let    per?.let {        it.copy()        it.addWhat1(kc)        it.addWhat2(kc)        it.addWhat3(kc)    }}//源码@kotlin.internal.InlineOnlypublic inline fun &lt;T, R&gt; T.let(block: (T) -&gt; R): R {    contract {        callsInPlace(block, InvocationKind.EXACTLY_ONCE)    }    //把接收的参数,传入了我们提供的函数中    return block(this)}</code></pre><h4 id="with"><a href="#with" class="headerlink" title="with"></a>with</h4><p>适用于调用同一个类的多个方法时，可以省去类名重复，直接调用类的方法即可，如Android中onBinderViewHolder中，数据model的属性映射到UI上</p><pre><code class="kotlin">@kotlin.internal.InlineOnlypublic inline fun &lt;T, R&gt; with(receiver: T, block: T.() -&gt; R): R {    contract {        callsInPlace(block, InvocationKind.EXACTLY_ONCE)    }    return receiver.block()}//用收到的实例去调用 block方法,返回值自己定义</code></pre><h4 id="run"><a href="#run" class="headerlink" title="run"></a>run</h4><p>let + with 的结合体</p><p>既可以直接访问实例的公有属性和方法</p><p>又弥补了with函数传入对象判空问题</p><pre><code class="kotlin">@kotlin.internal.InlineOnlypublic inline fun &lt;T, R&gt; T.run(block: T.() -&gt; R): R {    contract {        callsInPlace(block, InvocationKind.EXACTLY_ONCE)    }    return block()}</code></pre><h4 id="apply"><a href="#apply" class="headerlink" title="apply"></a>apply</h4><pre><code class="kotlin">@kotlin.internal.InlineOnlypublic inline fun &lt;T&gt; T.apply(block: T.() -&gt; Unit): T {    contract {        callsInPlace(block, InvocationKind.EXACTLY_ONCE)    }    block()    return this}//注意它返回的是this</code></pre><h3 id="闭包"><a href="#闭包" class="headerlink" title="闭包"></a>闭包</h3><ul><li>就是函数的运行环境</li><li>持有函数的运行状态</li><li>函数内部可以定义函数</li><li>函数内部也可以定义类</li></ul><pre><code class="kotlin">fun fibonacci(): () -&gt; Long {    var first = 0L    var second = 1L    return fun() : Long{        val result = second        second += first        first = second - first        return result    }}fun main(args: Array&lt;String&gt;) {    val f = fibonacci()    println(f())    println(f())    println(f())    println(f())    println(f())}输出:11235</code></pre><p>我们发现<code>var first = 0L</code>,<code>var second = 1L</code> 这两个的值被保存住了</p><p>每次f() 后,first和 second都能记住他们当前被赋予的值</p><h3 id="复合函数"><a href="#复合函数" class="headerlink" title="复合函数"></a>复合函数</h3><p>这简直太秀了</p><pre><code class="kotlin">fun add(int: Int) =  int + 1fun multiply(int: Int)  =  int * 2fun &lt;A, B, C&gt; compose(f: (B) -&gt; C, g: (A) -&gt; B) : (A) -&gt; C {    return { x -&gt; f(g(x)) }}fun main(args: Array&lt;String&gt;) {    val addAndMultiply = compose(::add, ::multiply)    println(addAndMultiply(9))  //输出  19}</code></pre><p>### </p>]]></content>
    
    
    <categories>
      
      <category>Java</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Java，Kotlin</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Kotlin学习笔记-基础</title>
    <link href="undefined2018/08/10/kotlin-learn-note-basic/"/>
    <url>2018/08/10/kotlin-learn-note-basic/</url>
    
    <content type="html"><![CDATA[<h3 id="基本类型"><a href="#基本类型" class="headerlink" title="基本类型"></a>基本类型</h3><h5 id="不会隐式转换"><a href="#不会隐式转换" class="headerlink" title="不会隐式转换"></a>不会隐式转换</h5><pre><code class="kotlin">val a = 123val b : Float = a  //这样是不合法的,不支持隐式转换val c : Float = a.toFloat()</code></pre><a id="more"></a><h5 id="多行"><a href="#多行" class="headerlink" title="多行"></a>多行</h5><pre><code class="kotlin">val lines = &quot;&quot;&quot;    好人啊.    #/    $a&quot;&quot;&quot;print(lines)</code></pre><p>输出为</p><pre><code class="kotlin">    好人啊.    #/    123Process finished with exit code 0</code></pre><h3 id="引用类型"><a href="#引用类型" class="headerlink" title="引用类型"></a>引用类型</h3><h5 id="空安全"><a href="#空安全" class="headerlink" title="空安全"></a>空安全</h5><pre><code class="kotlin">fun getValue() : String {    return null  //报错}</code></pre><p>如果你这么写,一定是会报错的,原因是  指定的返回值 <code>String</code> 不接受null的返回值</p><p>如果你一定要它可以返回一个空那就只能加一个<code>?</code></p><pre><code class="kotlin">fun getValue() : String? {    return null}</code></pre><p>那么作为调用者</p><pre><code class="kotlin">print(getValue()?.length)     //输出  nullprint(getValue()!!.length)      //输出 KotlinNullPointerException ,直接就给干崩了</code></pre><ul><li><code>?</code> 的作用是,如果为空则输出null  ,如果不为空则正常使用</li><li><code>!!</code>取消空安全机制,就和java一样了</li></ul><h5 id="类型转换"><a href="#类型转换" class="headerlink" title="类型转换"></a>类型转换</h5><p>对于转换异常的那些,如果一旦错误就直接奔溃,我们希望它不要崩溃,而是以其他的方式来表现</p><pre><code class="kotlin">open class Parentclass Child : Parent()fun main(args: Array&lt;String&gt;) {    val parent = Parent()    val child = parent as? Child    //然而抛出了一个异常  ClassCastException,类型转换异常    print(child)  }</code></pre><p>那么Kotlin对此做了什么操作?</p><pre><code class="kotlin">val child = parent as? Childprint(child)   //输出 null,而不会直接奔溃</code></pre><h3 id="区间Range"><a href="#区间Range" class="headerlink" title="区间Range"></a>区间Range</h3><ul><li><code>a..b</code> 运算符  [a,b]</li><li><code>a until b</code>  [a,b)</li></ul><pre><code class="kotlin">val range : IntRange  = 1..29</code></pre><h4 id="Range-的方法"><a href="#Range-的方法" class="headerlink" title="Range 的方法"></a>Range 的方法</h4><ul><li>contains   也可以使用  <code>in</code> 运算符</li><li>isEmpty</li><li>EMPTY   (静态变量)</li></ul><pre><code class="kotlin">print(range.contains(9))   //  tureprint(99 in range)  // false</code></pre><h4 id="遍历Range"><a href="#遍历Range" class="headerlink" title="遍历Range"></a>遍历Range</h4><pre><code class="kotlin">for (i in range){    print(i)}</code></pre><h3 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h3><h4 id="创建数组"><a href="#创建数组" class="headerlink" title="创建数组"></a>创建数组</h4><pre><code class="kotlin">val intArr: IntArray = intArrayOf(1,2,3,4,5)val charArr: CharArray = charArrayOf(&#39;a&#39;,&#39;b&#39;,&#39;c&#39;,&#39;d&#39;,&#39;e&#39;)val objArr: Array&lt;Parent&gt; = arrayOf(Parent(&quot;王&quot;),Parent(&quot;诛&quot;),Parent(&quot;魔&quot;))</code></pre><h4 id="遍历"><a href="#遍历" class="headerlink" title="遍历"></a>遍历</h4><pre><code class="kotlin">formap iterator...</code></pre><h3 id="val-var-coust"><a href="#val-var-coust" class="headerlink" title="val/var/coust"></a>val/var/coust</h3><p>var   可以修改</p><p>val    不可修改final    <strong>运行时常量</strong></p><p>const   静态常量         <strong>编译期常量</strong></p><h3 id="Lambda"><a href="#Lambda" class="headerlink" title="Lambda"></a>Lambda</h3><pre><code class="kotlin">//一般写法fun doSome(a:Int,b:Int) : Int{    return a + b +1}//如果只有返回值,其实可以直接写fun doSome(a:Int,b:Int) : Int = a + b +1</code></pre><pre><code class="java">val array  = arrayOf(1,3,4,5,6,7)fun main(args: Array&lt;String&gt;) {    //lambda表达式    array.forEach {        print(it)    }    // ::  引用    array.forEach(::print)    array.forEachIndexed { index, i -&gt;        print(&quot;index = $index , value = $i&quot;)    }}</code></pre><p>有一点要注意的是,Lambda中的Return</p><pre><code class="kotlin">fun main(args: Array&lt;String&gt;) {    array.forEachIndexed { index, i -&gt;        if (index ==2 ) return        println(&quot;index = $index , value = $i&quot;)    }    print(&quot;Fun End&quot;)}//输出:index = 0 , value = 1index = 1 , value = 3Process finished with exit code 0</code></pre><p>我们可以看到,<code>if (index ==2 ) return</code>直接就返回了<code>main</code>的方法</p><p>那么我想跳出<code>forEachIndexed</code>怎么办?</p><pre><code class="kotlin">fun main(args: Array&lt;String&gt;) {    array.forEachIndexed JUMP@{ index, i -&gt;        if (index == 2) return@JUMP        println(&quot;index = $index , value = $i&quot;)    }    print(&quot;Fun End&quot;)}//输出index = 0 , value = 1index = 1 , value = 3index = 3 , value = 5index = 4 , value = 6index = 5 , value = 7Fun End</code></pre><p>我们可以发现,index = 2 的那一条消失了,因为我们跳出了方法,回到了我们标记的地方 <code>JUMP@</code></p><h3 id="类成员"><a href="#类成员" class="headerlink" title="类成员"></a>类成员</h3><h5 id="重写默认的Get-Set方法"><a href="#重写默认的Get-Set方法" class="headerlink" title="重写默认的Get/Set方法"></a>重写默认的Get/Set方法</h5><pre><code class="kotlin">class KotlinClassA{    var a = 123        get() {            println(&quot;get a value&quot;)            return field        }        set(value) {            field = value            println(&quot;someone set value&quot;)        }}</code></pre><h5 id="字段延迟初始化"><a href="#字段延迟初始化" class="headerlink" title="字段延迟初始化"></a>字段延迟初始化</h5><pre><code class="kotlin">class KotlinClassA{    var a = 123        get() {            print(&quot;get a value&quot;)            return field        }        set(value) {            field = value            print(&quot;someone set value&quot;)        }    //var直接使用lateinit即可    lateinit var b:String    //val的只能用 by 了,lazy返回一个lambda表达式    val c :String by lazy {        print(&quot;lazy init c&quot;)        &quot;666&quot;    }}fun main(args: Array&lt;String&gt;) {    val kot =  KotlinClassA()    println(kot.a)    println(kot.c)}输出:get a value  123lazy init c  666Process finished with exit code 0</code></pre><p>可以看到,c是在我调用它的时候,才打印了<code>lazy init c</code>说明确实是延迟加载的,否则应该是<code>KotlinClassA</code>初始化的时候就应该打印这句话的.</p><h3 id="操作符"><a href="#操作符" class="headerlink" title="操作符"></a>操作符</h3><p>在java中,操作符的作用是固定的,我们没有办法去改变它</p><p>但是在kotlin中,允许我们去自重写操作符,只需要保证入<strong>入参数量</strong>与<strong>函数名</strong>一致即可</p><p><a href="http://kotlinlang.org/docs/reference/operator-overloading.html" target="_blank" rel="noopener">Kotlin给出的文档</a></p><pre><code class="kotlin">class OperatorClass(val value :Int){    //比如我想让加法变成减法    operator fun plus(other : OperatorClass):Int{        return value - other.value    }    operator fun plus(other : Int):Int{        return value - other.value    }}fun main(args: Array&lt;String&gt;) {    val opera = OperatorClass(66)    //两个类相加    print(opera + OperatorClass(6))    print(opera + 10)}输出:6056</code></pre><p>我不仅仅让OperatorClass有了加法,而且还把加法改写成了减法</p><p>还有很多的操作符是可以重写的,看看文档就知道了.</p><h3 id="表达式"><a href="#表达式" class="headerlink" title="表达式"></a>表达式</h3><h5 id="if表达式"><a href="#if表达式" class="headerlink" title="if表达式"></a>if表达式</h5><p>kotlin中的if等等,都是一个表达式,他是可以有值的,我一直没有理解这个.</p><p>看到这个例子,我明白了</p><pre><code class="kotlin">const val DEBUG = 0const val USER = 1const val USER_NAME = &quot;kotlin&quot;const val USER_PASS_WD = &quot;jetBrains&quot;const val ADMIN = &quot;admin&quot;fun main(args: Array&lt;String&gt;) {    //使用了if的返回值,每块中的最后一行就是返回值    val mode = if (args.isNotEmpty() &amp;&amp; args[0] == &quot;0&quot;) {        DEBUG    } else {        USER    }    println(&quot;USER:&quot;)    val user = readLine()    println(&quot;PASSWORD:&quot;)    val passwd = readLine()    if (mode == DEBUG &amp;&amp; user == ADMIN &amp;&amp; passwd == ADMIN) {        println(&quot;Welcome Admin Login.&quot;)    } else if (user == USER_NAME &amp;&amp; passwd == USER_PASS_WD) {        println(&quot;Welcome $user Login.&quot;)    } else {        println(&quot;Error.&quot;)    }}</code></pre><h5 id="When表达式"><a href="#When表达式" class="headerlink" title="When表达式"></a>When表达式</h5><p>when也和if表达式一样,但要注意的是,如果是要用来赋值,那么else -&gt; 也需要返回值</p><pre><code class="kotlin">val mode = when{        args.isNotEmpty() &amp;&amp; args[0] == &quot;0&quot; -&gt; 0        else -&gt; 1    }   when (mode){    !is Int -&gt; println(&quot;mode is Int&quot;)    in 0..9 -&gt; println(&quot;$mode in 1..9&quot;)    0 -&gt; println(&quot;mode == 0&quot;)    else -&gt; println(&quot;bye&quot;)}</code></pre><h3 id="循环"><a href="#循环" class="headerlink" title="循环"></a>循环</h3><h5 id="for循环"><a href="#for循环" class="headerlink" title="for循环"></a>for循环</h5><p>只要一个数据结构可迭代,就可以使用这样的方式来遍历</p><pre><code class="kotlin">fun main(args: Array&lt;String&gt;) {    for (value in args){        println(value)    }    for ((index,value) in args.withIndex()){        println(&quot;current $index index = $value&quot;)    }    for (valueWithIndex in args.withIndex()){        println(&quot;current ${valueWithIndex.index} index =  ${valueWithIndex.value}&quot;)    }}</code></pre><h5 id="跳出和跳过"><a href="#跳出和跳过" class="headerlink" title="跳出和跳过"></a>跳出和跳过</h5><pre><code class="kotlin">@LABEL   标签breakcontinue</code></pre><h3 id="异常"><a href="#异常" class="headerlink" title="异常"></a>异常</h3><p>这玩意也是一个表达式,别的就不说了</p><h3 id="参数"><a href="#参数" class="headerlink" title="参数"></a>参数</h3><h5 id="多个参数"><a href="#多个参数" class="headerlink" title="多个参数"></a>多个参数</h5><pre><code class="kotlin">fun sing(vararg words: String,count :Int){    words.forEach(::println)    println(count)}fun main(args: Array&lt;String&gt;) {    val array = arrayOf(&quot;ds&quot;,&quot;ce&quot;,&quot;lp&quot;)    sing(&quot;abc&quot;,&quot;def&quot;,&quot;zyx&quot;,&quot;opl&quot;,count =  4)    // *Array   可以把一个数组展开    sing(*array,count = array.size)}</code></pre><h5 id="默认值"><a href="#默认值" class="headerlink" title="默认值"></a>默认值</h5><pre><code class="kotlin">fun sing(vararg words: String,count :Int = 1000){    words.forEach(::println)    println(count)}fun main(args: Array&lt;String&gt;) {    sing(&quot;12&quot;,&quot;23&quot;,&quot;63&quot;)}</code></pre><p>下面的调用中,并没有传入count的值,但是并不会报错,因为函数中指定count的默认值了</p><h3 id="接口-继承"><a href="#接口-继承" class="headerlink" title="接口/继承"></a>接口/继承</h3><pre><code class="kotlin">interface Drive{    fun drive()}interface Fix{    fun fix(){        println(&quot;维修技能&quot;)    }}class CarDrive: Drive{    override fun drive() {        println(&quot;驾驶技能-汽车&quot;)    }}class ComputerFix: Fix{    override fun fix() {        super.fix()        println(&quot;维修技能-修电脑&quot;)    }}class Manager : Drive,Fix{    override fun drive() {        println(&quot;经理开车-奥迪轿车&quot;)    }    override fun fix() {        super.fix()        println(&quot;经理维修-汽车&quot;)    }}class SeniorManager(val drive: Drive,val fix: Fix) : Drive by drive , Fix by fixfun main(args: Array&lt;String&gt;) {    val manager = Manager()    manager.drive()    manager.fix()    val carDrive = CarDrive()    val computerFix = ComputerFix()    val seniorManager = SeniorManager(carDrive,computerFix)    seniorManager.drive()    seniorManager.fix()}</code></pre><ul><li>接口可以有默认的方法,但是没有状态</li><li><code>Drive by drive , Fix by fix</code> 代理了经理的技能.</li></ul><h3 id="静态方法-JvmStatic"><a href="#静态方法-JvmStatic" class="headerlink" title="静态方法/@JvmStatic"></a>静态方法/@JvmStatic</h3><pre><code class="kotlin">class Pay private constructor(val money : Double){    companion object {        fun toPay(v : Double): Pay{            return Pay(v)        }        // JvmStatic注解的,可以在Java中像静态方法一样调用        @JvmStatic        fun copyPay(p : Pay) : Pay{            return Pay(p.money)        }    }}kotlin:    val pay = Pay.toPay(10.93)    val pay2 = Pay.copyPay(pay)Java:    //正常的调用,必须使用 Companion 伴生对象    Pay pay = Pay.Companion.toPay(123.8);    Pay pay2 = Pay.copyPay(pay);</code></pre>]]></content>
    
    
    <categories>
      
      <category>Java</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Java，Kotlin</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Glide4.X版本图片加载显示进度</title>
    <link href="undefined2018/08/09/glide-okhttp-progress/"/>
    <url>2018/08/09/glide-okhttp-progress/</url>
    
    <content type="html"><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>Glide无疑是一款非常优秀的图片加载框架,但是他并没有支持显示图片加载的进度.</p><p>那么我们遇到这种需求的时候应该怎么办?自己写一个图片加载框架么?</p><p>不,我们肯定是选择自己来扩展这个框架,使得Glide”支持”显示进度</p><p><strong>GlideImageView</strong>  用来控制start &amp; autoStart , 用来显示 progress , error</p><p><strong>OkHttp</strong>  用来支持进度的回调</p><a id="more"></a><h3 id="思考"><a href="#思考" class="headerlink" title="思考"></a>思考</h3><p>为什么我要选择使用OkHttp来改造那?</p><pre><code class="java">@Override    public void registerComponents(Context context, Glide glide, Registry registry) {        registry.replace(GlideUrl.class, InputStream.class, new OkHttpUrlLoader.Factory());    }</code></pre><p>我们可以看到,ModelLoaderFactory是我们自己传进去的,那么我只要持有这个ModelLoaderFactory不就可以知道进度了么?</p><p>追踪源码发现了初始化OkHttpClient的方法,internalClient 是Call.Factory类型的,而OkHttpClient是Call.Factory的实现类.</p><pre><code class="java">    /**     * Constructor for a new Factory that runs requests using a static singleton client.     */    public Factory() {      this(getInternalClient());    }    /**     * Constructor for a new Factory that runs requests using given client.     *     * @param client this is typically an instance of {@code OkHttpClient}.     *      * 看到这个有参的构造函数了么?还是Public的..     */    public Factory(@NonNull Call.Factory client) {      this.client = client;    }private static Call.Factory getInternalClient() {      if (internalClient == null) {        synchronized (Factory.class) {          if (internalClient == null) {            internalClient = new OkHttpClient();          }        }      }      return internalClient;}</code></pre><p>那么,可以确定替换OkHttpClient的思路是正确的,下面我们来实现一下</p><p><img src="/images/glide_okhttp_progress.png" srcset="/img/loading.gif" alt="glide-okhttp"></p><ul><li><p>OkHttpLoadImage  提供OkHttpClient并添加拦截器</p><ul><li>OnProgressListener  由需要显示进度的View实现,提供一个Url,回调progress</li><li>OkHttpClient 的实例</li><li>HashMap<string,onprogresslistener>  实际上存放的是View自己</string,onprogresslistener></li></ul></li><li><p>ProgressResponseBody  对外提供当前下载的进度</p></li><li><p>LoadImageView  记录当前url,显示进度</p></li><li><p>GlideLoaderModule @GlideModule</p><p>通过<code>new OkHttpUrlLoader.Factory(OkHttpLoadImage.INSTANCE())</code>替代默认的OkHttpClient</p></li></ul><h3 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h3><h4 id="OkHttpLoadImage"><a href="#OkHttpLoadImage" class="headerlink" title="OkHttpLoadImage"></a>OkHttpLoadImage</h4><p>该类提供一个OkHttpClient的实例,在这个实例中添加一个NetworkInterceptor,这个拦截器提供当前下载的进度</p><pre><code class="java">/** * If you have any questions, you can contact by email {wangzhumoo@gmail.com} * * @author 王诛魔 2018/8/9 下午6:10 */public final class OkHttpLoadImage {    //一定要记得unRegister,这里存放的是key以及OnProgressListener    //实际上,我们最好采用软引用,这样更加的安全,毕竟我们无法感知View的生命周期    private static HashMap&lt;String, OnProgressListener&gt; progressListenerMap;    //添加了拦截的OkHttpClient    private OkHttpClient okHttpClient;    static {        progressListenerMap = new HashMap&lt;&gt;();    }    private OkHttpLoadImage() {        initOkHttp();    }    /**     * 构建一个OkHttp的实例     * ProgressResponseBody 是一个比较关键的类,他提供了进度     */    private void initOkHttp() {        okHttpClient = new OkHttpClient.Builder()                .addNetworkInterceptor(chain -&gt; {                    Request request = chain.request();                    Response response = chain.proceed(request);                    ProgressResponseBody body = new ProgressResponseBody(response, request.url().toString());                    //添加监听,使得当前类知道进度                    body.addOnResponseListener(responseListener);                    return response.newBuilder()                            .body(body)                            .build();                })                .build();    }    private static class SingletonHolder {        private static OkHttpLoadImage instance = new OkHttpLoadImage();    }    public static OkHttpClient INSTANCE(){        return SingletonHolder.instance.okHttpClient;    }    private static ProgressResponseBody.OnResponseListener responseListener = new ProgressResponseBody.OnResponseListener() {        @Override        public void update(String key, float progress) {            //去寻找这个key，并传回去当前的进度            OnProgressListener listener = progressListenerMap.get(key);            if (listener != null) {                listener.onProgress(progress);            }        }    };    /**     * 注册进度的回调     */    public static void register(OnProgressListener listener) {        //可能会有多个View注册，但是我们只回调当前这个        progressListenerMap.put(listener.getKey(), listener);    }    /**     * 取消监听     *     * @param listener view     */    public static void unRegister(OnProgressListener listener) {        progressListenerMap.remove(listener.getKey());    }    /**     * 监听进度的接口     */    public interface OnProgressListener {        //回调当前的进度给View        void onProgress(float progress);        //获取当前View资源的key(URL即可)        String getKey();    }}</code></pre><h4 id="ProgressResponseBody"><a href="#ProgressResponseBody" class="headerlink" title="ProgressResponseBody"></a>ProgressResponseBody</h4><p>这个东西,网上到处都是</p><pre><code class="java">public class ProgressResponseBody extends ResponseBody{    //OkHttpLoadImage中传进来的response    private final ResponseBody responseBody;    private String url;    private BufferedSource bufferedSource;    public ProgressResponseBody(Response response,String url) {        this.responseBody = response.body();        this.url = url;    }    @Override    public MediaType contentType() {        return responseBody.contentType();    }    @Override    public long contentLength() {        return responseBody.contentLength();    }    @Override    public BufferedSource source() {        if (bufferedSource == null) {            bufferedSource = Okio.buffer(source(responseBody.source()));        }        return bufferedSource;    }    private Source source(BufferedSource source) {        return new ForwardingSource(source) {            long totalBytes = 0L;            @Override            public long read(Buffer sink, long byteCount) throws IOException {                long bytesRead = super.read(sink, byteCount);                // read() returns the number of bytes read, or -1 if this source is exhausted.                totalBytes += bytesRead != -1 ? bytesRead : 0;                if (listener != null) {                    //注意这块的 1.0 *  , 要不两个long除法会一直是 0                     listener.update(url, (float) 1.0 * totalBytes/contentLength());                }                return bytesRead;            }        };    }    private OnResponseListener listener;    public void addOnResponseListener(OnResponseListener listener){        this.listener = listener;    }    public interface OnResponseListener{        void update(String key,float progress);    }}</code></pre><h4 id="LoadImageView"><a href="#LoadImageView" class="headerlink" title="LoadImageView"></a>LoadImageView</h4><pre><code class="java">/** * If you have any questions, you can contact by email {wangzhumoo@gmail.com} * * @author 王诛魔 2018/8/9 下午5:59 */public class LoadImageView extends AppCompatImageView implements OkHttpLoadImage.OnProgressListener{    private Paint mPaint;    private float progress;    private String url;    public LoadImageView(Context context) {        this(context,null);    }    public LoadImageView(Context context, @Nullable AttributeSet attrs) {        this(context, attrs,0);    }    public LoadImageView(Context context, AttributeSet attrs, int defStyleAttr) {        super(context, attrs, defStyleAttr);        init();    }    public void setImageUrl(String url){        this.url = url;        //此时开始加载        OkHttpLoadImage.register(this);        ImageLoader.LoaderImg(getContext(),url).into(this);        Glide.with(this).load(url).into(this);    }    /**     * 初始化工具     */    private void init() {       mPaint = new Paint();       mPaint.setColor(Color.BLACK);       mPaint.setAntiAlias(true);       mPaint.setStrokeWidth(5);       mPaint.setTextSize(50);    }    @SuppressLint(&quot;DefaultLocale&quot;)    @Override    protected void onDraw(Canvas canvas) {        super.onDraw(canvas);        canvas.drawText(String.format(&quot;Already : %d&quot;,(int)(100 * progress)),100,100,mPaint);    }    public void progress(float progress){        this.progress = progress;        invalidate();    }    @Override    public void onProgress(float progress) {        post(() -&gt; progress(progress));    }    @Override    public String getKey() {        return url;    }    public boolean isLoaded(){        return progress == 1F;    }}</code></pre><h4 id="GlideLoaderModule"><a href="#GlideLoaderModule" class="headerlink" title="GlideLoaderModule"></a>GlideLoaderModule</h4><pre><code class="java">/** * If you have any questions, you can contact by email {wangzhumoo@gmail.com} * * @author 王诛魔 2017/8/9 下午12:16 * */@GlideModulepublic final class GlideLoaderModule extends AppGlideModule {    @Override    public void applyOptions(Context context, GlideBuilder builder) {        RequestOptions options  = new RequestOptions()                .centerCrop()                .placeholder(R.drawable.default_images_load)                .error(R.drawable.default_images_load)                .priority(Priority.HIGH)                .format(DecodeFormat.PREFER_ARGB_8888)                .diskCacheStrategy(DiskCacheStrategy.ALL);        int maxMemory = (int) Runtime.getRuntime().maxMemory();        int memoryCacheSize = maxMemory / 8;        //设置内存缓存大小        File cacheDir = new File(ApiConstants.INSTANCE.getIMAGE_PATH() + File.separator);        if(!cacheDir.exists()){            cacheDir.mkdirs();        }        int diskCacheSize = 1024 * 1024 * 512;        //设置磁盘缓存大小        builder.setMemoryCache(new LruResourceCache(memoryCacheSize));        builder.setDiskCache(new DiskLruCacheFactory(cacheDir.getPath(), &quot;Images&quot;, diskCacheSize));        builder.setDefaultRequestOptions(options);    }    @Override    public void registerComponents(Context context, Glide glide, Registry registry) {        registry.replace(GlideUrl.class, InputStream.class,                new OkHttpUrlLoader.Factory(OkHttpLoadImage.INSTANCE()));    }}</code></pre><h3 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h3><p><img src="/images/glide_progress_image.gif" srcset="/img/loading.gif" alt=""></p>]]></content>
    
    
    <categories>
      
      <category>Android</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Android</tag>
      
      <tag>View</tag>
      
      <tag>Glide</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Glide4.X版本的基本使用</title>
    <link href="undefined2018/08/09/glide-4-note/"/>
    <url>2018/08/09/glide-4-note/</url>
    
    <content type="html"><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>Glide是一款性能优异,包大小中等,加载速度快的图片加载工具,也是Google推荐使用的加载框架之一.</p><p>在以前的工程中,我们都是使用3.8版本一下的Glide,而在4.X版本中,Glide的使用方式发生了一些变化,所以今天特意写了笔记来记录,以便于以后使用时查阅</p><h4 id="地址"><a href="#地址" class="headerlink" title="地址"></a>地址</h4><blockquote><p>Glide:   <a href="https://github.com/bumptech/glide" target="_blank" rel="noopener">https://github.com/bumptech/glide</a></p></blockquote><a id="more"></a><h4 id="依赖"><a href="#依赖" class="headerlink" title="依赖:"></a>依赖:</h4><pre><code class="groovy">implementation (&quot;com.github.bumptech.glide:glide:4.7.1&quot;) {    exclude group: &quot;com.android.support&quot;}annotationProcessor &quot;com.github.bumptech.glide:compiler:4.7.1&quot;//kotlin使用kapt// kapt &#39;com.github.bumptech.glide:compiler:4.7.1&#39;    //如果你需要使用okhttp作为网络层implementation &quot;com.github.bumptech.glide:okhttp3-integration:4.7.1&quot;</code></pre><h4 id="混淆-proguard"><a href="#混淆-proguard" class="headerlink" title="混淆(proguard):"></a>混淆(proguard):</h4><pre><code class="xml">-keep public class * implements com.bumptech.glide.module.GlideModule-keep public class * extends com.bumptech.glide.module.AppGlideModule-keep public enum com.bumptech.glide.load.resource.bitmap.ImageHeaderParser$** {  **[] $VALUES;  public *;}# for DexGuard only-keepresourcexmlelements manifest/application/meta-data@value=GlideModule</code></pre><h3 id="开始使用"><a href="#开始使用" class="headerlink" title="开始使用"></a>开始使用</h3><h4 id="基本配置"><a href="#基本配置" class="headerlink" title="基本配置"></a>基本配置</h4><p>继承 AppGlideModule</p><pre><code class="java">/** * If you have any questions, you can contact by email {wangzhumoo@gmail.com} * @author 王诛魔 2018/8/9 下午12:16 */@GlideModulepublic class GlideLoaderModule extends AppGlideModule {    @Override    public void applyOptions(Context context, GlideBuilder builder) {        RequestOptions options  = new RequestOptions()                .centerCrop()                .placeholder(R.drawable.default_images_load)                .error(R.drawable.default_images_load)                .priority(Priority.HIGH)                .format(DecodeFormat.PREFER_ARGB_8888)                .diskCacheStrategy(DiskCacheStrategy.ALL);        int maxMemory = (int) Runtime.getRuntime().maxMemory();        int memoryCacheSize = maxMemory / 8;        //设置内存缓存大小        File cacheDir = new File(ApiConstants.INSTANCE.getIMAGE_PATH() + File.separator);        if(!cacheDir.exists()){            cacheDir.mkdirs();        }        int diskCacheSize = 1024 * 1024 * 512;        //设置磁盘缓存大小        builder.setMemoryCache(new LruResourceCache(memoryCacheSize));        builder.setDiskCache(new DiskLruCacheFactory(cacheDir.getPath(), &quot;Images&quot;, diskCacheSize));        builder.setDefaultRequestOptions(options);    }    @Override    public void registerComponents(Context context, Glide glide, Registry registry) {        registry.replace(GlideUrl.class, InputStream.class, new OkHttpUrlLoader.Factory());    }}</code></pre><p>注意,<code>GlideLoaderModule</code>在4.X版本之后,不需要写到Manifest文件中去,但是需要你添加<code>@GlideModule</code>注解</p><p>注意,<code>GlideLoaderModule</code>在4.X版本之后,不需要写到Manifest文件中去,但是需要你添加<code>@GlideModule</code>注解</p><h4 id="占位符"><a href="#占位符" class="headerlink" title="占位符"></a>占位符</h4><ul><li><p><a href="https://muyangmin.github.io/glide-docs-cn/javadocs/400/com/bumptech/glide/request/RequestOptions.html#placeholder-int-" target="_blank" rel="noopener">placeholder</a></p><ul><li><p>占位符是当请求正在执行时被展示的 Drawable,当请求成功完成时,占位符会被请求到的资源替</p></li><li><p>如果资源是从内存中加载出来的，那么占位符可能根本不会被显示</p></li><li>如果请求失败并且没有设置 <code>error Drawable</code> ，则占位符将被持续展示</li></ul></li><li><p><a href="https://muyangmin.github.io/glide-docs-cn/javadocs/400/com/bumptech/glide/request/RequestOptions.html#error-int-" target="_blank" rel="noopener">error</a></p><ul><li>在请求永久性失败时展示</li><li>也在请求的url/model为 <code>null</code> ，且并没有设置 <code>fallback Drawable</code> 时展示</li></ul></li><li><p><a href="https://muyangmin.github.io/glide-docs-cn/javadocs/400/com/bumptech/glide/request/RequestOptions.html#fallback-int-" target="_blank" rel="noopener">fallback</a></p><ul><li>在请求的url/model为 <code>null</code> 时展示(注意,null).   会覆盖<code>error</code>的第二条显示条件</li></ul></li></ul><h4 id="Transform-圆角"><a href="#Transform-圆角" class="headerlink" title="Transform(圆角)"></a>Transform(圆角)</h4><p>变换这块,分为几个部分</p><h5 id="默认变换"><a href="#默认变换" class="headerlink" title="默认变换"></a>默认变换</h5><ul><li><a href="https://muyangmin.github.io/glide-docs-cn/javadocs/400/com/bumptech/glide/load/resource/bitmap/CenterCrop.html" target="_blank" rel="noopener">CenterCrop</a></li><li><a href="https://muyangmin.github.io/glide-docs-cn/javadocs/400/com/bumptech/glide/load/resource/bitmap/FitCenter.html" target="_blank" rel="noopener">FitCenter</a></li><li><a href="https://muyangmin.github.io/glide-docs-cn/javadocs/400/com/bumptech/glide/load/resource/bitmap/CircleCrop.html" target="_blank" rel="noopener">CircleCrop</a></li></ul><h5 id="多重变换"><a href="#多重变换" class="headerlink" title="多重变换"></a>多重变换</h5><p>使用<code>transform</code>方法</p><ul><li><p>方式一</p><pre><code class="java">Glide.with(context)  .load(url)  .transform(new MultiTransformation(new FitCenter(), new CustomTransformation())  .into(imageView);</code></pre></li><li><p>方式二</p><pre><code class="java">GlideApp.with(context)  .load(url)  .transforms(new FitCenter(), new CustomTransformation())  .into(imageView);</code></pre></li></ul><h5 id="自定义变换"><a href="#自定义变换" class="headerlink" title="自定义变换()"></a>自定义变换()</h5><pre><code class="java">/** * If you have any questions, you can contact by email {wangzhumoo@gmail.com} * @author 王诛魔 2017/11/2 上午12:20 * 圆角图片 */public class GlideRoundTransform extends BitmapTransformation {    private static final String ID = &quot;com.wangzhumo.app.commonlib.utils.GlideRoundTransform&quot;;    private static float radius = 0f;    public GlideRoundTransform() {        this(5);    }    /**     * 圆角像素     * @param dp     */    public GlideRoundTransform(int dp) {        radius = Resources.getSystem().getDisplayMetrics().density * dp;    }    @Override    protected Bitmap transform(@NonNull BitmapPool pool, @NonNull Bitmap toTransform, int outWidth, int outHeight) {        return roundCrop(pool, toTransform);    }    private static Bitmap roundCrop(BitmapPool pool, Bitmap source) {        if (source == null) return null;        Bitmap result = pool.get(source.getWidth(), source.getHeight(), Bitmap.Config.ARGB_8888);        Canvas canvas = new Canvas(result);        Paint paint = new Paint();        paint.setShader(new BitmapShader(source, BitmapShader.TileMode.CLAMP, BitmapShader.TileMode.CLAMP));        paint.setAntiAlias(true);        RectF rectF = new RectF(0f, 0f, source.getWidth(), source.getHeight());        canvas.drawRoundRect(rectF, radius, radius, paint);        return result;    }    @Override    public boolean equals(Object o) {        return o instanceof GlideRoundTransform;    }    @Override    public int hashCode() {        return ID.hashCode();    }    @Override    public void updateDiskCacheKey(MessageDigest messageDigest) {        messageDigest.update(ID.getBytes());    }}</code></pre><p>其中<code>equals()</code>,<code>hashCode()</code>,<code>updateDiskCacheKey</code>主要是为了缓存和存储的正常工作</p><h4 id="GlideExtension-扩展API"><a href="#GlideExtension-扩展API" class="headerlink" title="GlideExtension(扩展API)"></a>GlideExtension(扩展API)</h4><h5 id="GlideOption"><a href="#GlideOption" class="headerlink" title="GlideOption"></a>GlideOption</h5><pre><code class="java">/** * If you have any questions, you can contact by email {wangzhumoo@gmail.com} * @author 王诛魔 2018/8/9 下午2:57 * 支持快捷使用圆角图片 */@GlideExtensionpublic final class RoundGlideExtension {    private RoundGlideExtension(){ }    /**     * 给url添加参数     * @param options RequestOptions     */    @GlideOption    public static void round(RequestOptions options,int corner){        options.transform(new GlideRoundTransform(corner));    }    /**     * 给url添加参数     * @param options RequestOptions     */    @GlideOption    public static void round(RequestOptions options){        options.transform(new GlideRoundTransform());    }}</code></pre><ol><li>添加<code>@GlideExtension</code>注解</li><li>私有构造</li><li>静态方法,以及<code>@GlideOption</code>注解</li></ol><pre><code class="java">//通过GlideApp.with(context).load(url).apply(options).round();// orGlideApp.with(context).load(url).apply(options).round(corner);//来加载圆角图片</code></pre><h5 id="GlideType"><a href="#GlideType" class="headerlink" title="GlideType"></a>GlideType</h5><p>允许你添加对新的资源类型的支持，包括指定默认选项。</p><p>暂时没有使用.</p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>下一期,我们做一个带进度条的图片加载.</p>]]></content>
    
    
    <categories>
      
      <category>Android</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Android</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Android中使用注解笔记</title>
    <link href="undefined2018/08/09/annotation-simple-note/"/>
    <url>2018/08/09/annotation-simple-note/</url>
    
    <content type="html"><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>@Override 就是一个很常见的注解.</p><ol><li>检查是否正确的复写父类方法</li><li>标志是重写方法</li></ol><p><strong>元注解</strong></p><p>元注解是,额,嗯 注解的注解</p><ul><li>@Retention：注解生命周期</li><li>@Target：作用范围</li><li>@Inherited：标明所修饰的注解类型是被继承的,子类会继承这个注解</li><li>@Documented：javadoc</li></ul><p>这些都是由Java语言本身提供的最基础的注解,他们负责注解其他的注解,具体的作用见上文</p><a id="more"></a><h3 id="自定义注解"><a href="#自定义注解" class="headerlink" title="自定义注解"></a>自定义注解</h3><h4 id="运行时注解-RUNTIME"><a href="#运行时注解-RUNTIME" class="headerlink" title="运行时注解(RUNTIME)"></a>运行时注解(RUNTIME)</h4><pre><code class="java">/** * If you have any questions, you can contact by email {wangzhumoo@gmail.com} * @author 王诛魔 2018/8/9 上午10:50 *  * 标记字段为imageUrl,图片地址 */@Retention(RetentionPolicy.RUNTIME)@Target(ElementType.FIELD)public @interface ImageUrl {    String error() default &quot;http://wangzhumo.com/css/images/avatar.png&quot;;}/** * If you have any questions, you can contact by email {wangzhumoo@gmail.com} * @author 王诛魔 2018/8/9 上午10:48 *  * 标记字段为Content,内容 */@Retention(RetentionPolicy.RUNTIME)@Target(ElementType.FIELD)public @interface Content {}</code></pre><p>@ImageUrl  与 @Content  中都没有什么方法,这里只是使用标记的功能</p><p>为了体现标记的作用</p><pre><code class="java">/** * If you have any questions, you can contact by email {wangzhumoo@gmail.com} * * @author 王诛魔 2018/8/9 上午10:47 */public class Whatever {    public String haha;    //瞎写的字段名,标记为正文    @Content    public String aaaa;    //瞎写的字段名,标记为图片地址    @ImageUrl(error = &quot;http://wangzhumo.com/images/java_heap_stack.png&quot;)    public String bajkfhajks;    public String waht;     /**     * 自动生产     *     * @return List     */    public static List&lt;Whatever&gt; create() {        List&lt;Whatever&gt; whatever = new ArrayList&lt;&gt;();        for (int i = 0; i &lt; 10; i++){            //开始建立            if (i==3){                whatever.add(new Whatever(String.format(Locale.CHINA,&quot;第%d个项目&quot;,i),&quot;&quot;));            }else{                whatever.add(new Whatever(String.format(Locale.CHINA,&quot;第%d个项目&quot;,i),&quot;http://wangzhumo.com/css/images/avatar.png&quot;));            }        }        return whatever;    }}</code></pre><p>在RecyclerView中使用</p><p>com.wangzhumo.playground.SimpleAdapter#onBindViewHolder</p><pre><code class="java">@Overridepublic void onBindViewHolder(@NonNull ViewHolder holder, int position) {    try {        for (Field field : getItem(position).getClass().getDeclaredFields()) {            field.setAccessible(true);            if (field.isAnnotationPresent(Content.class)) {                holder.bindView.setContext((String) field.get(getItem(position)));            } else if (field.isAnnotationPresent(ImageUrl.class)) {                String imageUrl = (String) field.get(getItem(position));                if (TextUtils.isEmpty(imageUrl)) {                    ImageUrl url = field.getAnnotation(ImageUrl.class);                    holder.bindView.setImageUrl(url.error());                }else{                    holder.bindView.setImageUrl(imageUrl);                }            }        }    } catch (IllegalAccessException e) {        e.printStackTrace();    }}</code></pre><p><code>TextUtils.isEmpty(imageUrl)</code>简单的判断,是否设置了值,如果它没有值,那就直接使用 url.error() 中设置的值</p><p><img src="/images/annotation_image_error.png" srcset="/img/loading.gif" alt="image_error"></p><p>在生成数据时,我给第4个位置的图片设置了<code>&quot;&quot;</code>空值,则这里直接显示了我 @ImageUrl( error = “xxxxx”)中设置的图片</p><p>如果我改造一下,设置GlideApp.with(imageUrl  ).error(@ImageUrl.error()) 可以成为一个很实用的方法</p><h4 id="编译时注解-CLASS"><a href="#编译时注解-CLASS" class="headerlink" title="编译时注解(CLASS)"></a>编译时注解(CLASS)</h4><p>对于我个人来说,基本上没有这样的需要,但是如<code>Dagger2</code> 使用编译时注解 + APT 实现依赖注入</p><p>其他如<code>ARouter</code>,<code>BufferKnike</code>,<code>Glide</code>也会使用这样的技术.</p><p>如Glide</p><pre><code class="java">package com.bumptech.glide.annotation.compiler;  //public final class GlideAnnotationProcessor extends AbstractProcessor{      @Override    public synchronized void init(ProcessingEnvironment processingEnvironment) {         super.init(processingEnvironment);        //...          //主要是初始化一些工具类啊什么的      }      @Override      public Set&lt;String&gt; getSupportedAnnotationTypes() {        //...        //该方法中返回所有注解的类        }      @Override      public SourceVersion getSupportedSourceVersion() {        return SourceVersion.latestSupported();      }      @Override      public boolean process(Set&lt;? extends TypeElement&gt; set, RoundEnvironment env) {        //...        //这里是重要的部分,通过注释我们就能知道它大概做什么了      }}</code></pre><ol><li><p>遍历得到需要解析的元素列表</p></li><li><p>判断符合要求的元素</p></li><li><p>修改,整理输出参数,或者借助APT生产代码等</p></li></ol><p>如果你对这部分感兴趣,不妨选一个库看看</p>]]></content>
    
    
    <categories>
      
      <category>Java</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Java</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>LeetCode-罗马数字转整数</title>
    <link href="undefined2018/08/06/roman-to-integer/"/>
    <url>2018/08/06/roman-to-integer/</url>
    
    <content type="html"><![CDATA[<p>给定一个罗马数字，将其转换成整数。输入确保在 1 到 3999 的范围内。</p><p><strong>示例 1:</strong></p><pre><code>输入: &quot;III&quot;输出: 3</code></pre><h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>这一题其实不在于算法有多难,而是在于你对于这个罗马数字与整形之间的关系要搞清楚</p><table><thead><tr><th>基本字符</th><th>I</th><th>V</th><th>X</th><th>L</th><th>C</th><th>D</th><th>M</th></tr></thead><tbody><tr><td>相应的阿拉伯数字表示为</td><td>1</td><td>5</td><td>10</td><td>50</td><td>100</td><td>500</td><td>1000</td></tr></tbody></table><p>上面是他们之间的对应关系,但是这还不够(以下来自百度百科)</p><a id="more"></a><ol><li>相同的数字连写，所表示的数等于这些数字相加得到的数,如:Ⅲ = 3</li><li>小的数字在大的数字的右边，所表示的数等于这些数字相加得到的数, 如:Ⅷ = 8; Ⅻ = 12</li><li>小的数字,(限于Ⅰ、X 和C)在大的数字的左边，所表示的数等于大数减小数得到的数,如:Ⅳ= 4; Ⅸ= 9</li><li>正常使用时,连写的数字重复不得超过三次</li><li>在一个数的上面画一条横线,表示这个数扩大1000倍</li></ol><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><ul><li>需要一个键值对来保存罗马数字与整形的关系</li><li>遍历,并比较前一个罗马字符与当前罗马字符的大小<ul><li>当前罗马字符更大,则+=</li><li>当前小,则-=</li></ul></li><li>输出结果</li></ul><h3 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h3><pre><code class="java">/** * If you have any questions, you can contact by email {wangzhumoo@gmail.com} * * @author 王诛魔 2018/8/7 下午5:41 * 给定一个罗马数字，将其转换成整数。输入确保在 1 到 3999 的范围内。 * * 示例 1: * * 输入: &quot;III&quot; * 输出: 3 * */public class RomanToIntClass {    private static HashMap&lt;Character, Integer&gt; contrastMap;    static {        contrastMap = new HashMap&lt;&gt;();        contrastMap.put(&#39;I&#39;, 1);        contrastMap.put(&#39;V&#39;, 5);        contrastMap.put(&#39;X&#39;, 10);        contrastMap.put(&#39;L&#39;, 50);        contrastMap.put(&#39;C&#39;, 100);        contrastMap.put(&#39;D&#39;, 500);        contrastMap.put(&#39;M&#39;, 1000);    }    /**     * 罗马转整形     * @param romanStr 罗马字符串     * @return 整数     */    public static int romanToInt(String romanStr){        char[] romanCharArray = romanStr.toCharArray();        int result = 0;        for (int i = 0; i &lt; romanCharArray.length; i++) {            //遍历这个罗马数组            if (i == romanCharArray.length -1 || contrastMap.get(romanCharArray[i+1]) &lt;= contrastMap.get(romanCharArray[i])){                //如果满足,说明当前的这个罗马字符是大于后一个罗马数字的,则应该加上当前的罗马字符                result += contrastMap.get(romanCharArray[i]);            }else{                //则是前面小,后面大,应该减去当前的这个罗马字符                result -= contrastMap.get(romanCharArray[i]);            }        }        return result;    }}</code></pre><h3 id="结果"><a href="#结果" class="headerlink" title="结果"></a>结果</h3><pre><code class="shell">输入:  MCMXCIV输出: 1994Process finished with exit code 0</code></pre>]]></content>
    
    
    <categories>
      
      <category>Programme</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Programme</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>算法复习笔记-快速排序</title>
    <link href="undefined2018/07/31/Arithmetic-quick-sort/"/>
    <url>2018/07/31/Arithmetic-quick-sort/</url>
    
    <content type="html"><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>通过一趟排序将要排序的数据分割成独立的两部分,其中一部分的所有数据都比另外一部分的所有数据都要小,然后再按此方法对这两部分数据分别进行快速排序,整个排序过程可以递归进行,以此达到整个数据变成有序序列。 </p><p>快速排序由 C. A. R. Hoare（东尼霍尔，Charles Antony Richard Hoare）在1960年提出 .而后经过很多人,很长时间的优化,才得到现在的版本.快速排序可以说是一个至关重要的算法了,现在的很多语言基础库中的排序,就是使用的快速排序算法来完成的.</p><p><img src="/images/quick_sort.png" srcset="/img/loading.gif" alt="quick_sort"></p><a id="more"></a><h3 id="思考"><a href="#思考" class="headerlink" title="思考"></a>思考</h3><p>这里我打算使用前后指针的方法来完成快速排序.定义两个指针,一个curr指向数组的第一个元素,而pre指向的是curr-1的位置.</p><ol><li>定义curr以及pre两个指针</li><li>当array[curr] &lt; key 则curr与pre指针同时向后移动</li><li>当array[curr] &gt; key 则curr向后移动一位,pre保持不动(当前这个位置的值是小于key的)</li><li>当array[curr] &lt; key 则需要交换array[curr]以及array[pre]  </li></ol><p>可以这么说,每次找到array[curr] 这个位置的元素比key要小,说明它不应该在当前的这个位置,需要和pre的位置元素交换,应为pre一直是指向了最后一个小于key的元素位置</p><p>看上图所示,序号5的这一排,我用框分出了三个部分.</p><ul><li>绿色区域[0,pre]  都是小于key的</li><li>红色区域[pre+1,curr)都是大于key的</li><li>而橙色的区域[curr,right]都是没有经过比较的区域</li></ul><p>那么很容易就可以看出,其实我们就是想让这个数组,以pre为分界点,左面的都小于key,而右面的都大于</p><p>那么,只要发现array[curr] &lt; key 直接和array[pre+1]交换位置,还是满足上面的要求的.</p><h3 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h3><pre><code class="java">/** * If you have any questions, you can contact by email {wangzhumoo@gmail.com} * @author 王诛魔 2018/7/31 下午5:54 * 快速排序[left,right) */public class QuickClass{    //为了给分割数组的方法使用,用于选出一个key    private static Random mRandom = new Random(System.currentTimeMillis());    /**     * 快速排序入口-前后指针     *     * @param array 要排序的数组     * @param left  左边界     * @param right 右边界     */    public static void quickSort(int[] array, int left, int right) {        //如果left &gt;= right了,说明这个数组已经不能再继续分了        if (left &gt;= right) return;        //此处找到这个p,分割点,需要经过一轮的快速排序        int p = partition(array, left, right);        //递归调用        quickSort(array, left, p);        quickSort(array, p + 1, right);    }    /**     * 分割数组     * 排序array[left , right] 的顺序     * 使得返回一个p ,在 array[left,p] 都小于k  在array[p+1 , right)都大于k     *     * @param array 要排序的数组     * @param left  左边边界     * @param right 右边边界     * @return p 分割了两个数组的位置     */    private static int partition(int[] array, int left, int right) {        //随机替换一个元素到key的位置,这是为了避免如果排列一个近乎有序的数组时,        //造成一侧的子数组特多,而另一侧则很少,使得效率降低        swap(array,left,mRandom.nextInt(right - left + 1) + left);        //拿出key        int key = array[left];        //定义一个pre等于curr-1        //为什么直接赋值为left那?因为left是我key的位置,        //可以直接不用比较,curr = pre+1即是第一个要比较的元素        int pre = left;        for(int curr = pre+1;curr &lt;= right;curr++){            //此时判断 array[curr] 与 key的关系即可            if(array[curr] &lt; key){                swap(array,curr, ++pre);                            }        }        //完成后需要把key元素移动到pre的位置去        swap(array,left,pre);        return pre;    }    /**     * 交换位置     *     * @param arr 数组     * @param a     * @param b     */    private static void swap(int[] arr, int a, int b) {        int temp = arr[a];        arr[a] = arr[b];        arr[b] = temp;    } }</code></pre><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>这还只是快速排序的最简单方法,还有更为复杂一些的三路快排等,后面继续学习</p><p>测试打印:</p><pre><code class="shell">1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21</code></pre>]]></content>
    
    
    <categories>
      
      <category>Programme</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Programme</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>算法复习笔记-归并排序</title>
    <link href="undefined2018/07/31/Arithmetic-merge-sort/"/>
    <url>2018/07/31/Arithmetic-merge-sort/</url>
    
    <content type="html"><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>归并排序可以说是一个经典的使用分治思维的排序算法了.</p><p>先把问题<strong>分</strong>为一些小的问题然后递归求解,而使用<strong>治</strong>的思想把分阶段求得的答案合并在一起.</p><p>首先我得来一张图说明这个事:</p><p><img src="/images/merge_sort.png" srcset="/img/loading.gif" alt="merge"></p><a id="more"></a><p>上图显示了一个输入数组被分解的过程,下面只要我们能给他合并起来就可以完成这是输入数组的排序了</p><h3 id="合并思路"><a href="#合并思路" class="headerlink" title="合并思路"></a>合并思路</h3><p>合并的时候我们需要一个临时数组的帮助,这个临时数组的大小应该是与输入数组的大小一致的.</p><p><code>int[] array,int left,int mid,int right,int [] tempArray</code></p><p>需要传入  需要排序的数组,左数组的左边界, 左数组的右边界  ,右数组右边界,临时数组</p><ol><li><p>遍历左右数组,直至两个数组至少有一个数组全部遍历一次</p><p>=&gt;   左数组当前index &lt;= mid  &amp;&amp;  右数组当前index  &lt;= right</p></li><li><p>比较左右两个数组中元素的大小.</p><p>分为两种情况:</p><ul><li>左数组当前元素 &lt;= 右边数组当前元素<ul><li>交换tempArray当前位置 与 左数组当前元素</li><li>tempArray 的index ++ ,因为这一个位置已经确定了,应该确定下一个元素了 </li><li>左边当前元素index ++ ,这个元素已经比较过了,应该移动到下一个位置与右数组元素比较</li></ul></li><li>右边当前元素更大<ul><li>交换tempArray当前位置 与 右数组当前元素</li><li>tempArray 的index ++ </li><li>右边当前元素index ++ </li></ul></li></ul></li><li><p>当上面的循环完成后,还有一种可能是,右边或左边的数组中还有元素没有参与比较</p><p>=&gt;   因为这些剩下的元素都比另一个数组中元素大,而这个数组本身也是有序的则</p><p>=&gt;   把这些剩下的元素全部追加到tempArray</p></li><li><p>最后我们发现,tempArray已经是一个有序的数组了,但是我们要排序的是array</p><p>=&gt;   把tempArray中元素全部复制给array</p></li></ol><h3 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h3><pre><code class="java">/** * If you have any questions, you can contact by email {wangzhumoo@gmail.com} * @author 王诛魔 2018/7/31 下午4:26 * 归并排序 */public class MergeClass {    /**     * 归并排序     *     * @param array   需要排序的数组     * @param left  左边界     * @param right  右边界     * @param tempArray 临时数组,避免频繁创建数组     */    public static void MergeSort(int[] array,int left,int right,int [] tempArray){        mergeSort(array, left, right, tempArray);    }    public static void mergeSort(int[] array,int left,int right,int [] tempArray){        //通过观察上图,我们可以知道,如果 left &gt;= right         //就是最小的数组了,所以要停止递归,开始返回        if(left &gt;= right){            return;        }        //计算当前传入数组的中点,用来把数组分成两个部分,这里注意避免int越界        int mid = left + (right - left) / 2 ;        //递归调用左右数组        //左边数组 [left , mid]        mergeSort(array, left, mid, tempArray);        //右边数组 (mid,right]        mergeSort(array, mid + 1 , right , tempArray);        //合并这个数组,需要原始数组,临时数组,左右边界以及mid(这是为了计算右边数组的开始index)        merge(array,left,mid,right,tempArray);    }    /**     * 合并数组     *     * @param array     * @param left     * @param mid     * @param right     * @param tempArray     */    public static void merge(int[] array,int left,int mid,int right,int [] tempArray){        //为了后面的操作,先定义好几个边界值        int i = left;   //左数组index开始位置        int j = mid + 1;   //右数组idnex开始位置        int temp = 0;  //临时数组index的开始位置        //1.循环        while(i &lt;= mid &amp;&amp; j &lt;= right){            //2.比较大小            if(array[i] &lt;= array[j]){                //合并赋值与index ++                 tempArray[temp++] = array[i++];            }else{                tempArray[temp++] = array[j++];            }        }        //3.剩余元素        while(i &lt;= mid){            tempArray[temp++] = array[i++];        }        while(j &lt;= right){            tempArray[temp++] = array[j++];        }        //4.复制回array        temp = 0;        while(left &lt;= right){            array[left++] = tempArray[temp++];        }    } }</code></pre><p>最后测试了一下,没问题</p><pre><code class="shell"> 13 21 23 26 45 67 123 213 456 563</code></pre>]]></content>
    
    
    <categories>
      
      <category>Programme</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Programme</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>ConstraintLayout使用指南-进阶使用</title>
    <link href="undefined2018/07/30/ConstraintLayout-Advance/"/>
    <url>2018/07/30/ConstraintLayout-Advance/</url>
    
    <content type="html"><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p><a href="http://www.wangzhumo.com/2018/07/12/ConstraintLayout-Basic/">ConstraintLayout使用指南-基础的约束</a></p><p>通过上一篇的了解,大概已经知道ConstraintLayout的基本功能了,但是对于我们日常的开发工作,还是有一定的差距,所以这一篇,主要记录一些开发中用到的进阶功能.</p><p>行了,接上文的<strong>纵横比</strong>,上代码</p><a id="more"></a><h3 id="开发中实例"><a href="#开发中实例" class="headerlink" title="开发中实例"></a>开发中实例</h3><h4 id="参照线-Guidelines"><a href="#参照线-Guidelines" class="headerlink" title="参照线(Guidelines)"></a>参照线(Guidelines)</h4><p><img src="/images/constraint_guideline.png" srcset="/img/loading.gif" alt="guide"></p><p>本来以为很高端</p><pre><code class="java">public class Guideline extends View{    构造函数{        super.setVisibility(8);    }       public void setVisibility(int visibility) {  }    public void draw(Canvas canvas) { }}</code></pre><p>哈哈,就是一个VIew,不绘制在界面上而已.</p><pre><code class="xml">&lt;android.support.constraint.Guideline      android:id=&quot;@+id/guideline&quot;      android:layout_width=&quot;wrap_content&quot;      android:layout_height=&quot;wrap_content&quot;      app:layout_constraintGuide_begin=&quot;127dp&quot;    //这里是指从右边开使,偏移127dp      app:layout_constraintGuide_end=&quot;127dp&quot;  //这里是指从左边开使,偏移127dp      app:layout_constraintGuide_percent=&quot;0.5&quot;  //在整个布局的50%处,也就是居中      android:orientation=&quot;vertical&quot;/&gt;    //线的类型是,垂直</code></pre><p>那么,我们可以将其他控件附着在它上面,一起布局移动</p><h4 id="Chain-链"><a href="#Chain-链" class="headerlink" title="Chain 链"></a>Chain 链</h4><p>这玩意可厉害了,就比权重什么的强了有1000倍吧</p><p>比如我想把下图这样的三个控件平分整个布局宽度</p><p><img src="/images/constraint_unchain.png" srcset="/img/loading.gif" alt="chain"></p><p>正常的操作是,用一个LinearLayout设置权重</p><p>如果我们使用ConstraintLayout会更加简单,而且功能更多</p><pre><code class="xml">&lt;layout xmlns:app=&quot;http://schemas.android.com/apk/res-auto&quot;        xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;&gt;    &lt;android.support.constraint.ConstraintLayout            android:id=&quot;@+id/rootView&quot;            android:background=&quot;@android:color/white&quot;            android:layout_width=&quot;match_parent&quot;            android:layout_height=&quot;match_parent&quot;&gt;        &lt;ImageView                android:layout_width=&quot;wrap_content&quot;                android:layout_height=&quot;wrap_content&quot;                app:srcCompat=&quot;@mipmap/ic_launcher&quot;                android:id=&quot;@+id/imageView2&quot;                app:layout_constraintStart_toStartOf=&quot;parent&quot;                app:layout_constraintEnd_toStartOf=&quot;@+id/imageView3&quot;                app:layout_constraintHorizontal_chainStyle=&quot;spread_inside&quot;/&gt;        &lt;ImageView                android:layout_width=&quot;wrap_content&quot;                android:layout_height=&quot;wrap_content&quot;                app:srcCompat=&quot;@mipmap/ic_launcher&quot;                android:id=&quot;@+id/imageView3&quot;                app:layout_constraintStart_toEndOf=&quot;@+id/imageView2&quot;                app:layout_constraintEnd_toStartOf=&quot;@+id/imageView4&quot;/&gt;        &lt;ImageView                android:layout_width=&quot;wrap_content&quot;                android:layout_height=&quot;wrap_content&quot;                app:srcCompat=&quot;@mipmap/ic_launcher&quot;                android:id=&quot;@+id/imageView4&quot;                app:layout_constraintStart_toEndOf=&quot;@+id/imageView3&quot;                app:layout_constraintEnd_toEndOf=&quot;parent&quot;/&gt;    &lt;/android.support.constraint.ConstraintLayout&gt;&lt;/layout&gt;</code></pre><p>你可能会说,这么多layout_constraintStart_toEndOf 什么的,明明更麻烦</p><p><img src="/images/constraint_chain.gif" srcset="/img/loading.gif" alt=""></p><h5 id="操作步骤"><a href="#操作步骤" class="headerlink" title="操作步骤"></a>操作步骤</h5><ol><li>选中一个控件</li><li>框选所有要组成<code>Chain</code>的控件</li><li>添加Chain</li></ol><p>还能看到我点击了一个  链接  按钮,他们三个的布局又发生了变化</p><h5 id="chainStyle"><a href="#chainStyle" class="headerlink" title="chainStyle"></a>chainStyle</h5><p>这是由chainStyle的改变造成的</p><pre><code class="xml">app:layout_constraintHorizontal_chainStyle=&quot;spread_inside&quot;</code></pre><ul><li><p>spread(默认的模式)</p><p>平分间隙让多个 View 布局到剩余空间</p></li><li><p>spread_inside</p><p>边缘的两个 View 紧贴父控件边缘,剩余的 View 在剩余的空间内平分间隙布局</p></li><li><p>packed</p><p>所有的Views打包居中,相互没有间隔</p></li></ul><blockquote><p>要注意的是spread还有两个强大的东西</p></blockquote><ol><li><p>如果我把三个控件的width设置为 0dp会这样:</p><p><img src="/images/constraint_width.png" srcset="/img/loading.gif" alt="0dp"></p></li></ol><ol><li><p>如果你想让他们几个控件按比例平分:</p><p>可以添加该属性</p><pre><code class="xml">app:layout_constraintHorizontal_weight = &quot;0.3&quot;</code></pre><p><img src="/images/constraint_weight.png" srcset="/img/loading.gif" alt="weight"></p><p>这是我设置的  0.3 : 0.2 : 0.5</p></li></ol><h4 id="覆盖父控件"><a href="#覆盖父控件" class="headerlink" title="覆盖父控件"></a>覆盖父控件</h4><pre><code class="xml">&lt;ImageView            android:layout_width=&quot;match_parent&quot;            android:layout_height=&quot;200dp&quot;             app:srcCompat=&quot;@drawable/ic_launcher_background&quot;            android:id=&quot;@+id/imageView5&quot;             android:scaleType=&quot;fitXY&quot;            app:layout_constraintStart_toStartOf=&quot;parent&quot;            app:layout_constraintEnd_toEndOf=&quot;parent&quot;            app:layout_constraintTop_toTopOf=&quot;parent&quot;            tools:ignore=&quot;VectorDrawableCompat&quot;/&gt;    &lt;ImageView            android:id=&quot;@+id/imageView7&quot;            android:layout_width=&quot;40dp&quot;            android:layout_height=&quot;40dp&quot;            app:srcCompat=&quot;@mipmap/icon_youtube&quot;            tools:layout_editor_absoluteX=&quot;160dp&quot;            app:layout_constraintBottom_toBottomOf=&quot;@+id/imageView5&quot;             app:layout_constraintTop_toBottomOf=&quot;@+id/imageView5&quot;/&gt;</code></pre><p>主要关注这两句</p><pre><code class="xml">app:layout_constraintBottom_toBottomOf=&quot;@+id/imageView5&quot; app:layout_constraintTop_toBottomOf=&quot;@+id/imageView5&quot;</code></pre><p>我们的imageView7  吧它的上下都指定了位于 imageView5的下底边.</p><p><img src="/images/constraint_above.png" srcset="/img/loading.gif" alt="above"></p><h4 id="百分比布局"><a href="#百分比布局" class="headerlink" title="百分比布局"></a>百分比布局</h4><pre><code>app:layout_constraintHorizontal_bias=&quot;0.3&quot;</code></pre><p>用好这个属性和 GuideLine即可</p><h3 id="未完待续"><a href="#未完待续" class="headerlink" title="未完待续.."></a>未完待续..</h3><p>后面有用的,会继续添加到这里</p>]]></content>
    
    
    <categories>
      
      <category>Android</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Android</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>今日头条的屏幕适配方案</title>
    <link href="undefined2018/07/30/Screen-toutiao-resize/"/>
    <url>2018/07/30/Screen-toutiao-resize/</url>
    
    <content type="html"><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><blockquote><p>今日头条传送门:</p><p><a href="https://mp.weixin.qq.com/s/d9QCoBP6kV9VSWvVldVVwA" target="_blank" rel="noopener">https://mp.weixin.qq.com/s/d9QCoBP6kV9VSWvVldVVwA</a></p></blockquote><p>现在Android端的适配方案也是五花八门的,但就是这样,我们的UI设计师们还觉得和他们的设计图不一致,我真的是服了他们的像素眼.</p><p>今日头条的这个适配方案,可以说是取巧到一个<strong>妙啊</strong>的水平了.</p><a id="more"></a><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>android.util.TypedValue#applyDimension</p><pre><code class="java">public static float applyDimension(int unit, float value,                                       DisplayMetrics metrics)    {        switch (unit) {        case COMPLEX_UNIT_PX:            return value;        case COMPLEX_UNIT_DIP:            return value * metrics.density;        case COMPLEX_UNIT_SP:            return value * metrics.scaledDensity;        case COMPLEX_UNIT_PT:            return value * metrics.xdpi * (1.0f/72);        case COMPLEX_UNIT_IN:            return value * metrics.xdpi;        case COMPLEX_UNIT_MM:            return value * metrics.xdpi * (1.0f/25.4f);        }        return 0;    }</code></pre><p>这一段就是,系统来调用,以便缩放调整自己的大小,满足对应屏幕大小的代码了.</p><p>主要看<code>COMPLEX_UNIT_PX</code>,<code>COMPLEX_UNIT_DIP</code> ,<code>COMPLEX_UNIT_SP</code>这三个case</p><p>因为我们开发的过程中,也主要是用了这三种单位,尤其是DIP,很多时候我们会把字体的大小也用DIP这个单位来写.</p><blockquote><p>value * metrics.density</p></blockquote><p>通过观察我们可以发现,都是value * DisplayMetrics.常量</p><p>那么我要是能把DisplayMetrics里面的这个常量值改了,是不是就可以为所欲为了?</p><pre><code class="java"> public float density; //... public float scaledDensity;</code></pre><p>幸福来得太突然,这几个常量都是 public 而且非 final的.</p><h3 id="具体实现"><a href="#具体实现" class="headerlink" title="具体实现"></a>具体实现</h3><p>举例说明我最近做了一个大屏的项目,使得是960dp,看看这个公式</p><p>我的这个屏幕宽度是 3000px,他的宽度是960dp</p><pre><code class="java">case COMPLEX_UNIT_DIP:      return value * metrics.density;</code></pre><p>带入公式</p><pre><code class="java">3000px  = density * 960dp =&gt;  则  density = 3000 / 960=&gt;  则  density = 屏幕真实宽度 / 设计图宽度(dp)</code></pre><p>那么下面直接贴代码了</p><pre><code class="java">/** * If you have any questions, you can contact by email {wangzhumoo@gmail.com} * * @author 王诛魔 2018/6/25 下午5:17 * * 今日头条的屏幕适配方案: * 修改density值,强行把所有不同尺寸分辨率的手机的宽度dp值改成同一个值 */public class ResizeDensity {    private static float sNoncompatDensity;    private static float sNoncompatScaledDensity;    /**     *     * @param activity activity     * @param application application     */    public static void setCustomDensity(@NonNull Activity activity, @NonNull final Application application) {        DisplayMetrics appDisplayMetrics = application.getResources().getDisplayMetrics();        if (sNoncompatDensity == 0) {            sNoncompatDensity = appDisplayMetrics.density;            sNoncompatDensity = appDisplayMetrics.scaledDensity;            application.registerComponentCallbacks(new ComponentCallbacks() {                @Override                public void onConfigurationChanged(Configuration newConfig) {                    if (newConfig != null &amp;&amp; newConfig.fontScale &gt; 0) {                        sNoncompatScaledDensity = application.getResources().getDisplayMetrics().scaledDensity;                    }                }                @Override                public void onLowMemory() {                }            });        }        float targetDensity = appDisplayMetrics.widthPixels / 960;        float targetScaleDensity = targetDensity * (sNoncompatScaledDensity / sNoncompatDensity);        int targetDensityDpi = (int) (160 * targetDensity);        appDisplayMetrics.density = targetDensity;        appDisplayMetrics.scaledDensity = targetScaleDensity;        appDisplayMetrics.densityDpi = targetDensityDpi;        final DisplayMetrics activityDisplayMetrics = activity.getResources().getDisplayMetrics();        activityDisplayMetrics.density = targetDensity;        activityDisplayMetrics.scaledDensity = targetScaleDensity;        activityDisplayMetrics.densityDpi = targetDensityDpi;    }}</code></pre><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>直接在Activity中去调用就可以达到效果了.</p><blockquote><p>今日头条发现的一个小问题:</p><p>但是测试后发现另外一个问题，就是如果在系统设置中切换字体，再返回应用，字体并没有变化。于是还得监听下字体切换，调用 Application#registerComponentCallbacks 注册下 onConfigurationChanged 监听即可。</p></blockquote><p>阅读源码…读源码…源码…</p>]]></content>
    
    
    <categories>
      
      <category>Android</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Android</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Android事件分发机制-ViewGroup</title>
    <link href="undefined2018/07/30/Android-MotionEvent-ViewGroup/"/>
    <url>2018/07/30/Android-MotionEvent-ViewGroup/</url>
    
    <content type="html"><![CDATA[<h3 id="总览"><a href="#总览" class="headerlink" title="总览"></a>总览</h3><h4 id="什么是事件分发"><a href="#什么是事件分发" class="headerlink" title="什么是事件分发"></a>什么是事件分发</h4><p>就是将系统传递过来的MotionEvent分发到某个具体的View,并处理这个MotionEvent的整个过程</p><p>我们先要明白</p><ul><li>责任链模式</li><li>ViewGroup和View的树形结构</li><li>一次完整的MotionEvent事件(ACTION_DOWN , ACTION_MOVE , ACTION_UP)</li></ul><a id="more"></a><h4 id="主要方法"><a href="#主要方法" class="headerlink" title="主要方法"></a>主要方法</h4><ol><li><p>boolean dispatchTouchEvent(MotionEvent ev)</p><p>这个方法是分发点击事件的方法,只要这个点击事件能传递到当前的控件,就会调用这个方法</p></li><li><p>boolean onInterceptTouchEvent(MotionEvent ev)</p><p>是否要拦截这个事件?要明白的是,View是没有这个方法的,因为View是最下层的,没有资格去拦截.</p><p>它要么消费事件,要么不消费返回它的父控件,而不是自己拦截掉事件.</p></li><li><p>boolean onTouchEvent(MotionEvent event) </p><p>处理点击事件,ViewGroup的dispatchTouchEvent方法会调用这个方法.</p></li></ol><h4 id="主要参与成员"><a href="#主要参与成员" class="headerlink" title="主要参与成员"></a>主要参与成员</h4><ol><li><p>Activity</p><p>我们要明白,一个事件在物理硬件层产生后,是由系统的输入系统处理,然后经过其传递通道(如果深入了解,我们可以知道,其底层是由一个双向的Socket来做到的),传递到UI线程,Activity是第一个拿到这个事件的,但是它并不能处理这个事件,所以Activity必须把这个事件分发下去,而不会自己处理.</p></li><li><p>ViewGroup</p><p>它与View最大的不同在于,虽然它也是View的子类,但是它可能还管理着其他ViewGroup &amp; View,所以它是有所有的三个方法的.</p></li><li><p>View</p><p>既是所有控件的父类,也是我们说的最基本的控件,它只能选择处理或不处理事件,没有其他操作了.</p></li></ol><h3 id="阅读源码"><a href="#阅读源码" class="headerlink" title="阅读源码"></a>阅读源码</h3><h4 id="Activity-dispatchTouchEvent"><a href="#Activity-dispatchTouchEvent" class="headerlink" title="Activity#dispatchTouchEvent"></a>Activity#dispatchTouchEvent</h4><pre><code class="java">public boolean dispatchTouchEvent(MotionEvent ev) {        if (ev.getAction() == MotionEvent.ACTION_DOWN) {            onUserInteraction();   //空方法,不看        }        //查看superDispatchTouchEvent发现是一个抽象方法,那么我们去找它的实现类        if (getWindow().superDispatchTouchEvent(ev)) {            return true;        }        //直接调用了onTouchEvent()        return onTouchEvent(ev);}</code></pre><p>=&gt; Window 的实现类,现在只有一个 PhoneWindow</p><pre><code class="java"> @Override public boolean superDispatchTouchEvent(MotionEvent event) {        return mDecor.superDispatchTouchEvent(event);     //那么我们知道mDecor是DecorView,它继承了FrameLayout并且是TitleView 和 ContextView的容器 }//DecorView的superDispatchTouchEvent方法public boolean superDispatchTouchEvent(MotionEvent event) {        return super.dispatchTouchEvent(event);    }</code></pre><p>很明显的,我们知道这个super是指的DecorView的父类ViewGroup</p><p><code>android.view.ViewGroup#dispatchTouchEvent</code></p><h4 id="ViewGroup-dispatchTouchEvent"><a href="#ViewGroup-dispatchTouchEvent" class="headerlink" title="ViewGroup#dispatchTouchEvent"></a>ViewGroup#dispatchTouchEvent</h4><p>这个代码长到爆炸</p><pre><code class="java">@Overridepublic boolean dispatchTouchEvent(MotionEvent ev) {     //...省略    //搜了半天才知道,mInputEventConsistencyVerifier调试用的,连带辅助功能的都省略了    boolean handled = false;    //onFilterTouchEventForSecurity 这个方法是View中的,如果false就要丢弃事件    //第一步 :     //如果是ture才继续来处理这个事件,其实就是Window是否被遮盖的值    if (onFilterTouchEventForSecurity(ev)) {        final int action = ev.getAction();        final int actionMasked = action &amp; MotionEvent.ACTION_MASK;        // Handle an initial down.        if (actionMasked == MotionEvent.ACTION_DOWN) {            //第二步 :             //这里清除掉了所有之前的状态,            //1. clearTouchTargets() 看起来是清空了一个保存需要接受事件View的链表            //   mFirstTouchTarget链表初始化            //2.mGroupFlags &amp;= ~FLAG_DISALLOW_INTERCEPT;            //  这个标记意为:不允许ViewGroup对触摸事件进行拦截            cancelAndClearTouchTargets(ev);            resetTouchState();        }        final boolean intercepted;        //第三步:        //检查当前ViewGroup是否想要拦截触摸事件,并把值写入intercepted返回        if (actionMasked == MotionEvent.ACTION_DOWN || mFirstTouchTarget != null) {                   //这个标志位通过requestDisallowInterceptTouchEvent来设置                final boolean disallowIntercept = (mGroupFlags &amp; FLAG_DISALLOW_INTERCEPT) != 0;                if (!disallowIntercept) {                    //如果不禁用拦截事件,则调用onInterceptTouchEvent(ev);                    //并且返回onInterceptTouchEvent的返回值给intercepted                    intercepted = onInterceptTouchEvent(ev);                    ev.setAction(action); // restore action in case it was changed                } else {                    intercepted = false;                }        } else {                // There are no touch targets and this action is not an initial down                // so this view group continues to intercept touches.                intercepted = true;        }        //...省略        //第四步,检查是否取消了事件        final boolean canceled = resetCancelNextUpFlag(this)            || actionMasked == MotionEvent.ACTION_CANCEL;        // 第五步,把事件canceled,intercepted  既没有被取消,也没有被拦截的时候        // 把事件分发到它的子View中去        final boolean split = (mGroupFlags &amp; FLAG_SPLIT_MOTION_EVENTS) != 0;        TouchTarget newTouchTarget = null;        boolean alreadyDispatchedToNewTouchTarget = false;        if (!canceled &amp;&amp; !intercepted) {            //省略..            if (actionMasked == MotionEvent.ACTION_DOWN                || (split &amp;&amp; actionMasked == MotionEvent.ACTION_POINTER_DOWN)                || actionMasked == MotionEvent.ACTION_HOVER_MOVE) {                final int actionIndex = ev.getActionIndex(); // always 0 for down                final int idBitsToAssign = split ? 1 &lt;&lt; ev.getPointerId(actionIndex)                    : TouchTarget.ALL_POINTER_IDS;                //清空这个idBitsToAssign之前的TouchTarget链表                removePointersFromTouchTargets(idBitsToAssign);               //获取这个View的所有子View个数                final int childrenCount = mChildrenCount;                if (newTouchTarget == null &amp;&amp; childrenCount != 0) {                    final float x = ev.getX(actionIndex);                    final float y = ev.getY(actionIndex);                    // Find a child that can receive the event.                    // Scan children from front to back.                    final ArrayList&lt;View&gt; preorderedList = buildTouchDispatchChildList();                    final boolean customOrder = preorderedList == null                        &amp;&amp; isChildrenDrawingOrderEnabled();                    final View[] children = mChildren;                    //第六步,执行事件分发                    //我们可以看到这里是遍历所有的子View,并把                    for (int i = childrenCount - 1; i &gt;= 0; i--) {                        final int childIndex = getAndVerifyPreorderedIndex(                           childrenCount, i, customOrder);                        final View child = getAndVerifyPreorderedView(                            preorderedList, children, childIndex);                        //省略...                        //这里判断,当前循环到的这个子View是否可点击,并且这个坐标                        //在子View的可视范围内,如果都满足,则跳出判断继续执行下面的代码,如果                        //不能满足条件,则continue,跳过这个View                        if (!canViewReceivePointerEvents(child)                          || !isTransformedTouchPointInView(x, y, child, null)) {                            ev.setTargetAccessibilityFocus(false);                            continue;                        }                        newTouchTarget = getTouchTarget(child);                        if (newTouchTarget != null) {                            // Child is already receiving touch within its bounds.                            // Give it the new pointer in addition to the ones it is handling.                            newTouchTarget.pointerIdBits |= idBitsToAssign;                            break;                        }                        resetCancelNextUpFlag(child);                        //我们可以看到,这里把事件分发下去了,给了当前的这个child                        if (dispatchTransformedTouchEvent(ev, false, child, idBitsToAssign)) {                            // Child wants to receive touch within its bounds.                            //如果能走到这里,则子View返回的肯定是ture,说明子View                            //消费 &amp; 拦截了这个事件                            mLastTouchDownTime = ev.getDownTime();                            if (preorderedList != null) {                                // childIndex points into presorted list, find original index                                for (int j = 0; j &lt; childrenCount; j++) {                                    if (children[childIndex] == mChildren[j]) {                                        mLastTouchDownIndex = j;                                        break;                                    }                                }                            } else {                                mLastTouchDownIndex = childIndex;                            }                            mLastTouchDownX = ev.getX();                            mLastTouchDownY = ev.getY();                            //ddTouchTarget()将child添加到mFirstTouchTarget                            newTouchTarget = addTouchTarget(child, idBitsToAssign);                            //设置alreadyDispatchedToNewTouchTarget为true                            alreadyDispatchedToNewTouchTarget = true;                            break;                        }                        // The accessibility focus didn&#39;t handle the event, so clear                        // the flag and do a normal dispatch to all children.                        ev.setTargetAccessibilityFocus(false);                    }                    if (preorderedList != null) preorderedList.clear();                }                if (newTouchTarget == null &amp;&amp; mFirstTouchTarget != null) {                    // Did not find a child to receive the event.                    // Assign the pointer to the least recently added target.                    newTouchTarget = mFirstTouchTarget;                    while (newTouchTarget.next != null) {                        newTouchTarget = newTouchTarget.next;                    }                    newTouchTarget.pointerIdBits |= idBitsToAssign;                }            }        }        //以上,判断不被取消,不被拦截的方法完毕了        //第七步,继续分发事件        // Dispatch to touch targets.        //这里注意看dispatchTransformedTouchEvent的第三个参数,是null        //在该方法中,child这个参数为null,则是直接调用了super.dispatchTouchEvent(ev)        if (mFirstTouchTarget == null) {            // No touch targets so treat this as an ordinary view.            handled = dispatchTransformedTouchEvent(ev, canceled, null,                                                    TouchTarget.ALL_POINTER_IDS);        } else {            // Dispatch to touch targets, excluding the new touch target if we already            // dispatched to it.  Cancel touch targets if necessary.            TouchTarget predecessor = null;            TouchTarget target = mFirstTouchTarget;            while (target != null) {                //TouchTarget   这里是一直在遍历这个链表,进行判断,事件分发                final TouchTarget next = target.next;                if (alreadyDispatchedToNewTouchTarget &amp;&amp; target == newTouchTarget) {                    handled = true;                } else {                    final boolean cancelChild = resetCancelNextUpFlag(target.child)                        || intercepted;                    if (dispatchTransformedTouchEvent(ev, cancelChild,                                                      target.child, target.pointerIdBits)) {                        handled = true;                    }                    if (cancelChild) {                        if (predecessor == null) {                            mFirstTouchTarget = next;                        } else {                            predecessor.next = next;                        }                        target.recycle();                        target = next;                        continue;                    }                }                predecessor = target;                target = next;            }        }        //第八步 如果有必要,更新取消标记        // Update list of touch targets for pointer up or cancel, if needed.        if (canceled            || actionMasked == MotionEvent.ACTION_UP            || actionMasked == MotionEvent.ACTION_HOVER_MOVE) {            resetTouchState();        } else if (split &amp;&amp; actionMasked == MotionEvent.ACTION_POINTER_UP) {            final int actionIndex = ev.getActionIndex();            final int idBitsToRemove = 1 &lt;&lt; ev.getPointerId(actionIndex);            removePointersFromTouchTargets(idBitsToRemove);        }    }    if (!handled &amp;&amp; mInputEventConsistencyVerifier != null) {        mInputEventConsistencyVerifier.onUnhandledEvent(ev, 1);    }    return handled;}</code></pre><p>我们不妨来梳理一下</p><p>第一步至第三步都是根据各种标记,是否可见等来判断是否需要分发这个事件.</p><p>从第四步开始,才是开始分发这个事件的代码,第五步判断是不是DOWN,MOVE事件,如果是就开始分发给每一个子View,同时把这个View添加到了<code>mFirstTouchTarget</code>这个链表中</p><p>而我们可以看到第七步,<code>mFirstTouchTarget == null</code>判断这个链表,如果不是null就继续分发事件,如果是null的话就直接回调父类的<code>super.dispatchTouchEvent</code></p><p>这样我们可以得出一个结论:</p><blockquote><p>如果一个View没有接收到<code>DOWN</code>事件,而后的事件它肯定也无法接收到.</p></blockquote><h4 id="android-view-ViewGroup-dispatchTransformedTouchEvent"><a href="#android-view-ViewGroup-dispatchTransformedTouchEvent" class="headerlink" title="android.view.ViewGroup#dispatchTransformedTouchEvent"></a>android.view.ViewGroup#dispatchTransformedTouchEvent</h4><pre><code class="java"> private boolean dispatchTransformedTouchEvent(MotionEvent event, boolean cancel,            View child, int desiredPointerIdBits) {        final boolean handled;        //省略...        // Perform any necessary transformations and dispatch.        if (child == null) {            //如果子View为空,则把自己当做一个View来处理,这里是直接调用的View.dispatchTouchEvent            handled = super.dispatchTouchEvent(transformedEvent);        } else {            final float offsetX = mScrollX - child.mLeft;            final float offsetY = mScrollY - child.mTop;            transformedEvent.offsetLocation(offsetX, offsetY);            if (! child.hasIdentityMatrix()) {                transformedEvent.transform(child.getInverseMatrix());            }            //这里就很明白了,事件又传递到该ViewGroup的子View中去了            handled = child.dispatchTouchEvent(transformedEvent);        }        // Done.        transformedEvent.recycle();        //返回        return handled;    }</code></pre><h4 id="android-view-ViewGroup-onInterceptTouchEvent"><a href="#android-view-ViewGroup-onInterceptTouchEvent" class="headerlink" title="android.view.ViewGroup#onInterceptTouchEvent"></a>android.view.ViewGroup#onInterceptTouchEvent</h4><pre><code class="java">   public boolean onInterceptTouchEvent(MotionEvent ev) {        if (ev.isFromSource(InputDevice.SOURCE_MOUSE)                &amp;&amp; ev.getAction() == MotionEvent.ACTION_DOWN                &amp;&amp; ev.isButtonPressed(MotionEvent.BUTTON_PRIMARY)                &amp;&amp; isOnScrollbarThumb(ev.getX(), ev.getY())) {            return true;        }        return false;    }</code></pre><p>注意看一下他的注释</p><p><code>Implement this method to intercept all touch screen motion events.</code></p><p>一般都是返回false的,如果你需要拦截所有的事件而不去分发,重写然后返回ture即可</p><h4 id="而ViewGroup的onTouchEvent是直接走的View-onTouchEvent"><a href="#而ViewGroup的onTouchEvent是直接走的View-onTouchEvent" class="headerlink" title="而ViewGroup的onTouchEvent是直接走的View.onTouchEvent()"></a>而ViewGroup的onTouchEvent是直接走的View.onTouchEvent()</h4><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><ul><li><p><strong>ViewGroup中dispatchTouchEvent()会把事件进行遍历传递</strong></p><p>遍历它自己的所有子View,然后调用child的dispatchTouchEvent()来分发触摸事件</p></li><li><p><strong>ViewGroup的某个子View没有接受ACTION_DOWN,则它再也不会被分发事件了</strong></p></li><li><p><strong>ViewGroup的onInterceptTouchEvent()默认返回false</strong></p><p>也就是说,如果你需要自定义的ViewGroup拦截事件,直接重写返回false即可</p></li><li><p><strong>ViewGroup的onTouchEvent 并没有自己的实现,直接调用其父类View的</strong></p></li></ul><p>下篇View走起</p>]]></content>
    
    
    <categories>
      
      <category>View</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Android</tag>
      
      <tag>View</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>贝塞尔曲线练习-谷歌猜画小歌的倒计时</title>
    <link href="undefined2018/07/27/Bezier-Google-caihuaxiaoge/"/>
    <url>2018/07/27/Bezier-Google-caihuaxiaoge/</url>
    
    <content type="html"><![CDATA[<p>总的来说一共有四段二阶贝塞尔曲线，其实我们是可以只用一次高阶贝塞尔曲线来搞定的，但是那样不是很划算，所以我用四段二阶曲线拼接为一个循环。</p><p>示意图：</p><p><img src="/images/wave_show.png" srcset="/img/loading.gif" alt="示意图"></p><p>图中大框表示手机屏幕，我们只要每次都移动S点的位置就可以做到模拟波浪。</p><a id="more"></a><p>那么需要确定</p><ol><li>宽度（D点位置）</li><li>波浪高度 （C 点，控制点的高度，它的宽度是不做变化的）</li><li>起始点的位置</li></ol><p>当我们开始移动时，只需要移动S点位置即可，其他点都调用quadTo ，lineTo 的API就可以直接相对位置的位移</p><p>实现效果图:</p><p><img src="/images/wave_image.gif" srcset="/img/loading.gif" alt=""></p><p>好了，既然道理已经明白了，那就开始代码把</p><h3 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h3><p>选择继承View实现，我们没有其他的控件需要协调，只要管好自己就OK,直接上View即可</p><p>本来构思的是做一个可以画多条波浪的View,但是试了一下,多条很难看…..而且我是为了练手,所以半途改了设计</p><h4 id="WaveView-java"><a href="#WaveView-java" class="headerlink" title="WaveView.java"></a>WaveView.java</h4><blockquote><p>WaveView主要负责初始化Wave.java实例,以及计算水面的高度其他都是具体交给了Wave.java做的</p></blockquote><p>onDraw的主要逻辑:</p><pre><code class="java">@Overrideprotected void onDraw(Canvas canvas) {    //这一步是画了一个圆角矩形,达到整个控件的圆角效果    //在super之前调用,除了背景,可以挡着所有的绘制    canvas.clipPath(radiusPath);     super.onDraw(canvas);    //为了实现最后时刻的抖动效果    matrix.setRotate(postRotate, 0.5F, 0.5F);//忽略,未实现    canvas.save();//忽略,未实现    canvas.concat(matrix);//忽略,未实现    //draw wave,这一步就是把两条波浪都画了出来,for循环所有的波浪,其实就2条    for (int i = waveList.length-1; i &gt;= 0; i--) {        waveList[i].drawWave(canvas);    }    canvas.restore();//忽略,未实现}</code></pre><p>水面高度动画:(其实这里没有设置动画的时长,因为这个是留给使用者来设置的)</p><pre><code class="java">/** * 设置水升起的动画 * @return ValueAnimator */private ValueAnimator getWaterRaiseAnim() {    //初始化动画    if (waterAnimator == null) {        //可以看到,我们的变化范围是 0F -  mHeight        waterAnimator = ValueAnimator.ofFloat(0F, mHeight);        waterAnimator.setInterpolator(new AccelerateInterpolator());        waterAnimator.addUpdateListener(animation -&gt; {            for (Wave wave : waveList) { //循环调用wave,告诉每一个实例,高度变化了                wave.updateHeight((float) animation.getAnimatedValue());            }        });    }    return waterAnimator;}</code></pre><p>两个startAnim,目的是用户不传递时间时,我们使用默认的20 * 1000毫秒</p><pre><code class="java">//开始动画public void startAnim() {    startAnim(DEFAULT_TIME);}/** * 开始动画 * @param time 时间单位 秒 */public void startAnim(long time) {    if (animatorSet != null) {        if (animatorSet.isRunning()) {            animatorSet.cancel();        }        animatorSet.start();    }else{        initAnim(time);        animatorSet.start();    }}//这里本来还添加了晃动的动画,注释掉的就是private void initAnim(long time) {    animatorSet = new AnimatorSet();    waterAnimator = getWaterRaiseAnim();    waterAnimator.setDuration(time);    animatorSet.play(waterAnimator);    //rotateAnim = getRotateAnim();    //animatorSet.play(rotateAnim).after(time / 5 * 4)}</code></pre><p>Wave.java</p><blockquote><p>主要负责绘制波浪,并自己调用动画达到波浪起伏效果</p></blockquote><p>绘制的方法:</p><pre><code class="java">     /**     * 当前这一条波浪的绘制     *     * @param canvas 画布     */    public void drawWave(Canvas canvas) {        //如果不是第一层,则不需要要画波浪下面的部分        drawWave(isTop());        canvas.drawPath(mPath, mPaint);    }        /**     * @param isNeed 是否需要绘制下面部分     */    private void drawWave(boolean isNeed) {        mPath.reset();        mPath.moveTo(mLeftTop.x, mLeftTop.y);        mPath.quadTo(mControlFirst.x, mControlFirst.y, mLeftMid.x, mLeftMid.y);        mPath.quadTo(mControlSecond.x, mControlSecond.y, mMid.x, mMid.y);        mPath.quadTo(mControlThree.x, mControlThree.y, mRightMid.x, mRightMid.y);        mPath.quadTo(mControlFour.x, mControlFour.y, mRightTop.x, mRightTop.y);        if (isNeed) {            mPath.lineTo(mRightBottom.x, mRightBottom.y);            mPath.lineTo(mLeftBottom.x, mLeftBottom.y);            mPath.lineTo(mLeftTop.x, mLeftTop.y);        } else {            mPath.lineTo(mRightTop.x, mRightTop.y + mWaveTrough);            mPath.lineTo(mLeftTop.x, mLeftTop.y + mWaveTrough);            mPath.lineTo(mLeftTop.x, mLeftTop.y);        }    }</code></pre><p>动画</p><pre><code class="java">    /**     * 初始化一个动画,并开启动画     */    public void startAnim() {        ValueAnimator valueAnimator;        if ((layerNum &amp; 1) == 0) {            //达到位移是从左向右的效果            valueAnimator = ValueAnimator.ofFloat(mLeftTop.x, 0);        } else {            //位移从右向左的移动            valueAnimator = ValueAnimator.ofFloat(mRightTop.x, mWidth);        }        valueAnimator.setInterpolator(new LinearInterpolator());        valueAnimator.setDuration(1000);        //无限的动画,一直播放,达成一个循环        valueAnimator.setRepeatCount(Animation.INFINITE);        valueAnimator.addUpdateListener(animation -&gt; {            float value = (float) animation.getAnimatedValue();            //交给next方法,具体的算出每一个点的下一个位置            next(value);        });        valueAnimator.start();    }</code></pre><p>next(float value)</p><pre><code class="java">    /**     * 变化后的数值     * @param value x方向的位移     */    private void next(float value) {        if ((layerNum &amp; 1) == 0) {            //这是向右移动            mLeftTop.set(value, mHeight - mWaterHeight);            mLeftMid.set(mLeftTop.x + mWidth / 2f, mHeight - mWaterHeight);            mMid.set(mLeftMid.x + mWidth / 2f, mHeight - mWaterHeight);            mRightMid.set(mMid.x + mWidth / 2f, mHeight - mWaterHeight);            mRightTop.set(mRightMid.x + mWidth / 2f, mHeight - mWaterHeight);            mControlFirst.set(mLeftTop.x + mWidth / 4f, mLeftTop.y + mWaveTrough);            mControlSecond.set(mLeftMid.x + mWidth / 4f, mLeftMid.y - mWavePeak);            mControlThree.set(mMid.x + mWidth / 4f, mMid.y + mWaveTrough);            mControlFour.set(mRightMid.x + mWidth / 4f, mRightMid.y - mWaveTrough);        } else {            //向左移动            mLeftTop.set(value, mHeight - mWaterHeight);            mLeftMid.set(mLeftTop.x - mWidth / 2f, mHeight - mWaterHeight);            mMid.set(mLeftMid.x - mWidth / 2f, mHeight - mWaterHeight);            mRightMid.set(mMid.x - mWidth / 2f, mHeight - mWaterHeight);            mRightTop.set(mRightMid.x - mWidth / 2f, mHeight - mWaterHeight);            mControlFirst.set(mLeftTop.x - mWidth / 4f, mLeftTop.y + mWaveTrough);            mControlSecond.set(mLeftMid.x - mWidth / 4f, mLeftMid.y - mWavePeak);            mControlThree.set(mMid.x - mWidth / 4f, mMid.y + mWaveTrough);            mControlFour.set(mRightMid.x - mWidth / 4f, mRightMid.y - mWaveTrough);        }        //这里我们只对第一个波浪设置了回调,所以必须要判断,不是空才能通知WaveView重绘        if (onRequestDraw != null) {            onRequestDraw.onDraw();        }    }</code></pre><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>定义一定要清楚,要不然会把自己混进去.</p><p>具体代码请到</p><blockquote><p> GIthub  :  <a href="https://github.com/wangzhumo/module_views" target="_blank" rel="noopener">https://github.com/wangzhumo/module_views</a></p></blockquote>]]></content>
    
    
    <categories>
      
      <category>View</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Android</tag>
      
      <tag>View</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Android开发xml中的样式</title>
    <link href="undefined2018/07/26/Android-xml-style/"/>
    <url>2018/07/26/Android-xml-style/</url>
    
    <content type="html"><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>我们在App中,很多时候需要一个统一的风格,样式.如TextView,EditText,Button,ProgressBar,CheckBox等等,都需要背景,阴影等.我们可以用UI设计师提供的切图,但是如果我们能使用Android提供的<code>shape、selector、layer-list、level-list、style、theme</code>等实现会更好.</p><p>下面做一个基本使用的笔记.</p><a id="more"></a><h3 id="Shape"><a href="#Shape" class="headerlink" title="Shape"></a>Shape</h3><p>shape定义的xml文件我们都是存放在drawable目录下，如果你的项目没有则新建一个.</p><p>使用shape可以通过android:shape属性指定下面四种类型的形状</p><ul><li><strong>rectangle</strong>: 矩形</li><li><strong>oval</strong>: 椭圆形</li><li><strong>line</strong>: 线形</li><li><strong>ring</strong>: 环形</li></ul><h4 id="基本属性"><a href="#基本属性" class="headerlink" title="基本属性"></a>基本属性</h4><ul><li><p><strong>corners</strong> 设置圆角,rectangle矩形的时候用</p><p>可以<code>radius</code>使用所有的圆角,也可以单独设置每一个圆角</p><ul><li>android:radius   四个圆角都会使用这个值</li><li><em>android:topLeftRadius</em> 左上角的半径</li><li><em>android:topRightRadius</em> 右上角的半径</li><li><em>android:bottomLeftRadius</em> 左下角的半径</li><li><em>android:bottomRightRadius</em> 右下角的半径</li></ul></li><li><p><strong>soid</strong>  设置填充色</p><ul><li>android:color  填充色</li></ul></li><li><p><strong>stroke</strong>  设置描边线条</p><ul><li><em>android:color</em> 描边线条颜色</li><li><em>android:width</em> 描边线条宽度</li><li><em>android:dashWidth</em> 设置线条为虚线时的横线长度</li><li><em>android:dashGap</em> 设置线条为虚线时的横线之间的间隔</li></ul></li><li><p><strong>padding</strong>  内容与边界的内间距</p><ul><li><em>android:left</em> 左内间距</li><li><em>android:right</em> 右内间距</li><li><em>android:top</em> 上内间距</li><li><em>android:bottom</em> 下内间距</li></ul></li><li><p><strong>gradient</strong>  这个属性可以给你的图形设置渐变</p><ul><li><p>android:type 渐变的类型   </p><ul><li>(第一次用方形,哈哈)  linear 线性渐变</li><li>sweep 扫描渐变</li><li>radial 放射渐变</li></ul></li><li><p>android:startColor 渐变开始的颜色</p></li><li><p>android:centerColor  渐变的中间色</p></li><li><p>android:endColor  渐变结束的颜色</p></li><li><p>android:angle 渐变的角度,当你设置线性渐变可用</p></li><li><p>android:centerX  渐变中心的X坐标,当你设置放射渐变有效</p></li><li><p>android:centerY   渐变中心的Y坐标 ,当你设置放射渐变有效</p></li><li><p>android:gradientRadius  渐变的半径,针对放射渐变</p></li></ul></li></ul><h5 id="rectangle"><a href="#rectangle" class="headerlink" title="rectangle"></a>rectangle</h5><p>同基本属性</p><h5 id="line"><a href="#line" class="headerlink" title="line"></a>line</h5><p>stroke &amp; size 组合实现,常用来做EditText的光标</p><h5 id="oval"><a href="#oval" class="headerlink" title="oval"></a>oval</h5><ul><li><strong>size</strong>   可以设置图形的宽,高<ul><li>android:width  宽度</li><li>android:height  高度</li></ul></li></ul><p>其他同基本属性</p><h5 id="ring"><a href="#ring" class="headerlink" title="ring"></a>ring</h5><ul><li><strong>android:innerRadius</strong>  里面圆的半径</li><li><strong>android:innerRadiusRatio</strong>  默认3,便是内圆半径是宽度/3 </li><li><strong>android:thickness</strong>   环的宽度</li><li><strong>android:thicknessRatio</strong>  默认是9,表示环的宽度是宽度/9</li></ul><pre><code class="xml-dtd">&lt;shape xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;    android:innerRadiusRatio=&quot;3&quot;    android:shape=&quot;ring&quot;    android:thicknessRatio=&quot;9&quot;    android:useLevel=&quot;false&quot;&gt;    &lt;gradient        android:endColor=&quot;@color/colorAccent&quot;        android:startColor=&quot;#FFFFFF&quot;        android:type=&quot;sweep&quot; /&gt;&lt;/shape&gt;</code></pre><p>图示:</p><p><img src="/images/shape_ring.png" srcset="/img/loading.gif" alt="ring"></p><h3 id="Selector"><a href="#Selector" class="headerlink" title="Selector"></a>Selector</h3><p>selector可以添加多个Item,表示不同的状态的不同资源.drawable &amp; color</p><p>要注意的:</p><ul><li><p>drawable的资源放在 drawable目录,并且指定的是 android:drawable</p></li><li><p>color 的放在color目录,并且指定 android:color </p></li></ul><p>那么下面我列举出所有的可以设置的状态</p><ul><li><strong>android:state_enabled</strong>: 设置触摸或点击事件是否可用状态</li><li><strong>android:state_pressed</strong>: 是否按压状态</li><li><strong>android:state_selected</strong>: 是否选中状态，true表示已选中，false表示未选中</li><li><strong>android:state_checked</strong>: 是否勾选状态</li><li><strong>android:state_checkable</strong>: 勾选是否可用状态</li><li><strong>android:state_focused</strong>: 是否获得焦点状态</li><li><strong>android:state_window_focused</strong>: 当前窗口是否获得焦点状态</li><li><strong>android:state_activated</strong>: 是否被激活状态</li><li><strong>android:state_hovered</strong>: 是在上面滑动的状态</li><li><strong>android:enterFadeDuration</strong>  状态改变时的淡入时间</li><li><strong>android:exitFadeDuration</strong> 状态改变时旧状态消失的淡出</li></ul><h3 id="layout-list"><a href="#layout-list" class="headerlink" title="layout-list"></a>layout-list</h3><p>layer-list的作用是把多个drawable按照顺序层叠在一起显示.</p><p>它既可以是根节点,也可以作为selector的Item存在.</p><p>我们可以使用layer-list的特性来做阴影效果.</p><pre><code class="xml-dtd">&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;&lt;layer-list xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;&gt;    &lt;item        android:left=&quot;4dp&quot;        android:top=&quot;4dp&quot;&gt;        &lt;shape&gt;            &lt;solid android:color=&quot;@android:color/darker_gray&quot; /&gt;            &lt;corners android:radius=&quot;10dp&quot; /&gt;        &lt;/shape&gt;    &lt;/item&gt;    &lt;item        android:bottom=&quot;4dp&quot;        android:right=&quot;4dp&quot;&gt;        &lt;shape&gt;            &lt;solid android:color=&quot;@android:color/white&quot; /&gt;            &lt;corners android:radius=&quot;10dp&quot; /&gt;        &lt;/shape&gt;    &lt;/item&gt;&lt;/layer-list&gt;</code></pre><p><img src="/images/layer_list.png" srcset="/img/loading.gif" alt="layer"></p><p>layer-list的item可以通过以下四个属性来设置偏移量：</p><ul><li>android:top 顶部偏移量</li><li>android:bottom 底部偏移量</li><li>android:left 左边偏移量</li><li>android:right 右边偏移量</li></ul><h3 id="level-list"><a href="#level-list" class="headerlink" title="level-list"></a>level-list</h3><p>level-list可以存放多张drawable,每一张drawable对应一定的level范围,使用时通过level值展示对应的drawable</p><p><strong>android:drawable</strong> 指定drawable资源</p><p><strong>android:minLevel</strong> 该Drawable的最小level值</p><p><strong>android:maxLevel</strong> 该Drawable的最大level值</p><pre><code class="xml-dtd">&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;&lt;level-list xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;&gt;    &lt;item        android:drawable=&quot;@drawable/draw1&quot;        android:maxLevel=&quot;50&quot;        android:minLevel=&quot;0&quot; /&gt;    &lt;item        android:drawable=&quot;@drawable/draw2&quot;        android:maxLevel=&quot;100&quot;        android:minLevel=&quot;50&quot; /&gt;&lt;/level-list&gt;</code></pre>]]></content>
    
    
    <categories>
      
      <category>View</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Android</tag>
      
      <tag>View</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Android Studio中使用CMake进行JNI开发</title>
    <link href="undefined2018/07/25/Android-Studio-CMake-JNI/"/>
    <url>2018/07/25/Android-Studio-CMake-JNI/</url>
    
    <content type="html"><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>定一个小目标,替代RenderScript来做一个图片的高斯模糊,因为这是一个比较考验性能的操作,所以我打算用C来做这个操作(主要原因是我自己不会写C++,刚好看到有这个开源算法…)</p><h3 id="创建项目"><a href="#创建项目" class="headerlink" title="创建项目"></a>创建项目</h3><blockquote><p>new -&gt; new Module -&gt; Android Library </p></blockquote><p>当项目创建好之后,这只是一个单纯的Library,并不能使用JNI开发</p><p>下面,我们把它改造一下(下图是改造完成的目录结构):</p><a id="more"></a><p><img src="/images/jni_folder.png" srcset="/img/loading.gif" alt="file"></p><h4 id="添加CMakeLists-txt"><a href="#添加CMakeLists-txt" class="headerlink" title="添加CMakeLists.txt"></a>添加CMakeLists.txt</h4><blockquote><p>选中lib_blur - new File - CMakeLists.txt</p></blockquote><pre><code class="java">cmake_minimum_required(VERSION 3.4.1)#设置生成的so动态库最后输出的路径#set(CMAKE_LIBRARY_OUTPUT_DIRECTORY ${PROJECT_SOURCE_DIR}/src/main/jniLibs/${ANDROID_ABI})add_library( # 库名             sample             # 该库生成动态函数             SHARED             # 依赖的文件             src/main/cpp/samplelib.cpp)find_library( # 设置Path变量的名称              log-lib              # 指定要查询的库名字              # 在ndk中查找 liblog.so 函数库              log )target_link_libraries( # 目标库                       sample                       # 要链接的库                       android                       # Links the target library to the log library                       # included in the NDK.                       ${log-lib} )</code></pre><h4 id="修改build-grade"><a href="#修改build-grade" class="headerlink" title="修改build.grade"></a>修改build.grade</h4><pre><code class="groovy">android {    defaultConfig {        //...        ndk {            // 设置支持的SO库架构            abiFilters &#39;armeabi-v7a&#39;, &#39;x86&#39;        }        externalNativeBuild {            cmake {                cppFlags &quot;-std=c++14&quot;, &quot;-frtti&quot;, &quot;-fexceptions&quot;            }        }        }    //...    externalNativeBuild {        cmake {            path &quot;CMakeLists.txt&quot;        }    }}</code></pre><h4 id="编写C-文件"><a href="#编写C-文件" class="headerlink" title="编写C++文件"></a>编写C++文件</h4><p>我们的C文件都在<code>src/main/cpp</code>文件夹下,每一个C文件都需要在<code>CMakeLists.txt</code>文件中指定</p><pre><code class="groovy"> # 依赖的文件 src/main/cpp/samplelib.cpp</code></pre><p>samplelib.cpp</p><pre><code class="c++">#include &lt;jni.h&gt;#include &lt;stdlib.h&gt;#include &lt;string&gt;#include &lt;android/log.h&gt;#define TAG    &quot;JNI_LOG&quot;#define LOGE(...)  __android_log_print(ANDROID_LOG_ERROR,TAG ,__VA_ARGS__)using namespace std;#ifdef __cplusplusextern &quot;C&quot; {#endif//定义我Java文件的位置,注意是&#39;/&#39;分开static const char *className = &quot;com/wangzhumo/app/commonlib/jni/JniManager&quot;;//返回一个stringjstring stringFromJNI(JNIEnv *env,jclass clz) {    std::string hello = &quot;Hello from C++&quot;;    return env-&gt;NewStringUTF(hello.c_str());}//返回一个string 并把这句话打印到logcat中去jstring sayHello(JNIEnv* env,jclass clz) {    std::string hello = &quot;Say Hello from C++&quot;;    LOGE(&quot;Say Hello and value&quot;);    return env-&gt;NewStringUTF(hello.c_str());}//获取所有方法名static JNINativeMethod gJniMethods[] = {        {&quot;sayHello&quot;, &quot;()Ljava/lang/String;&quot;, (void*)sayHello},        {&quot;stringFromJNI&quot;, &quot;()Ljava/lang/String;&quot;, (void*)stringFromJNI},};//其中{&quot;MethodName&quot;,&quot;(入参)返回值&quot;,()Method}//动态注册本地方法static int jniRegisterNativeMethods(JNIEnv* env, const char* className,                                    const JNINativeMethod* gMethods, int numMethods) {    jclass clazz;    clazz = (env)-&gt;FindClass( className);    if (clazz == NULL) {        return -1;    }    int result = 0;    if ((env)-&gt;RegisterNatives(clazz, gMethods, numMethods) &lt; 0) {        result = -1;    }    (env)-&gt;DeleteLocalRef(clazz);    return result;}//JNI_OnLoad回调JNIEXPORT jint JNICALL JNI_OnLoad(JavaVM* vm, void* reserved){    JNIEnv* env = NULL;    jint result = -1;    if (vm-&gt;GetEnv((void**) &amp;env, JNI_VERSION_1_6) != JNI_OK) {        return result;    }    jniRegisterNativeMethods(env, className, gJniMethods, sizeof(gJniMethods) / sizeof(JNINativeMethod));    return JNI_VERSION_1_6;}#ifdef __cplusplus}#endif</code></pre><h4 id="编写Java文件"><a href="#编写Java文件" class="headerlink" title="编写Java文件"></a>编写Java文件</h4><pre><code class="java">public class JniManager {    static{        System.loadLibrary(&quot;sample&quot;);    }    public static native String sayHello();    public static native String stringFromJNI();}</code></pre><h3 id="编译"><a href="#编译" class="headerlink" title="编译"></a>编译</h3><blockquote><p> Build -&gt; Make Project</p></blockquote><p>编译完成,如果成功则 build -&gt; intermediates -&gt; cmake  下就有 .so文件</p><p>如图所示:</p><p><img src="/images/jni_so_file.png" srcset="/img/loading.gif" alt="so"></p><p>我们可以看到,生成了 armeabi-v7a,  x86两种类型的.so文件,如果不在build.gradle中声明:</p><pre><code class="groovy">ndk {    // 设置支持的SO库架构    abiFilters &#39;armeabi-v7a&#39;, &#39;x86&#39;}</code></pre><h3 id="调用"><a href="#调用" class="headerlink" title="调用"></a>调用</h3><pre><code class="kotlin">class MainActivity : AppCompatActivity() {    override fun onCreate(savedInstanceState: Bundle?) {        super.onCreate(savedInstanceState)        setContentView(R.layout.activity_main)    }    override fun onResume() {        super.onResume()        Log.e(&quot;JNI&quot;,JniManager.sayHello())        Log.e(&quot;JNI&quot;,JniManager.stringFromJNI())    }}</code></pre><p>结果:</p><pre><code class="shell">07-26 17:42:41.420 6685-6685/com.wangzhumo.playground E/JNI_LOG: Say Hello and value07-26 17:42:41.420 6685-6685/com.wangzhumo.playground E/JNI: Say Hello from C++07-26 17:42:41.420 6685-6685/com.wangzhumo.playground E/JNI: Hello from C++</code></pre><p>其中<code>JNI_LOG</code>是由 cpp 中的方法打印到Android的控制台的</p><p><code>JNI</code>是我们在MainActivity中调用的</p><pre><code class="kotlin"> Log.e(&quot;JNI&quot;,JniManager.sayHello()) Log.e(&quot;JNI&quot;,JniManager.stringFromJNI())</code></pre><h3 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h3><p>以上说明我的JNI算是初步完成了调用</p><blockquote><p><a href="http://zhixinliu.com/2015/07/01/2015-07-01-jni-register/" target="_blank" rel="noopener">http://zhixinliu.com/2015/07/01/2015-07-01-jni-register/</a></p><p><a href="https://developer.android.com/ndk/guides/" target="_blank" rel="noopener">https://developer.android.com/ndk/guides/</a></p></blockquote><p>前言中的Flag真是立的好,C++不是很会,所以只能往简单了写,真是可怜的我</p>]]></content>
    
    
    <categories>
      
      <category>Android</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Android</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>数据结构-下笔记</title>
    <link href="undefined2018/07/22/Data-Structure-Note-1/"/>
    <url>2018/07/22/Data-Structure-Note-1/</url>
    
    <content type="html"><![CDATA[<p>算法</p><ul><li>输入,待处理的信息</li><li>输出,经处理的信息</li><li>正确性,的确可以解决问题</li><li>确定性,任意算法都可以描述为由基本操作(明确,精密的)组成的序列</li><li>可行性,每一基本操作都可以实现,并在常数时间内完成</li><li>有穷性,对任何输入,经有穷次基本操作,都可以得到输出</li></ul>]]></content>
    
    
    <categories>
      
      <category>Programme</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Programme</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>递归调用创建单链表</title>
    <link href="undefined2018/07/15/Recursion-Linked-List/"/>
    <url>2018/07/15/Recursion-Linked-List/</url>
    
    <content type="html"><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>很多的面试中,都有要求实现一个单链表,这里就搞一个试试.</p><a id="more"></a><h3 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h3><p>Node.kt</p><pre><code class="kotlin">//创建一个Nodeclass Node(val value:Int){    var next : Node? = null}</code></pre><ol><li>这个Node有一个<code>value</code>,它是一个必传且不可修改的参数,就直接放在了构造了</li><li><code>next</code>指向了下一个Node,这样就可以完成一个单向的链表,让我想起了 <code>Message</code>的next</li><li><code>next</code>默认是null,这是因为单链表最后一个<code>next</code>中就是null.</li></ol><p>ListCreated.kt</p><pre><code class="kotlin">class ListCreated {    fun createList(list: List&lt;Int&gt;): Node? {        //1.        if (list.isEmpty()) {            return null        }        //2.        val currentNode = Node(list[0])        println(&quot;before ${currentNode.value}&quot;)        //3.        val nextNode = createList(list.subList(1, list.size))        if (nextNode != null) {            println(&quot;after ${currentNode.value}&quot;)        }        //4.        currentNode.next = nextNode        return currentNode    }}class ListCreated {    fun createList(list: List&lt;Int&gt;): Node? {        //1.        if (list.isEmpty()) {            return null        }        //2.        val currentNode = Node(list[0])        println(&quot;before ${currentNode.value}&quot;)        //3.        val nextNode = createList(list.subList(1, list.size))        if (nextNode != null) {            println(&quot;after ${currentNode.value}&quot;)        }        //4.        currentNode.next = nextNode        return currentNode    }}</code></pre><ol><li>我们需要去判断List,如果为空就直接返回null了</li><li>这里就是当前的这个Node,保存了当前的value,但是next还是为null的</li><li>这里就是递归调用的地方,传入的参数是一个subList,当然是去掉了第一个,因为第一个已经是currentNode了</li><li>把currentNode的<code>next</code>指向了nextNode,构成单向</li></ol><p>MainTest.java</p><pre><code class="java">public class MainClass {    public static void main(String[] args){        List&lt;Integer&gt; integerList = Arrays.asList(1,4,6,2);        ListCreated created = new ListCreated();        Node node = created.createList(integerList);        printAll(node);    }    public static void printAll(Node node){        while (node != null){            System.out.print(node.getValue());            System.out.print(&quot; &quot;);            node = node.getNext();        }    }}</code></pre><p>打印结果:</p><pre><code>before 1before 4before 6before 2after 6after 4after 11 4 6 2</code></pre><p>我们可以清楚的知道before 1,4,6,2 而没有打印,说明压入了栈,指令没有返回</p><p>after本来应该是 2,6,4,1的,为什么2没有打印出来,是因为</p><pre><code class="java">if (nextNode != null) {     println(&quot;after ${currentNode.value}&quot;)}</code></pre><p>链表最后一个Node的<code>next</code>是为null的,所以没有打印</p><p>出栈的顺序,也是按照栈的规则,先进后出.</p><p><img src="/images/list_created.gif" srcset="/img/loading.gif" alt=""></p><p>可以看到出入栈的顺序</p>]]></content>
    
    
    <categories>
      
      <category>Java</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Java</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>设计模式-装饰者设计模式</title>
    <link href="undefined2018/07/14/Design-Pattern-Decoration/"/>
    <url>2018/07/14/Design-Pattern-Decoration/</url>
    
    <content type="html"><![CDATA[<h3 id="认识装饰者模式"><a href="#认识装饰者模式" class="headerlink" title="认识装饰者模式"></a>认识装饰者模式</h3><p>装饰者模式一般由一下几部分组成:</p><ul><li>Component：装饰者和被装饰者的共同父类,是一个接口或者抽象类,定义了基本行为</li><li>ConcreteComponent：具体的组件对象,实现了组件的接口,定义具体对象,通常就是被装饰者</li><li>Decorator：抽象装饰者,需要继承Component,它内部维护了一个指向Component实例的引用,对于ConcreteComponent来说,不需要知道Decorator的存在,就可以完成对ConcreteComponent的装饰</li><li>ConcreteDecorator：具体装饰者,来完成具体的装饰功能,扩展ConcreteComponent.</li></ul><a id="more"></a> <p>我们知道在编码中,倡导使用组合,而不是继承来扩展和复用功能,装饰者模式也是基于组合来完成的.装饰者模式可以很灵活的给对象添加功能,作为一个外部的类给对象添加功能,而不用直接修改对象本身,或者创建子类.</p><h3 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h3><p>那我们就按照上面的结构,一一来创建</p><p>就拿我下班后要干的事说起吧,每天下班我回家必须要背一会单词,这个是我的基本任务</p><p>可选的任务:</p><p>Coding   看书  看电视  玩手机</p><h4 id="Component"><a href="#Component" class="headerlink" title="Component"></a>Component</h4><pre><code class="kotlin">abstract class HomeWork{    //完成了作业    open fun doWork() : String {        return &quot;下班后任务&quot;    }    //完成作业花费时间    abstract fun costTime() : Int}</code></pre><p>可以看到,我下班后的任务,定义了一个任务,一个耗费时间</p><p>这个Component可以是接口,也可以是抽象类,根据自己的需要来定就行</p><h4 id="ConcreteComponent"><a href="#ConcreteComponent" class="headerlink" title="ConcreteComponent"></a>ConcreteComponent</h4><pre><code class="kotlin">class BaseWork : HomeWork(){    override fun doWork(): String {        return &quot;背单词&quot;    }    override fun costTime() : Int {        return 30    }}</code></pre><h4 id="Decorator"><a href="#Decorator" class="headerlink" title="Decorator"></a>Decorator</h4><pre><code class="kotlin">abstract class Decorator : HomeWork(){    abstract override fun costTime(): Int}</code></pre><h4 id="ConcreteDecorator"><a href="#ConcreteDecorator" class="headerlink" title="ConcreteDecorator"></a>ConcreteDecorator</h4><pre><code class="kotlin">class ProgrammeWork(private val work : HomeWork) : Decorator(){    override fun doWork(): String {        return work.doWork() + &quot;  Coding&quot;    }    override fun costTime(): Int {        return work.costTime() + 45    }}class TelevisionWork(private val work: HomeWork) : Decorator(){    override fun doWork(): String {        return work.doWork() + &quot;  看电视&quot;    }    override fun costTime(): Int {        return work.costTime() + 60    }}</code></pre><h3 id="执行结果"><a href="#执行结果" class="headerlink" title="执行结果"></a>执行结果</h3><pre><code class="java">public static void main(String[] args){        BaseWork work = new BaseWork();        System.out.println(work.doWork() +                String.format(&quot;  耗费时间 : %d 分钟&quot;, work.costTime()));        //如果说我心情好还学了一会代码        ProgrammeWork programmeWork = new ProgrammeWork(work);        System.out.println(programmeWork.doWork() +                String.format(&quot;  耗费时间 : %d 分钟&quot;, programmeWork.costTime()));        //本来想睡了,但是媳妇看的电视特好看,我又去看了电视        TelevisionWork tvWork = new TelevisionWork(programmeWork);        System.out.println(tvWork.doWork() +                String.format(&quot;  耗费时间 : %d 分钟&quot;, tvWork.costTime()));}//Run:背单词  耗费时间 : 30 分钟背单词  Coding  耗费时间 : 75 分钟背单词  Coding  看电视  耗费时间 : 135 分钟Process finished with exit code 0</code></pre><p>其实我觉得装饰者和代理模式很像,像到我想不到有什么本质的差异,可能是我自己没有深刻的理解这两个设计模式,所以我希望下次有机会能搞明白.</p><blockquote><p><a href="https://blog.csdn.net/yeguxin/article/details/77337649" target="_blank" rel="noopener">https://blog.csdn.net/yeguxin/article/details/77337649</a></p></blockquote><p>这里是我现在觉得讲的有点道理的.</p>]]></content>
    
    
    <categories>
      
      <category>Java</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Java</tag>
      
      <tag>设计模式</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>设计模式-状态模式的使用</title>
    <link href="undefined2018/07/14/Design-pattern-State/"/>
    <url>2018/07/14/Design-pattern-State/</url>
    
    <content type="html"><![CDATA[<h3 id="状态模式-State"><a href="#状态模式-State" class="headerlink" title="状态模式(State)"></a>状态模式(State)</h3><h4 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h4><p>允许一个对象在其内部状态改变时改变它的行为,对象看起来似乎修改了它的类,状态模式是一种对象行为型模式。</p><p>那么我们在编码的过程中,有什么地方会遇到这样的状况那?</p><a id="more"></a><h4 id="组成"><a href="#组成" class="headerlink" title="组成"></a>组成</h4><p>环境类(Context) :  它内部维护一个State子类的实例,这个实例定义的是当前状态.</p><p>抽象状态类(State) : 定义一个接口,其中封装Context的一个特定状态的相关行为.</p><p>具体状态类(ConcreteState): 实现一个与Context的一个状态相关的行为.</p><h4 id="使用情况"><a href="#使用情况" class="headerlink" title="使用情况"></a>使用情况</h4><ol><li>如果一个对象,它的行为完全取决于它的某一种状态,而且这个状态是动态变化的.</li><li>代码中包含大量与对象状态有关的条件语句</li></ol><h3 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h3><p>现在有这么一个需求,用户分为不同的等级,每个等级所进行的操作是不一样的.</p><p>State</p><pre><code class="kotlin">interface UserState{  //接收一个价格,再返回一个处理后的价格    fun pay (level:Double) : Double}</code></pre><p>ConcreteState</p><pre><code class="kotlin">class NormalState :UserState{    override fun pay(level: Double): Double {        val result = level * 1.0        println(&quot;${javaClass.simpleName} 需要支付 : $result&quot;)        return result    }}class BossState : UserState{    override fun pay(level: Double): Double {        val result = 0        println(&quot;${javaClass.simpleName} 需要支付 : $result&quot;)        return 0.0    }}class VIPState : UserState{    override fun pay(level: Double): Double {        //会员95%        val result = level * 0.95        println(&quot;${javaClass.simpleName} 需要支付 : $result&quot;)        return result    }}</code></pre><p>Context</p><pre><code class="kotlin">class UserContext{    //保存状态    private var mState : UserState = NormalState()    fun setUser(state: UserState){        this.mState = state    }    fun pay(price:Double){        mState.pay(price)    }}</code></pre><h4 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h4><pre><code class="java">public class MainClass {    public static void main(String[] args){        UserContext userContext  = new UserContext();        userContext.pay(1000);        userContext.setUser(new VIPState());        userContext.pay(1000);        userContext.setUser(new BossState());        userContext.pay(1000);    }}//result:NormalState 需要支付 : 1000.0VIPState 需要支付 : 950.0BossState 需要支付 : 0Process finished with exit code 0</code></pre><h3 id="StateMachine复杂的状态机"><a href="#StateMachine复杂的状态机" class="headerlink" title="StateMachine复杂的状态机"></a>StateMachine复杂的状态机</h3><p>看着是没啥用的东西,明明可以用if else 搞定的,为什么一定要使用设计模式,而且还多了好几个类</p><p>只是我这里写的例子太简单,但还是把state 和 行为拉了出来,如果后面要加状态再添加实现类即可</p><p>BUT这只是最简单的实现,我们可以看看系统中有什么高级的东西</p><p><code>com/android/internal/util/StateMachine.java</code></p><p>当我看到这个类,我一下就明白为什么要用状态模式</p><p>我们现在的结构,非常简单,确实可以被if else替换,只是不那么优雅</p><p><img src="/images/state_simple.png" srcset="/img/loading.gif" alt=""></p><p>但是如果,你的State是这样的那?</p><p><img src="/images/state_level.png" srcset="/img/loading.gif" alt=""></p><p>你还可以用if - else么?这时候给你加一个state,不说改代码,起码要理一会才行</p><h4 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h4><pre><code class="java">SmHandle sm;//添加状态sm.addState(S0,null);//S1 S2添加为S0的子类sm.addState(S1,S0);sm.addState(S2,S0);//S3 S3添加为S1的子类sm.addState(S3,S1);sm.addState(S4,S1);//S5 S6 S7添加为S2的子类sm.addState(S5,S2);sm.addState(S6,S2);sm.addState(S7,S2);//设置初始状态setInitialState(S4);</code></pre><p>这样会构造成</p><p><img src="/images/state_demo.png" srcset="/img/loading.gif" alt=""></p>]]></content>
    
    
    <categories>
      
      <category>Java</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Java</tag>
      
      <tag>设计模式</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>RecyclerView中notifyItemRangeChanged无效的BUG</title>
    <link href="undefined2018/07/13/RecyclerView-unuseful-notifyItemRangeChanged/"/>
    <url>2018/07/13/RecyclerView-unuseful-notifyItemRangeChanged/</url>
    
    <content type="html"><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>RecyclerView是我们日常开发中用的最频繁的几个控件之一,可以说一个App没有RecyclerView的参与,可能根本就做不出来.然而同时,RecyclerView尽管有复用机制,我们使用的时候,还是应该尽量的节省内存,提高性能.</p><p>所以,对于RecyclerView中的Item,尽量少刷新,越少越好.</p><a id="more"></a><p><code>notifyItemRangeChanged</code>是主要的一个方法,其他的<code>notifyItemChanged</code>等几个不同入参的方法,其实最后都是调用notifyItemRangeChanged:</p><pre><code class="java">android.support.v7.widget.RecyclerView.Adapter#notifyItemRangeChanged(int positionStart, int itemCount, @Nullable Object payload)</code></pre><p>我们可以看到它的几个参数</p><blockquote><p>positionStart   开始的位置</p><p>itemCount       需要刷新几个Item</p><p>payload            这个参数比较重要,如果它为null,则回调中会刷新整个View而不是局部刷新</p></blockquote><p>好了,我们来说说这个BUG</p><p><img src="/images/yhcs_zan.png" srcset="/img/loading.gif" alt=""></p><p>看到赞,评论两个字段了么?  现在的需求是要加一个阅读量的,如图中的红色字</p><p>这个阅读量本地先做一个点击就加一的东西,而不去请求网络来刷新.</p><p>其实怎么刷这个赞都行,我们都需要先提供一个修改这一个   阅读量View  的功能</p><p>所以我理所当然的用<code>notifyItemRangeChanged</code>来做了一遍.</p><h3 id="BUG再现"><a href="#BUG再现" class="headerlink" title="BUG再现"></a>BUG再现</h3><p>当我信心满满的把这个运行到真机上测试的时候,我是拒绝的,这个阅读量的数字,一直保持0</p><p>一动也不动,于是我就开始了一步步的排除之旅.屋漏偏逢连夜雨,我的数据线好像有点接触不良,只得开启了WIFI ADB用来调试App,但是这就意味着我不能 debug了,那么我只能使出 Log 大法.</p><p>先贴上我当时的代码:</p><pre><code class="java">    @Override    protected void onBindViewHolder(@NonNull ViewHolder holder, @NonNull MediaItem item, @NonNull List&lt;Object&gt; payloads) {        Log.d(&quot;Adapter&quot;,&quot;onBindViewHolder&quot; + payloads.isEmpty());        if (payloads.isEmpty()){            onBindViewHolder(holder, item);        }else{            holder.mTvPvNum.setText(payloads.get(0).toString());        }    }    @Override    protected void onBindViewHolder(@NonNull ViewHolder holder, @NonNull MediaItem item) {        holder.mTvMediaAuthor.setText(item.getSourceName());        holder.mTvMediaTime.setText(DateFormatUtil.getDataStringForNews(item.getPublishTimeBO()));        //   省略其他不相关代码...        holder.itemView.setOnClickListener(v -&gt; {            if (onNewsClickListener != null) {                Log.d(&quot;Adapter&quot;,&quot;onBindViewHolder&quot; + item.getFormatPvNum());               getAdapter().notifyItemChanged(holder.getAdapterPosition(),item.addPvNum().getFormatPvNum());                onNewsClickListener.onArticleClick(item);            }        });    }</code></pre><h4 id="使用notifyItemChanged"><a href="#使用notifyItemChanged" class="headerlink" title="使用notifyItemChanged"></a>使用notifyItemChanged</h4><ol><li>调用<code>notifyItemXXX</code>系列方法</li><li>在<code>onBindViewHolder(ViewHolder,MediaItem item,List&lt;Object&gt; payloads)</code>方法中判断<code>List&lt;Object&gt; payloads</code>的值<ul><li>如果payloads值为空,则刷新全部,我这里直接调用了<code>onBindViewHolder(holder, item);</code>来进行整个Item的更新</li><li>如果payloads的值不为空,则进行局部更新即可</li></ul></li></ol><h4 id="预期效果"><a href="#预期效果" class="headerlink" title="预期效果"></a>预期效果</h4><p>在点击整个Item时调用之前准备的回调方法,并且</p><pre><code class="java">getAdapter().notifyItemChanged(postion,item.addPvNum().getFormatPvNum());</code></pre><p>那么对应postion位置的Item应该会刷新它的  <strong>阅读量</strong> </p><h4 id="BUG发生原因探索"><a href="#BUG发生原因探索" class="headerlink" title="BUG发生原因探索"></a>BUG发生原因探索</h4><h5 id="已知条件-通过Log可知"><a href="#已知条件-通过Log可知" class="headerlink" title="已知条件(通过Log可知)"></a>已知条件(通过Log可知)</h5><ol><li>调用<code>notifyItemChanged</code>成功了</li><li><code>onBindViewHolder(ViewHolder, item,List&lt;Object&gt; payloads)</code>方法没有被成功调起</li></ol><h5 id="推测原因"><a href="#推测原因" class="headerlink" title="推测原因"></a>推测原因</h5><p>如果说我当前的这个Adapter确实调用了<code>notifyItemChanged</code>,并且参数无误,但是却无法拉起回调</p><p>只能是回调方法没有被调起,我记起来了一些当时看过的RecyclerView源码</p><p>慢慢说起:</p><pre><code class="java">public void setAdapter(Adapter adapter) {        // bail out if layout is frozen        setLayoutFrozen(false);        setAdapterInternal(adapter, false, true);        processDataSetCompletelyChanged(false);        requestLayout();    }</code></pre><p>RecyclerView中的<code>setAdapter</code>,我们只需要关注其中的<code>setAdapterInternal(adapter, false, true);</code></p><p>暂时不用去了解其他几个方法,这4个方法中只有这一个方法参数中带了<code>adapter</code>,说明就是这个方法把RecyclerView和Adapter关联了起来.</p><pre><code class="java">private void setAdapterInternal(Adapter adapter, boolean compatibleWithPrevious,            boolean removeAndRecycleViews) {        if (mAdapter != null) {            mAdapter.unregisterAdapterDataObserver(mObserver);            mAdapter.onDetachedFromRecyclerView(this);        }        if (!compatibleWithPrevious || removeAndRecycleViews) {            removeAndRecycleViews();        }        mAdapterHelper.reset();        final Adapter oldAdapter = mAdapter;        mAdapter = adapter;        if (adapter != null) {            adapter.registerAdapterDataObserver(mObserver);            adapter.onAttachedToRecyclerView(this);        }        if (mLayout != null) {            mLayout.onAdapterChanged(oldAdapter, mAdapter);        }        mRecycler.onAdapterChanged(oldAdapter, mAdapter, compatibleWithPrevious);        mState.mStructureChanged = true;}</code></pre><p>看起来,是把老的Adapter清除,并设置传入的adapter为Adapter的值</p><pre><code class="java">if (adapter != null) {      adapter.registerAdapterDataObserver(mObserver);      adapter.onAttachedToRecyclerView(this);}</code></pre><p>重点在这句话<code>adapter.registerAdapterDataObserver(mObserver);</code></p><p>很明显,这是对数据变化注册成为一个观察者,查看源码发现最后是放到了 <code>mObservable</code> 中</p><p>大概已经知道是怎么回事了,可能我们当前的Adapter没有注册上观察者,所以没有回调过来吧.</p><p>为了证实我的猜测,我借了同事的测试机和线</p><h5 id="证实猜想"><a href="#证实猜想" class="headerlink" title="证实猜想"></a>证实猜想</h5><p>开启DEBUG一步一步跟过来.</p><pre><code>android.support.v7.widget.RecyclerView.AdapterDataObserver#onItemRangeChanged(int, int)</code></pre><p>最后,跑到了这里来.一个真真正正的空方法</p><p>于是查看了一下<code>mObservable</code>,只有一个值<code>RefreshAndLoadMoreHelper</code>,而我自己的Adapter明明是叫做<code>MultiTypeAdapter</code></p><p>看到这里,我的猜想已经证实,<code>RefreshAndLoadMoreHelper</code>是我自己封装,用来支持上拉加载,下拉刷新的工具类,其实它自己也继承了RecyclerView.Adapter,并且在<code>RefreshAndLoadMoreHelper</code>的构造方法中,调用了</p><p><code>recyclerView.setAdapter(mHeaderFooterAdapter);</code>,这就是说,我自己设置的Adapter永远会被它覆盖.</p><h3 id="解决BUG"><a href="#解决BUG" class="headerlink" title="解决BUG"></a>解决BUG</h3><p>已经知道了原因,是由于我自己的工具类,替代了本来设置的Adapter,,现在的<code>mHeaderFooterAdapter</code>是与当前RecyclerView关联的,但是我们在代码中</p><p>调用的是(开头的代码):</p><pre><code class="java">getAdapter().notifyItemChanged(holder.getAdapterPosition(),item.addPvNum().getFormatPvNum());</code></pre><p>getAdapter()返回的是Adapter而不是关联RecyclerView的<code>mHeaderFooterAdapter</code></p><p>所以,我们只要想办法,在Adapter中调用了方法后,通知<code>mHeaderFooterAdapter</code>一声,让它去完成操作即可</p><p><strong>代码如下:</strong></p><pre><code class="java">Adapter.registerAdapterDataObserver(new RecyclerView.AdapterDataObserver() {            @Override            public void onChanged() {                mHeaderFooterAdapter.notifyDataSetChanged();            }            @Override            public void onItemRangeChanged(int positionStart, int itemCount, @Nullable Object payload) {                mHeaderFooterAdapter.notifyItemRangeChanged(positionStart, itemCount, payload);            }        });</code></pre><p><code>Adapter</code>是我自己原来设置的</p><p><code>mHeaderFooterAdapter</code>是工具类</p><p>这里面的意思就是,给我自己的Adapter注册了一个观察者,每当我在Adapter中调用了方法,就会回调这里,在这里本来是通知RecyclerView来处理的,但是我们并不需要直接来处理,委托给<code>mHeaderFooterAdapter</code>即可,所以我在回调中直接调用了,<code>mHeaderFooterAdapter.notifyItemRangeChanged</code>这样就OK了.</p>]]></content>
    
    
    <categories>
      
      <category>Bug</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Android</tag>
      
      <tag>Bug</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>ConstraintLayout使用指南-基础的约束</title>
    <link href="undefined2018/07/12/ConstraintLayout-Basic/"/>
    <url>2018/07/12/ConstraintLayout-Basic/</url>
    
    <content type="html"><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>ConstraintLayout现在已经是新建布局的默认跟布局了,况且确实好用,有必要学习一波</p><p> <a href="https://developer.android.google.cn/reference/android/support/constraint/ConstraintLayout#Chains" target="_blank" rel="noopener">ConstraintLayout</a>,来自官网的文档,觉得不是很直观,于是我想把它做成GIF图</p><pre><code class="java">compile &#39;com.android.support.constraint:constraint-layout:1.1.2&#39;</code></pre><p>截止我写下这篇笔记的时候,已经是1.1.2版本了,下面所有的代码都是基于1.1.2版本.</p><a id="more"></a><h3 id="面板"><a href="#面板" class="headerlink" title="面板"></a>面板</h3><p><img src="/images/cons_broad.png" srcset="/img/loading.gif" alt="面板"></p><p>首先应该明白主要的两个面板</p><p>蓝色的区域,我们成为设计蓝图,下文称蓝图面板</p><p>右边的是属性面板,下文称属性面板,可以在这里进行精细调整</p><h3 id="单个控件的约束"><a href="#单个控件的约束" class="headerlink" title="单个控件的约束"></a>单个控件的约束</h3><p>再演示之前,建议大家都使用Android Studio 提供的<code>Design</code> 模式来创建和修改约束布局,方便而且直观</p><p>我的Android Studio 版本是3.1.3,如果有和我操作界面不一致的,请自行对应</p><h4 id="margin效果"><a href="#margin效果" class="headerlink" title="margin效果"></a>margin效果</h4><p><img src="/images/cons_default_move.gif" srcset="/img/loading.gif" alt="single_move"></p><p>如果我只给左边和上边加上约束,那么就会是<code>margin</code>的效果,代码表现如下:</p><pre><code class="xml"> &lt;Button        android:id=&quot;@+id/button&quot;        android:layout_width=&quot;wrap_content&quot;        android:text=&quot;Button&quot;        android:layout_height=&quot;wrap_content&quot;        android:layout_marginStart=&quot;28dp&quot;        android:layout_marginTop=&quot;28dp&quot;        app:layout_constraintStart_toStartOf=&quot;parent&quot;        app:layout_constraintTop_toTopOf=&quot;parent&quot; /&gt;</code></pre><p>如果你想调节这个<code>margin</code>,即可以拖动,也可以去属性面板调整,也可以在代码中修改</p><h4 id="居中-偏移效果"><a href="#居中-偏移效果" class="headerlink" title="居中/偏移效果"></a>居中/偏移效果</h4><p><img src="/images/cons_single_center.gif" srcset="/img/loading.gif" alt="弹性"></p><p>可以看到,我在左边和上边已经有<code>margin</code>的情况下,给右边和下边也加上了约束,现在<code>BUTTON</code>大体上是居中效果</p><p>为什么是”大体”居中那? 看箭头附近的 28 28 8 8 ,这是在<code>margin</code>的基础上居中的,去掉<code>margin</code>就是绝对居中的了</p><p>现在我们看属性面板:</p><p><img src="/images/cons_attr_2.png" srcset="/img/loading.gif" alt=""></p><p>略小的红框中,就是margin,这样的调节框还有3个</p><p>看到那个可以滑动的轴了么? 中间还有个50的数字,这个是调节<code>BUTTON</code>在垂直方向的偏移</p><p>其他几个操作框同理可推其作用</p><p>比如我需要一个<code>登录</code>在垂直方向的0.75处,也就是在整个页面的3/4处</p><p>可以直接拉动这个控制点,使他的数值变为<code>75</code>,也可以在代码中修改,代码表现如下:</p><pre><code class="xml">    &lt;Button        android:id=&quot;@+id/button&quot;        android:layout_width=&quot;wrap_content&quot;        android:layout_height=&quot;wrap_content&quot;        android:text=&quot;登录&quot;        app:layout_constraintBottom_toBottomOf=&quot;parent&quot;        app:layout_constraintEnd_toEndOf=&quot;parent&quot;        app:layout_constraintStart_toStartOf=&quot;parent&quot;        app:layout_constraintTop_toTopOf=&quot;parent&quot;        app:layout_constraintVertical_bias=&quot;0.75&quot; /&gt;</code></pre><p>此时的<code>BUTTON</code>就会处在整个布局的3/4处,就不放图了</p><h4 id="纵横比"><a href="#纵横比" class="headerlink" title="纵横比"></a>纵横比</h4><p><img src="/images/cons_ratio.gif" srcset="/img/loading.gif" alt="纵横比"></p><p>代码表现如下:</p><pre><code class="xml">    &lt;ImageView        android:layout_width=&quot;0dp&quot;        android:layout_height=&quot;0dp&quot;        android:src=&quot;@mipmap/login_bg&quot;        android:scaleType=&quot;fitXY&quot;        app:layout_constraintDimensionRatio=&quot;h,16:9&quot;        app:layout_constraintEnd_toEndOf=&quot;parent&quot;        app:layout_constraintStart_toStartOf=&quot;parent&quot;        app:layout_constraintTop_toTopOf=&quot;parent&quot; /&gt;</code></pre><h3 id="多个控件的约束"><a href="#多个控件的约束" class="headerlink" title="多个控件的约束"></a>多个控件的约束</h3>]]></content>
    
    
    <categories>
      
      <category>Android</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Android</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>JVM的垃圾回收Garbage Collection</title>
    <link href="undefined2018/07/11/JVM-Garbage-Collection/"/>
    <url>2018/07/11/JVM-Garbage-Collection/</url>
    
    <content type="html"><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>我们知道在线程创建时,程序计数器,本地方法栈,虚拟机栈随之创建,线程销毁时随之销毁</p><p>并且栈中的栈帧也随着方法的进入与退出执行出入栈操作,最重要的是每一个栈帧消耗的内存基本上在类结构确定时就已经知道,这几个区域的内存分配与回收都是确定的,不需要过多考虑回收.</p><p>但是进程中的 堆(heap) 以及 方法区与上面的几个栈是不同的,当程序处于运行时期才能确定,它们的内存分配与回收都是动态的.</p><p>垃圾收集主要就是这部分.</p><a id="more"></a><h3 id="内存中对象引用状态"><a href="#内存中对象引用状态" class="headerlink" title="内存中对象引用状态"></a>内存中对象引用状态</h3><p>要进行垃圾收集,第一件要确定的就是这个对象是否不被任何方式引用,当确定没有任何引用就可以进行回收.</p><p><strong>引用</strong>：要说引用状态就要明白什么是引用，如果Reference类型的数据中存储的数值代表的是另外一块内存的起始地址，我们就说这块内存代表着一个引用。</p><p>在JDK1.2之后,JAVA对引用的概念进行了扩充,将引用分外4种</p><ol><li>强引用, val onj = Object() </li><li>软引用 ,有用但是非必须的对象</li><li>弱引用,用来描述非必须对象</li><li>虚引用</li></ol><p>那么如何判断呢?</p><h4 id="引用计数法"><a href="#引用计数法" class="headerlink" title="引用计数法"></a>引用计数法</h4><p>即对象有一个引用计数器,每被引用一次就加1,引用释放就减去1,如果计数器为0,那就说明对象”已死”</p><p>但是Java虚拟机并没有采用这种方式,因为没有办法解决循环引用的问题</p><p>A与B对象,互相持有对方的引用,那么就算他们两个计数器永远不可能等于0,哪怕这两个对象都没有用了.</p><h4 id="可达性分析算法"><a href="#可达性分析算法" class="headerlink" title="可达性分析算法"></a>可达性分析算法</h4><p>JVM就是通过这种方式来判断对象是否存活.</p><p>这种算法,就是通过一系列的GC Roots对象作为起始点,从这些节点向下搜索,搜索走过的路径被称为引用链(Reference Chain),当一个对象到GC Roots没有任何引用链相连接的话,就可以判断这个对象不可用了.</p><p>GC Roots：</p><ul><li>虚拟机栈（栈帧中的本地变量表）中的引用对象</li><li>方法区中类静态属性引用变量</li><li>方法区中常量引用对象</li><li>本地方法栈中的JNI引用对象</li></ul><p><img src="/images/jvm_gcroots.png" srcset="/img/loading.gif" alt="gcroots"></p><h3 id="回收对象"><a href="#回收对象" class="headerlink" title="回收对象"></a>回收对象</h3><p>通过上面的可达性分析算法,我们就可以判断出那些可回收的对象,但是实际上他们也不是立即被回收</p><p>第一次不可达,没有与GC Roots相连接的引用链,他会被标记一次并且进行一次筛选,筛选是否有必要执行<code>finalize()</code>方法,当对象没有覆盖<code>finalize()</code>或者是该方法已经被虚拟机调用,都将视为”没有必要执行”.</p><p>如果一个对象被判定需要执行<code>finalize()</code>方法,那么这个对象会被放在<code>F-Queue</code>的队列中,并在稍后由虚拟机创建一个低优先级的<code>Finalizer</code>线程去执行它,稍后GC将会对<code>F-Queue</code>中的对象进行第二次筛选,如果该对象重新被引用了,那么它将被移出<code>F-Queue</code>队列,完成自救.否则,就真的被回收了.</p><h3 id="垃圾收集算法"><a href="#垃圾收集算法" class="headerlink" title="垃圾收集算法"></a>垃圾收集算法</h3><h4 id="标记-清除算法"><a href="#标记-清除算法" class="headerlink" title="标记-清除算法"></a>标记-清除算法</h4><p>这个算法分为两个部分,首先标记出所有需要回收的对象，在标记完成后统一回收所有被标记的对象    </p><p>这样的算法虽然可以达到目的,但是效率不高,而且标记-清除后会产生大量的不连续内存碎片,这会导致较大的对象分配内存时无法找到符合的内存块,导致提前触发另一次垃圾回收.</p><h4 id="复制算法"><a href="#复制算法" class="headerlink" title="复制算法"></a>复制算法</h4><p>这种算法的思路是,把一大块内存分为两个部分,A部分正常使用,当A块内存使用完,就把A内存中还存活的对象复制到另一块内存上去,然后一次性清理掉A上所有的内容.</p><p>这样的算法,简单而且高效,而且不会有大量不连续内存的问题产生,但是这样的话,永远只能使用到内存的一半空间,未免有些浪费了.</p><p>IBM通过研究,将内存分为一块较大的Eden空间和两块较小的Survivor空间,8:1:1 </p><h4 id="标记-整理算法"><a href="#标记-整理算法" class="headerlink" title="标记-整理算法"></a>标记-整理算法</h4><p>标记过程 仍然与上面说的“标记-清除”算法一样,但是后续不是直接执行清理,而是把可回收对象都向一端移动,然后直接清理掉端边界以外的内存.</p><h4 id="分代回收算法"><a href="#分代回收算法" class="headerlink" title="分代回收算法"></a>分代回收算法</h4><p>一般是把Java堆 分为新生代和老年代，这样就可以根据各个年代的特点采用最适当的收集算法。</p><p><strong>新生代</strong>:只有少量存活,就选用复制算法,付出少量存活对象的复制成本就可以完成收集</p><p><strong>老年代</strong>:对象存活率高,没有额外空间对它进行分配担保,就要使用“标记—清理”或者“标记—整理”算法来进行回收</p><h3 id="安全点-GC入口"><a href="#安全点-GC入口" class="headerlink" title="安全点(GC入口)"></a>安全点(GC入口)</h3><p>我们都知道GC是阻塞所有线程的,”Stop The  World”这样的.</p><p>程序执行时并非在所有地方都 能停顿下来开始GC,只有在到达安全点时才能暂停 . </p><p>至于对安全点的选定,也是很复杂,这里就不了解了.</p><p><strong>抢先式中断</strong>:GC发生时,把所有线程全部中断,如果有发现线程断的地方不在安全点上,就恢复线程,直到它继续执行指令到达”安全点”.</p><p><strong>主动式中断</strong>:GC需要中断时,设置标识,而每一个线程执行时主动轮询这个标志,发现中断标识就自己主动挂起.</p>]]></content>
    
    
    <categories>
      
      <category>Java</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Java</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Android中的贝塞尔曲线</title>
    <link href="undefined2018/07/05/Android-Bezier/"/>
    <url>2018/07/05/Android-Bezier/</url>
    
    <content type="html"><![CDATA[<h3 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h3><p>贝塞尔曲线(Bézier curve)</p><p>我们在很多App种都能发现它的影子,比如说</p><pre><code>QQ的小红点下拉刷新的粘连效果个人动态等页面的波浪效果阅读软件的翻页效果</code></pre><p>贝塞尔曲线是用一系列点来控制曲线状态，主要就是：数据点、控制点。我们可以通过调整控制点，来使得贝塞尔曲线形状变化</p><ul><li>数据点   指定了起始位置</li><li>控制点   一或多个,决定了曲线的轨迹</li></ul><a id="more"></a><p>这里放两个在线查看贝塞尔曲线的链接</p><blockquote><p><a href="http://myst729.github.io/bezier-curve/" target="_blank" rel="noopener">http://myst729.github.io/bezier-curve/</a></p><p><a href="http://cubic-bezier.com/#.17,.67,.83,.67" target="_blank" rel="noopener">http://cubic-bezier.com/#.17,.67,.83,.67</a></p></blockquote><p>这里是一个快速确定点位置的教程</p><blockquote><p><a href="https://www.jianshu.com/p/1d766455445b" target="_blank" rel="noopener">https://www.jianshu.com/p/1d766455445b</a></p></blockquote>]]></content>
    
    
    <categories>
      
      <category>Android</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Android</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>GitHub使用SSH的方式免密上传</title>
    <link href="undefined2018/07/05/GitHub-With-SSH/"/>
    <url>2018/07/05/GitHub-With-SSH/</url>
    
    <content type="html"><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>前一段时间换了github账号,各种转移数据,累死我</p><p>而后,我顺手添加了github的ssh-key(新创建了一个rsa的Key),然而当我:</p><pre><code class="shell"># phyooos @ wangzhumo in ~/develop/hexo [12:10:02] C:2$ hexo dINFO  Deploying: gitINFO  Clearing .deploy_git folder...    #...git@github.com: Permission denied (publickey).fatal: Could not read from remote repository.</code></pre><p>很迷,完全不知道为什么</p><a id="more"></a><h3 id="排除问题"><a href="#排除问题" class="headerlink" title="排除问题"></a>排除问题</h3><h4 id="查看-ssh目录"><a href="#查看-ssh目录" class="headerlink" title="查看~/.ssh目录"></a>查看~/.ssh目录</h4><pre><code class="shell">-rw-------  1 phyooos  staff   1.6K  6 27  2017 aliyun_rsa-rw-r--r--  1 phyooos  staff   398B  6 27  2017 aliyun_rsa.pub-rw-r--r--  1 phyooos  staff   402B  5 22  2017 authorized_keys-rw-r--r--  1 phyooos  staff   1.1K  6 28 14:48 config-rw-------  1 phyooos  staff   3.2K  6 27 18:05 github_rsa-rw-r--r--  1 phyooos  staff   746B  6 27 18:05 github_rsa.pub-rw-------  1 phyooos  staff   1.6K  5 17  2017 id_rsa-rw-r--r--@ 1 phyooos  staff   402B  5 17  2017 id_rsa.pub-rw-r--r--  1 phyooos  staff   1.3K  7  5 12:33 known_hosts</code></pre><p>其中</p><pre><code class="shell">-rw-------  1 phyooos  staff   3.2K  6 27 18:05 github_rsa-rw-r--r--  1 phyooos  staff   746B  6 27 18:05 github_rsa.pub</code></pre><p>就是我创建用来给github用的</p><h4 id="查看-ssh-config"><a href="#查看-ssh-config" class="headerlink" title="查看~/.ssh/config"></a>查看~/.ssh/config</h4><pre><code class="shell"># ---- github------------------Host github    HostName github.com    User git    IdentityFile /Users/phyooos/.ssh/github_rsa# -----------------------------</code></pre><p>也是没有问题的,而github上的key也就确实是github_rsa.pub</p><h4 id="Tower"><a href="#Tower" class="headerlink" title="Tower"></a>Tower</h4><p>但是我的Tower上,也有几个github上的项目,却可以正常的上传,</p><p>而Tower上的私钥是我手动配上去的,所以问题只有可能是终端中没有按照我的配置<code>IdentityFile /Users/phyooos/.ssh/github_rsa</code>来和github建立连接</p><p>我尝试把<code>id_rsa.pub</code>密钥加入到github上.</p><pre><code class="shell">To github.com:wangzhumo/wangzhumo.github.io.git   c45bbef..6b25311  HEAD -&gt; masterBranch &#39;master&#39; set up to track remote branch &#39;master&#39; from &#39;git@github.com:wangzhumo/wangzhumo.github.io.git&#39;.INFO  Deploy done: git</code></pre><p>竟然成功了.</p><h3 id="结论"><a href="#结论" class="headerlink" title="结论"></a>结论</h3><p><code>~/.ssh/config</code>中的配置,莫名没有生效,我至今也不知道为什么</p><p>还是说,github在终端中上传时,只会默认去拿id_rsa???</p><p>那就先这么用吧..迷</p>]]></content>
    
    
    <categories>
      
      <category>Tools</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Github</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Android非静态内部类与匿名内部类引起的内存泄漏</title>
    <link href="undefined2018/07/05/Android-inner-class-leak/"/>
    <url>2018/07/05/Android-inner-class-leak/</url>
    
    <content type="html"><![CDATA[<h3 id="内存"><a href="#内存" class="headerlink" title="内存"></a>内存</h3><h4 id="内存泄漏"><a href="#内存泄漏" class="headerlink" title="内存泄漏"></a>内存泄漏</h4><p>简单的说，当我们的对象创建时，就占用了一部分内存，而在这个对象没有被引用后会进行回收销毁，</p><p>以释放掉占用的内存。但是如果jvm没有成功回收这个对象，就会造成内存泄漏。</p><h4 id="内存溢出"><a href="#内存溢出" class="headerlink" title="内存溢出"></a>内存溢出</h4><p>Android中的OOM，系统会给每一个Android程序分配一定的内存。我的的App可能会因为大量的内存泄漏而导致内存耗尽，引发OOM导致整个App的崩溃。</p><p>就算内存没有耗尽而崩溃，也会导致App内存不足。此时我们创建新的对象或者其他方式需要使用内存时，GC就会主动进行垃圾回收，为你的操作准备好内存空间，每次GC都是阻塞操作，这就会导致我们的App卡顿。</p><blockquote><p>所以，我们优化App卡顿时，有一点就是要关注“内存抖动”。</p></blockquote><a id="more"></a><h3 id="案例"><a href="#案例" class="headerlink" title="案例"></a>案例</h3><h4 id="handler的内部类"><a href="#handler的内部类" class="headerlink" title="handler的内部类"></a>handler的内部类</h4><pre><code class="java">public class MainActivity extends Activity {   private final Handler mHandler = new Handler() {     @Override     public void handleMessage(Message msg) {        // do something     }   }    public void test1(){        // 延时60s        mHandler.postDelayed(new Runnable() {               @Override            public void run() {                    //run             }        }, 6000);        finish();    }  }</code></pre><p>我们知道在主线程中创建的Handler会被关联到 Looper（主线程的）中去，而主线程的Looper在应用程序的整个生命周期中存在 ，此时的Message会持有Handler对象，用来最后处理消息。</p><p>也就是调用<code>Handler#handleMessage(Message msg)</code></p><p><strong>当我们调用<code>test1()</code>方法</strong></p><ul><li>延时60s执行（但实际上，这个message已经发送，在消息队列中了，只是60s后才 handleMessage）</li><li>finish()掉这MainActivity</li><li><code>new Runnable</code>是一个匿名内部类，会持有隐式的外部类引用 </li></ul><p>这下就微妙了，MainActivity已经被finish了，但是延时Message却还存在于消息队列中，直到它被处理</p><p>延时Message 持有 MainActivity的Handler(用来处理这个消息)，而我们知道在Java中，非静态内部类和匿名类会隐式持有一个外部类的引用 ，在这里就是Handler隐式持有MainActivity</p><p>这下就导致，MainActivity 没有被垃圾回收机制回收 </p><p>还有个Runnable那…</p><h4 id="解决思路"><a href="#解决思路" class="headerlink" title="解决思路"></a>解决思路</h4><ol><li>去除隐式引用，可以把非静态内部类转化成静态的</li><li>手动管理外部类依赖，如果一定要使用，可以手动传入外部类（像Context这样的完全可以使用ApplicationContext替代）</li></ol><h4 id="案例小结"><a href="#案例小结" class="headerlink" title="案例小结"></a>案例小结</h4><p>非静态的内部类，由于它的生命周期不能同外部类一致，它的生存周期已经超过了它的外部类。</p><p>所以在它的外部类被回收时，被它打断了这个操作，导致内存泄漏产生</p><h3 id="内部类"><a href="#内部类" class="headerlink" title="内部类"></a>内部类</h3><p>Java中内部类分为四种 </p><ol><li>静态内部类</li><li>静态匿名内部类</li><li>非静态内部类</li><li>非静态内部匿名类</li></ol><table><thead><tr><th>说明</th><th>成员内部类</th><th>静态内部类</th></tr></thead><tbody><tr><td>静态成员</td><td>静态成员需同时有final关键词修饰</td><td>可以</td></tr><tr><td>静态方法</td><td>不可定义</td><td>可以</td></tr><tr><td>访问外部类非static属性/方法</td><td>外部类名.this.成员方法/属性</td><td>不可以</td></tr><tr><td>外部类访问内部类</td><td>需要通过内部类的一个实例来访问</td><td>需要通过内部类的一个实例来访问</td></tr><tr><td>创建实例</td><td>外部类名.内部类名 实例名 = 外部类实例名.new 内部类构造方法(参数)</td><td>外部类名.内部类名 实例名 = new 外部类名.内部类名(参数)</td></tr><tr><td>编译后的class文件</td><td>单独的class文件(so内部类中的方法和变量可以跟父类的方法和变量同名)，外部类$内部类.class</td><td>单独的class文件(so内部类中的方法和变量可以跟父类的方法和变量同名)，外部类$内部类.class</td></tr><tr><td>其他</td><td>与外部类平级的类继承内部类时，其构造方法中需要传入父类的实例对象。且在构造方法的第一句调用“外部类实例名.super(内部类参数)”</td><td>无</td></tr></tbody></table><table><thead><tr><th><strong>说明</strong></th><th style="text-align:left"><strong>成员内部类</strong></th><th><strong>匿名内部类</strong></th></tr></thead><tbody><tr><td>静态成员</td><td style="text-align:left">静态成员需同时有final关键词修饰</td><td>不可定义</td></tr><tr><td>静态方法</td><td style="text-align:left">不可定义</td><td>不可定义</td></tr><tr><td>访问外部类非static属性/方法</td><td style="text-align:left">外部类名.this.成员方法/属性</td><td>外部类名.this.成员方法/属性</td></tr><tr><td>外部类访问内部类</td><td style="text-align:left">需要通过内部类的一个实例来访问</td><td>需要通过内部类的一个实例来访问</td></tr><tr><td>创建实例</td><td style="text-align:left">外部类名.内部类名 实例名 = 外部类实例名.new 内部类构造方法(参数)</td><td>如上：父类 实例名 = new 父类（）{}</td></tr><tr><td>编译后的class文件</td><td style="text-align:left">单独的class文件(so内部类中的方法和变量可以跟父类的方法和变量同名)，外部类$内部类.class</td><td>单独的class文件，使用类$数字.class</td></tr><tr><td>其他</td><td style="text-align:left">与外部类平级的类继承内部类时，其构造方法中需要传入父类的实例对象。且在构造方法的第一句调用“外部类实例名.super(内部类参数)”</td><td>无</td></tr></tbody></table><blockquote><p><a href="https://www.cnblogs.com/dorothychai/p/6007709.html" target="_blank" rel="noopener">https://www.cnblogs.com/dorothychai/p/6007709.html</a></p></blockquote><h3 id="启示"><a href="#启示" class="headerlink" title="启示"></a>启示</h3><ol><li><p>非静态内部类 改为 静态非匿名内部类 </p></li><li><p>使用弱引用</p></li><li><p>在适当的时机手动销毁，在onDestory中手动销毁</p><p>养成良好的习惯，Context、Handler、Timer、Thread  、广播 、 IO 等都要注意销毁</p></li></ol>]]></content>
    
    
    <categories>
      
      <category>Android</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Android</tag>
      
      <tag>Java</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Git Submodule 子模块的使用</title>
    <link href="undefined2018/07/02/Git-Submodule/"/>
    <url>2018/07/02/Git-Submodule/</url>
    
    <content type="html"><![CDATA[<h4 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h4><p><em>Git</em>是一个开源的分布式版本控制系统,大家公司可能都是使用的Git来进行版本控制.</p><p>对于我个人,本地项目也喜欢使用git,万一哪天想回退一下,没有git可就真费劲了.</p><p>对于git的常规操作不用多说,今天贴一个submodule的真实使用过程</p><a id="more"></a><p><img src="/images/git_all_project.png" srcset="/img/loading.gif" alt="project"></p><p>项目结构如上.</p><p>为了方便我自己玩,我开了一个playground的项目</p><p>playground</p><pre><code class="shell">.├── app              #主项目├── lib_common         #子项目,其中主要提供三方的依赖,以及整个项目的公共代码部分                     #因为这个项目需要及时更新,方便每个人使用,所以是一个submodule来管理 ├── lib_player   ├── module_views     #今天要演示的子模块</code></pre><p>其实Submodule 和Android的组件化更配哦,属于强强联合</p><h4 id="创建module-views模块"><a href="#创建module-views模块" class="headerlink" title="创建module_views模块"></a>创建module_views模块</h4><h5 id="建立module"><a href="#建立module" class="headerlink" title="建立module"></a>建立module</h5><p>在我们playground的项目上,创建一个新模块,怎么操作就不说了</p><h5 id="在module-views中初始化Git"><a href="#在module-views中初始化Git" class="headerlink" title="在module_views中初始化Git"></a>在module_views中初始化Git</h5><blockquote><p>注意,当module_views这个模块创建时,一定不要手快把这个模块添加到playground整个项目的版本控制中</p><p>记得<strong>忽略module_views整个module</strong></p></blockquote><p>直接贴操作了</p><pre><code class="shell"># phyooos @ wangzhumo in ~ [16:38:01]$ cd ~/workspace/playground# phyooos @ wangzhumo in ~/workspace/playground on git:master x [16:58:48]$ ll | grep &#39;module_views&#39;drwxr-xr-x  11 phyooos  staff   352B  7  2 16:31 module_views# phyooos @ wangzhumo in ~/workspace/playground on git:master x [16:59:03]$ cd module_views# phyooos @ wangzhumo in ~/workspace/playground/module_views  [16:59:19]$ git initReinitialized existing Git repository in /Users/phyooos/workspace/playground/module_views/.git/</code></pre><p>因为我的module_views已经创建git仓库了,所以最后一步提示 <code>Reinitialized existing Git repository</code></p><h5 id="关联远程仓库"><a href="#关联远程仓库" class="headerlink" title="关联远程仓库"></a>关联远程仓库</h5><p>这一步随意,我本人是在github上创建了一个名为<a href="https://github.com/wangzhumo/module_views" target="_blank" rel="noopener">module_views</a>的库</p><p>拿到远程仓库地址 git@github.com:wangzhumo/module_views.git</p><pre><code class="shell"># phyooos @ wangzhumo in ~/workspace/playground/module_views  [16:59:30]$ git remote add origin git@github.com:wangzhumo/module_views.git# phyooos @ wangzhumo in ~/workspace/playground/module_views on git:master o [16:59:30]$ git pushEverything up-to-date# phyooos @ wangzhumo in ~/workspace/playground/module_views on git:master o [17:06:51]$ git statusOn branch masterYour branch is up to date with &#39;origin/master&#39;.nothing to commit, working tree clean</code></pre><p>添加远程仓库,并push,把本地代码提交到github上去,因为我自己已经提交过了,所以可以看到</p><p><code>Everything up-to-date</code></p><h4 id="添加子模块到playground中"><a href="#添加子模块到playground中" class="headerlink" title="添加子模块到playground中"></a>添加子模块到playground中</h4><p>贴操作</p><pre><code class="shell"># phyooos @ wangzhumo in ~/workspace/playground on git:master x [16:38:12]$ git submodule add git@github.com:wangzhumo/module_views.git ./module_viewsThe following path is ignored by one of your .gitignore files:module_viewsUse -f if you really want to add it.# phyooos @ wangzhumo in ~/workspace/playground on git:master x [16:38:59] C:1$ git submodule add -f git@github.com:wangzhumo/module_views.git ./module_viewsAdding existing repo at &#39;module_views&#39; to the index# phyooos @ wangzhumo in ~/workspace/playground on git:master x [16:39:21]$ git submodule 1616423ab118e2154bcf018c825f6ed3a57cf59b lib_common (heads/master) 55ae43eb327207a456624c69e3c01868f8cf43e3 module_views (heads/master)# phyooos @ wangzhumo in ~/workspace/playground on git:master x [16:39:48]$ git submodule foreach git pullEntering &#39;lib_common&#39;Already up to date.Entering &#39;module_views&#39;Already up to date.</code></pre><p>下面解释每一条命令</p><ol><li><p><code>git submodule add git@github.com:wangzhumo/module_views.git ./module_views</code></p><p>添加子模块 <code>git submodule add &lt;repository&gt; &lt;path&gt; 添加子模块</code></p><p>提示如下:</p><pre><code>The following path is ignored by one of your .gitignore files:module_viewsUse -f if you really want to add it.</code></pre><p>说我已经把<code>module_views</code>添加到忽略文件中了,如果确实想这样操作,加上<code>-f</code>强制操作</p></li></ol><ol><li><p><code>git submodule add -f git@github.com:wangzhumo/module_views.git ./module_views</code></p><p>可以看到提示,我已经成功的把<code>module_views</code>作为子项目添加到<code>playground</code>中了</p></li></ol><ol><li><p><code>git submodule</code></p><p>一共看到两个子模块,一个是刚添加的<code>module_views</code>,一个是我之前添加的</p></li></ol><ol><li><p><code>git submodule foreach git pull</code></p><p>拉取最新代码</p></li></ol><h4 id="其他submodule操作"><a href="#其他submodule操作" class="headerlink" title="其他submodule操作"></a>其他submodule操作</h4><p>文档</p>]]></content>
    
    
    <categories>
      
      <category>Tools</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Git</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>ServiceLoader 与 责任链设计模式</title>
    <link href="undefined2018/06/26/serviceloader-zerenlian/"/>
    <url>2018/06/26/serviceloader-zerenlian/</url>
    
    <content type="html"><![CDATA[<h3 id="前因"><a href="#前因" class="headerlink" title="前因"></a>前因</h3><p>最近在做人脸识别的一些东西</p><p>主要是使用百度的SDK来完成采集, 识别.</p><p>这个功能是使用百度云的Api来对人脸进行分析,拿到年龄 颜值 等等信息</p><a id="more"></a><p><strong>第一版设计稿:</strong></p><p><img src="/images/face_value.png" srcset="/img/loading.gif" alt="之前的效果"></p><p>那我就直接把请求到的数据展示了一下,然而</p><p><strong>第二版设计稿:</strong></p><p><img src="/images/face_text.png" srcset="/img/loading.gif" alt="第二版"></p><p>这一版就是需要把拿到的数值按照区间来展示成文字描述</p><p>那么,应该就是各种switch    if else </p><p>….</p><p>本来也是做Demo,所以我们可以高点其他的东西,于是我就想起了责任链模式,勉强可以做做么</p><h3 id="实现责任链"><a href="#实现责任链" class="headerlink" title="实现责任链"></a>实现责任链</h3><h4 id="定义抽象类"><a href="#定义抽象类" class="headerlink" title="定义抽象类"></a>定义抽象类</h4><p>com.baidu.aip.fl.func.service.HandlerFace.java  接口</p><pre><code class="java">public abstract class HandlerFace {    private HandlerFace nextHandler;    //接收一个实体类    public abstract ResultBean process(ResultBean bean);    //返回下一个处理类    public HandlerFace nextHandler(){        return nextHandler;    }    //设置下一个处理类    public void setHandler(HandlerFace handler){        this.nextHandler = handler;    }}</code></pre><h4 id="具体实现"><a href="#具体实现" class="headerlink" title="具体实现"></a>具体实现</h4><p><code>com.baidu.aip.fl.func.service.AgeHandlerFace.java</code>  实现类,处理年龄信息</p><pre><code class="java">public class AgeHandlerFace extends HandlerFace {    @Override    public ResultBean process(ResultBean bean) {        //1.处理自己的事情        if (bean != null &amp;&amp; bean.getIntAge() == 0 ){            bean.setResultAge(&quot;-&quot;);        }else if (bean != null &amp;&amp; bean.getIntAge() &lt;= 5){            bean.setResultAge(&quot;小朋友&quot;);        }else if (bean != null &amp;&amp; bean.getIntAge() &lt;= 10){            bean.setResultAge(&quot;中等朋友&quot;);        }else if (bean != null &amp;&amp; bean.getIntAge() &lt;= 15){            bean.setResultAge(&quot;大朋友&quot;);        }else if (bean != null &amp;&amp; bean.getIntAge() &lt;= 20){            bean.setResultAge(&quot;成年人&quot;);        }else if (bean != null &amp;&amp; bean.getIntAge() &lt;= 40){            bean.setResultAge(&quot;中年人&quot;);        }else if (bean != null &amp;&amp; bean.getIntAge() &lt;= 60){            bean.setResultAge(&quot;老年人&quot;);        }else if (bean != null &amp;&amp; bean.getIntAge() &lt;= 100){            bean.setResultAge(&quot;年纪好大&quot;);        }        //2.是否有下一个人来处理        if (nextHandler() != null){            //2.1.如果有下一个处理类,则把信息交给他继续处理            return nextHandler().process(bean);        }        //3.没有下一个处理直接返回        return bean;    }}</code></pre><p>AgeHandlerFace类只处理年纪相关的东西</p><p><code>com.baidu.aip.fl.func.service.BeautyHandlerFace.java</code></p><p><code>com.baidu.aip.fl.func.service.GenderHandlerFace.java</code></p><p>同样实现HandlerFace,分别处理颜值和性别</p><h3 id="ServiceLoader"><a href="#ServiceLoader" class="headerlink" title="ServiceLoader"></a>ServiceLoader</h3><p>上面的责任链其实已经可以使用,但是需要手动来初始化每个具体实现类,</p><p>并且一个一个设置 nextHandler ,最后调用处理</p><pre><code class="java">public class RealProcessFace{    //保存HandlerFace的每一个实现类    private static ArrayList&lt;HandlerFace&gt; arraylist;    static {        arraylist = new ArrayList();        //通过ServiceLoader来加载所有HandlerFace的实现类        ServiceLoader&lt;HandlerFace&gt; processors = ServiceLoader.load(HandlerFace.class);        Iterator iterator = processors.iterator();        while (iterator.hasNext()) {            //iterator.next() 这里具体实现类才真正的初始化了            arraylist.add((HandlerFace) iterator.next());        }    }    /**     * 获取组合短语     * @param task 人脸信息     * @return 组合短语     */    public static String process(ResultBean task) {        for (int i = 0; i &lt; arraylist.size() - 1 ; i++) {            //依次设置setHandler             //因为我并不需要他们依次处理,所以我并不关系他们处理的顺序            //如果是需要顺序执行的话,建议还是手动处理            arraylist.get(i).setHandler(arraylist.get(i+1));        }        //调用第一个处理类,就会依次调用后面的处理类        ResultBean resultBean = arraylist.get(0).process(task);        //返回处理结果        return resultBean.format();    }}</code></pre><h4 id="使用方法"><a href="#使用方法" class="headerlink" title="使用方法"></a>使用方法</h4><p><img src="/images/service_info.png" srcset="/img/loading.gif" alt="info"></p><p>1.创建一个base类,就是我上面写过的,可以是接口和抽象类</p><p><code>com.baidu.aip.fl.func.service.HandlerFace</code></p><p>2.一个或多个实现类</p><p><code>com.baidu.aip.fl.func.service.AgeHandlerFace.java</code></p><p><code>com.baidu.aip.fl.func.service.BeautyHandlerFace.java</code></p><p><code>com.baidu.aip.fl.func.service.GenderHandlerFace.java</code></p><p>这里一共是3个</p><p>3.定义resources/META-INF/ …. 文件</p><ul><li><p>该文件无拓展名</p></li><li><p>文件名就是 base类 或者接口 的全路径( 包名 + Filename )</p></li><li><p>文件中每一行写一个实现类的全路径名( 包名 + Filename )</p><p>src/main/resources/META-INF/services/com.baidu.aip.fl.func.service.HandlerFace</p><pre><code>com.baidu.aip.fl.func.service.GenderHandlerFacecom.baidu.aip.fl.func.service.AgeHandlerFacecom.baidu.aip.fl.func.service.BeautyHandlerFace</code></pre></li></ul><p>4.获取所有实现类</p><pre><code class="java">ServiceLoader&lt;HandlerFace&gt; processors = ServiceLoader.load(HandlerFace.class);//注意此时实现类都没有实例化Iterator iterator = processors.iterator();while (iterator.hasNext()) {    //iterator.next() 这里具体实现类才真正的初始化了    arraylist.add((HandlerFace) iterator.next());}</code></pre><p>这样的懒加载过程是由ServiceLoader实现的</p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><h4 id="责任链"><a href="#责任链" class="headerlink" title="责任链"></a>责任链</h4><p>这样的形式,为后期的扩展提供了很大的便利</p><p>AgeHandlerFace 中,我可以分更细的粒度,也可以合并.</p><p>eg:  50 以下都是年轻人</p><pre><code>   100 - 50 是老年人</code></pre><p>责任链虽然Android端最显著的算是 <strong>事件分发机制</strong>  ,很多框架中也都有使用,filter这样的东西</p><h4 id="ServiceLoader-1"><a href="#ServiceLoader-1" class="headerlink" title="ServiceLoader"></a>ServiceLoader</h4><p>这个东西,很强大</p><p>在插件化,以及 服务提供等方面都有应用</p>]]></content>
    
    
    <categories>
      
      <category>Java</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Java</tag>
      
      <tag>设计模式</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Android自定义一个遮罩引导层</title>
    <link href="undefined2018/05/21/Android-Shade/"/>
    <url>2018/05/21/Android-Shade/</url>
    
    <content type="html"><![CDATA[<h4 id="分析需求"><a href="#分析需求" class="headerlink" title="分析需求"></a>分析需求</h4><p>高亮显示指定的控件(1个或者多个)</p><ul><li>只有一个高亮控件,则直接绘制即可</li><li>多个高亮控件,则分两种效果展示<ul><li>顺序展示每一个控件</li><li>展示所有控件</li></ul></li><li>高亮部分的形状<ul><li>方形</li><li>圆形</li></ul></li></ul><a id="more"></a><p>展示与消失</p><ul><li>自动展示,自动消失</li><li>点击消失</li><li>点击指定部分消失</li></ul><h4 id="实现方式"><a href="#实现方式" class="headerlink" title="实现方式"></a>实现方式</h4><h5 id="遮罩层"><a href="#遮罩层" class="headerlink" title="遮罩层"></a>遮罩层</h5><ol><li>直接在本来的页面是添加,不用时消失</li><li>使用DecorView的方式,添加view即可</li><li>使用透明Activity覆盖</li></ol><p>选择第二种方式来实现</p><p>第一种方便但是耗时耗力,并且不能通用</p><p>第二种是大家都认可的一种方式,而且支持配置</p><p>第三种,对原界面生命周期造成影响,不太好</p><h5 id="高亮的实现"><a href="#高亮的实现" class="headerlink" title="高亮的实现"></a>高亮的实现</h5><p><strong>PorterDuffXfermode</strong>      :: PorterDuff.Mode.XOR)</p><h4 id="代码设计"><a href="#代码设计" class="headerlink" title="代码设计"></a>代码设计</h4><ul><li>mask layer View   用来实现遮罩层<ul><li>高亮显示绘制</li><li>指示语位置</li></ul></li><li>mask layer Manager  用来管理  遮罩层 <ul><li>addView</li><li>Show / hide </li><li>DecorView 操作</li><li>其他配置信息</li></ul></li><li>mask bean  用来存放需要高亮的View信息(高度,宽度..)</li></ul><h4 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h4><p>mask:</p><p>MaskGuideView   遮罩层容器</p><p>MaskLayout   高亮控件与指示语的位置,以及排列展示</p><p>MaskManager      加载管理整个遮罩层</p><p>MaskType      高亮控件的形状, 圆 方</p><p>TargetInfo      高亮控件的位置信息</p><p>TargetInfo.java</p><pre><code class="java">/** * If you have any questions, you can contact by email { wangzhumoo@gmail.com} * * @author 王诛魔 2018/5/21 下午7:20 * * 高亮区域信息 */public class TargetInfo {    /*     * 高亮区域起始X坐标     */    public int startX;    /*     * 高亮区域起始Y坐标     */    public int startY;    /*     * 高亮区域宽度     */    public int width;    /*     * 高亮区域高度     */    public int height;    /*     * 偏移量     */    public int offset = 10;    /**     * 获取半径     */    public int getRadius() {        return Math.max(width, height) / 2;    }}</code></pre><p>MaskType.java</p><pre><code class="java">/** * If you have any questions, you can contact by email { wangzhumoo@gmail.com} * * @author 王诛魔 2018/5/21 下午7:18 */public enum MaskType {    Rect,Circle}</code></pre><pre><code class="java">/** * If you have any questions, you can contact by email { wangzhumoo@gmail.com} * * @author 王诛魔 2018/5/21 下午11:35 * * 负责管理,准备,操作MaskGuideView */public class MaskManager {    //属性    private static final String TAG = &quot;MaskManager&quot;;    private final ViewGroup mRootView;    private final MaskGuideView mMaskGuideView;    private final Context mContext;    private List&lt;TargetInfo&gt; mTargetInfoList;    private List&lt;View&gt; mTargetViewList;    private List&lt;MaskLayout&gt; mMaskLayoutList;    private MaskType mMaskType;    private boolean isShowAll;    private int mPadding;    /**     * 计算targetInfo     *     * @param targetView view     * @return TargetInfo     */    private TargetInfo generateTargetInfo(View targetView) {        int[] location = new int[2];        //我们需要的是,这个targetView在整个屏幕上的位置        targetView.getLocationOnScreen(location);        TargetInfo targetInfo = new TargetInfo();        //计算startX width ...        switch (mMaskType) {            case Rect:                targetInfo.startX = location[0] - mPadding;                targetInfo.startY = location[1] - mPadding;                targetInfo.width = targetView.getWidth() + 2 * mPadding;                targetInfo.height = targetView.getHeight() + 2 * mPadding;                break;            case Circle:                int diameter = Math.max(targetView.getWidth() + 2 * mPadding, targetView.getHeight() + 2 * mPadding);                targetInfo.startX = location[0] - mPadding;                targetInfo.startY = location[1] - mPadding - (diameter / 2 - targetView.getHeight() / 2 - mPadding);                targetInfo.width = diameter;                targetInfo.height = diameter;                break;        }        Log.e(TAG, &quot;generateTargetInfo: &quot; + targetInfo.toString() );        return targetInfo;    }    /*     * builder模式     */    public static class Builder {        private ViewGroup mRootView;        private MaskGuideView mMaskGuideView;        private Context mContext;        private List&lt;TargetInfo&gt; mTargetInfoList;        private List&lt;MaskLayout&gt; mMaskLayoutList;        private List&lt;View&gt; mTargetViewList;        private MaskType mMaskType = MaskType.Circle;        private int mPadding = 0;        private int mGravity = Gravity.TOP;        private boolean isShowAll;        ...省略        public MaskManager build() {            this.mMaskGuideView.setOnClickListener(this.mMaskGuideView);            return new MaskManager(this);        }    }}</code></pre><p>额,代码传git好了</p>]]></content>
    
    
    
    <tags>
      
      <tag>Android</tag>
      
      <tag>View</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Android Binder机制(一)</title>
    <link href="undefined2018/05/11/Android-Binder-1/"/>
    <url>2018/05/11/Android-Binder-1/</url>
    
    <content type="html"><![CDATA[<h3 id="ServiceManager"><a href="#ServiceManager" class="headerlink" title="ServiceManager"></a>ServiceManager</h3><p>首先我们要了解一下ServiceManager.</p><p>ServiceManager的功能主要就是注册,查询服务,作为一个大管家的角色出现.</p><ul><li>注册服务：记录服务名和信息，放到服务列表</li><li>查询服务：根据服务名查询相应的的信息</li></ul><p>ServiceManager是有权限控制的，只有具有相应权限的进程才能注册,查询服务</p><p><a href="http://gityuan.com/2015/11/08/binder-get-sm/" target="_blank" rel="noopener">http://gityuan.com/2015/11/08/binder-get-sm/</a></p><a id="more"></a><h3 id="Linux内存"><a href="#Linux内存" class="headerlink" title="Linux内存"></a>Linux内存</h3><h4 id="内核空间"><a href="#内核空间" class="headerlink" title="内核空间"></a>内核空间</h4><p>为什么进程间不可以直接通讯那?</p><p>因为每个进程的内存空间都是隔离起来的,不可能随意去访问其他进程的内存.</p><p>在32位系统中,寻址空间最大为4G,那么这4G内存,一般将1G分配给内核空间,3G用户空间,Linux内核由系统内的所有进程共享.</p><p><img src="/images/linux_memory.png" srcset="/img/loading.gif" alt=""></p><p>这么一来,我们就可以在内核空间为所欲为了,不,并不能.用户进程不能直接操作内核.</p><p>Android是在Linux的内核上跑的,那么为什么Android要自己做一个Binder来实现进程间的通讯那?</p><p>我们都知道Linux上Socket/管道/消息队列都可以做到进程间的通讯,但是通过这些都需要2次内存拷贝,</p><p>而Binder只需要一次就可以完成,大大的提高效率</p><h4 id="BINDER-MMAP"><a href="#BINDER-MMAP" class="headerlink" title="BINDER_MMAP"></a>BINDER_MMAP</h4><p>mmap可以将一个文件或者其它对象映射进内存</p><p>在Binder中,通过在用户空间(当前进程的用户空间)创建一个虚拟地址空间,并在内核空间创建相同大小的虚拟地址空间.</p><p>接着申请一块物理内存,将物理内存映射到内核虚拟地址空间和用户虚拟内存空间,这样就实现了用户控件和内核空间的同步.</p><p><img src="/images/binder_physical_memory.jpg" srcset="/img/loading.gif" alt="来自Gityuan大佬"></p><h4 id="大概流程"><a href="#大概流程" class="headerlink" title="大概流程"></a>大概流程</h4><ol><li>copy_from_user 首先是要发出消息的,那么先从用户控件from 拷贝数据</li><li>binder_thread_write 第二步就是把刚才拷贝的数据写入到内核空间</li><li>binder_thread_read 第三步再次读取刚才从用户控件from读取并写入内核空间的数据</li><li>copy_to_user 最后当然是从内核空间拷贝数据到用户空间to(即目标)</li></ol><p>PS:以上均建立在每一次操作都成功的基础上</p><p>来自Gityuan大神的分享<a href="http://gityuan.com/2015/11/01/binder-driver/" target="_blank" rel="noopener">http://gityuan.com/2015/11/01/binder-driver/</a></p><p><img src="/images/binder_memory_map.jpg" srcset="/img/loading.gif" alt="binder_memory"></p><p>解释说明:</p><p>首先Client端发送消息,通过copy_from_user从Client端<strong>拷贝数据</strong>到内核空间去</p><p>而后还记得<strong>BINDER_MMAP</strong>中的操作么,内核空间的地址与Server是同一块物理内存,</p><p>Server就可以通过这个方式,直接同步到Client发送的数据.</p><blockquote><ul><li>binder_init：初始化字符设备；</li><li>binder_open：打开驱动设备，过程需要持有binder_main_lock同步锁；</li><li>binder_mmap：申请内存空间，该过程需要持有binder_mmap_lock同步锁；</li><li>binder_ioctl：执行相应的ioctl操作，该过程需要持有binder_main_lock同步锁；<ul><li>当处于binder_thread_read过程，read_buffer无数据则释放同步锁，并处于wait_event_freezable过程，等有数据到来则唤醒并尝试持有同步锁。</li></ul></li></ul></blockquote>]]></content>
    
    
    
    <tags>
      
      <tag>Android</tag>
      
      <tag>Source Code</tag>
      
      <tag>Binder</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>线程与进程的异同以及Android中的IPC机制</title>
    <link href="undefined2018/05/10/Thread-Process-IPC/"/>
    <url>2018/05/10/Thread-Process-IPC/</url>
    
    <content type="html"><![CDATA[<h3 id="线程与进程"><a href="#线程与进程" class="headerlink" title="线程与进程"></a>线程与进程</h3><p>Google  Doc (<a href="https://developer.android.com/guide/components/processes-and-threads" target="_blank" rel="noopener">https://developer.android.com/guide/components/processes-and-threads</a>)</p><ul><li><p>进程是资源分配的最小单位，线程是cpu调度的最小单位.</p></li><li><p>进程是应用程序的执行实例,一个进程中可以包含多个线程,</p><p>而一个进程的创建分配是要消耗较大的性能的,相比来说线程就要比进程的开销小.</p></li><li><p>对于进程来说不共享资源,内存是独立的.而线程共享它所在的线程的资源,内存.</p></li><li><p>进程间的通信就要更加麻烦,需要使用IPC( Inter-Proscess Communication)进程间的通讯</p><p>线程方便很多,但是线程间的同步又是一个较为大的课题了.</p></li></ul><blockquote><p>想强调的是，线程关注的是中央处理器的运行，而不是进程那样关注内存等资源的管理。</p></blockquote><a id="more"></a><h3 id="Android中的IPC机制"><a href="#Android中的IPC机制" class="headerlink" title="Android中的IPC机制"></a>Android中的IPC机制</h3><p>如下图所示:(已经不知道哪里的配图了…感谢分享)</p><p><img src="/images/android_ipc.png" srcset="/img/loading.gif" alt=""></p><h4 id="IPC简介"><a href="#IPC简介" class="headerlink" title="IPC简介"></a>IPC简介</h4><p>IPC(Inter-Process Communication) 进程间通信</p><p>使用场景:</p><p>在Android程序中，一般情况下一个程序就是一个进程</p><ol><li><p>App间的通信,常见的如需要使用其他App的数据</p></li><li><p>一个App使用多进程,比如指定运行线程<code>android:process=&quot;:name&quot;</code></p><blockquote><p>需要注意的是,如果一个App使用多进程,Application也会多次创建</p></blockquote></li></ol><h4 id="Bundle"><a href="#Bundle" class="headerlink" title="Bundle"></a>Bundle</h4><p>常见于Activity,service中传递数据</p><p>需要注意的是,bundle中的数据必须支持序列化(Serializable,Parcelable)</p><h4 id="文件共享"><a href="#文件共享" class="headerlink" title="文件共享"></a>文件共享</h4><p>SharedPreference就是这种实现的.</p><p>适合对同步要求不高的使用方式,需要注意处理好并发的问题.</p><h4 id="Messenger"><a href="#Messenger" class="headerlink" title="Messenger"></a>Messenger</h4><p>Messenger 对 AIDL 进行了封装，它实现了一种基于消息的进程间通信的方式</p><p><code>frameworks/base/core/java/android/os/IMessenger.aidl</code></p><p>它的AIDL文件就在这里保存着!</p><h4 id="AIDL"><a href="#AIDL" class="headerlink" title="AIDL"></a>AIDL</h4><p>AIDL（Android Interface definition language） 是 Android 提供的一种进程间通信 (IPC) 机制</p><p>需要注意的是AIDL支持的数据类型与Java接口支持的数据类型有些不同:</p><ol><li>所有基础类型（int, char…）</li><li>String，List，Map</li><li>所有Parcelable的类</li></ol><p>并且要根据需要添加 in out 的关键词</p><h4 id="ContentProvider"><a href="#ContentProvider" class="headerlink" title="ContentProvider"></a>ContentProvider</h4><p>主要是针对数据库使用的,最常见的例子就是Android中有很多已经定义好的ContentProvider</p><h4 id="Socket"><a href="#Socket" class="headerlink" title="Socket"></a>Socket</h4><p>说到这里,就不得不提一下<strong>Binder</strong>了</p><p><a href="http://www.wangzhumo.com/Source-Code/Android-Binder%E6%9C%BA%E5%88%B6-%E4%B8%80/">http://www.wangzhumo.com/Source-Code/Android-Binder%E6%9C%BA%E5%88%B6-%E4%B8%80/</a></p>]]></content>
    
    
    <categories>
      
      <category>Java</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Java</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Java中的内存模型</title>
    <link href="undefined2018/05/09/Java-memory-module/"/>
    <url>2018/05/09/Java-memory-module/</url>
    
    <content type="html"><![CDATA[<p><img src="/images/java_heap_stack.png" srcset="/img/loading.gif" alt="java_heap_stack"></p><a id="more"></a><h4 id="1-堆"><a href="#1-堆" class="headerlink" title="1. 堆"></a>1. 堆</h4><p>在JVM中只有一个,java回收机制主要就是作用于这一块</p><p>堆主要是用来存放存储对象的内容及其本身的.</p><h4 id="2-方法区"><a href="#2-方法区" class="headerlink" title="2. 方法区"></a>2. 方法区</h4><p>方法区也和堆一样,是被线程共享的.</p><p>存放了类的信息(方法,字段,名称),静态变量,常量</p><p>Java1.7之前,字符串常量池也是放在这里的,但是1.7以后移动到堆里面去了</p><h4 id="3-虚拟机栈"><a href="#3-虚拟机栈" class="headerlink" title="3. 虚拟机栈"></a>3. 虚拟机栈</h4><p><img src="/images/java_stack.png" srcset="/img/loading.gif" alt="java_stack"></p><p>每一个栈帧的出入栈都是一个方法被调起直到结束返回的过程.</p><p>每个线程都会有一个自己的Java栈，栈帧中包括</p><ul><li><p>局部变量表(Local Variables)</p><p>方法中的局部变量,函数的参数等.对于基础类型的变量直接存储他的值,而引用类型的变量</p><p>则存储的是指向对象的引用</p></li><li><p>操作数栈(Operand Stack)</p></li><li><p>指向运行时常量池的引用(Reference to runtime constant pool)</p><p>保证方法可以使用当前类的常量</p></li><li><p>方法返回地址(Return Address)</p><p>执行一个方法完成后需要返回调用它的地方</p></li><li><p>附加信息</p></li></ul><h4 id="4-程序计数器"><a href="#4-程序计数器" class="headerlink" title="4. 程序计数器"></a>4. 程序计数器</h4><p>Program Counter Register 也称作为PC寄存器,保存的是程序当前执行的指令的地址</p><h4 id="5-本地方法栈"><a href="#5-本地方法栈" class="headerlink" title="5.本地方法栈"></a>5.本地方法栈</h4><p>本地方法栈则是为执行本地方法（Native Method）服务的</p>]]></content>
    
    
    <categories>
      
      <category>Java</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Java</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Android的启动流程</title>
    <link href="undefined2018/05/09/Android-App-Launch/"/>
    <url>2018/05/09/Android-App-Launch/</url>
    
    <content type="html"><![CDATA[<h5 id="系统结构"><a href="#系统结构" class="headerlink" title="系统结构"></a>系统结构</h5><ul><li><p>应用层</p><p>即为开发出来的一些app,当然还包括了一些系统App</p></li><li><p>应用框架层(Java API Framework)</p><p>这一层由java编写,提供给我们平时开发使用的API,主要的一些组件:</p><ul><li><p>Manager</p><p>Activity Manager , Window Manager , Package Manager ,Location Manager </p><p>Notification Manager,Resource Manager,Telephony Manager</p></li><li><p>Content Providers</p></li><li><p>View System</p></li></ul></li><li><p>系统运行库层</p><p>C/C++程序库和Android运行时库</p></li><li><p>硬件抽象层(<strong>HAL</strong>)</p></li><li><p>Linux内核层</p></li></ul><p><img src="/images/android_boot_process.png" srcset="/img/loading.gif" alt="boot"></p><a id="more"></a><h5 id="Android的启动主要过程"><a href="#Android的启动主要过程" class="headerlink" title="Android的启动主要过程"></a>Android的启动主要过程</h5><ol><li><p><strong>init进程</strong></p><p>init进程是由内核启动的,是用户空间的第一个进程,可以说是一个root进程</p><ul><li>当init进程启动后会创建挂载系统目录,设备节点,</li><li>解析init.rc 和 init.hardware.rc,启动属性服务，以及一系列的服务和进程</li></ul></li></ol><ol><li><p><strong>本地守护进程</strong></p><p>启动</p><blockquote><p>servicemanager  管理binder的通讯</p><p>surfaceflinger  UI</p><p>mediaserver  音视频,相机</p><p>netd  蓝牙、wifi、usb等</p><p>adbd</p><p>rild</p><p>installd </p></blockquote><p>需要注意的是这些都是一个独立的Linux进程</p></li><li><p><strong>Native系统服务</strong></p><p>运行在本地守护进程中,所属进程初始化的时候会将Native系统服务注册到ServiceManager中,方便我们通过Binder机制调用Native系统服务</p></li><li><p><strong>Java服务</strong></p><p>再创建本地服务的同时,init进程还会创建Zygote进程</p><p>Zygote也是Android中相当重要的一个进程了,Zygote进程会建立一个Dalvik VM并且启动</p><p>System Server系统服务</p><p>System Server将启动Android Service</p><blockquote><p>AccessibilityManagerService 截获用户输入，并根据输入给用户一些额外的反馈，起到辅助效果的服务<br>AccountManagerService 管理设备中所有账号的服务，包括账号、密码、授权管理功能<br>ActivityManagerService 管理所有组件的服务，安卓系统的核心服务 AlarmManagerService 管理闹钟的服务<br>AppWidgetService 管理APP widgets的工作，包括加载、删除、布局等<br>AssetAtlasService 将一些系统图片资源合并成一个纹理图传给GPU达到硬件加速的效果的服务<br>AudioService 管理音频的服务<br>BackupManagerService 管理备份和应用数据的服务<br>BatteryService 管理电池的服务<br>BluetoothManagerService 管理系统蓝牙的服务<br>CertBlacklister 更新系统SSL证书的公共秘钥和序列号黑名单的服务<br>ClipboardService 管理系统剪贴板的服务<br>CommonTimeManagementService 管理公共时间配置的服务<br>ConnectivityService 管理网络连接的服务<br>ContentService 管理系统数据更新通知的服务，和ContentProvider密切相关<br>CountryDetectorService 检测当前系统所属国家的服务<br>DevicePolicyManagerService 管理系统设备配置的服务<br>DeviceStorageMonitorService 管理系统存储空间的服务，当存储空间小于某个阈值时，会发出警告广播<br>DiskStateService 管理系统存储空间统计的服务<br>DisplayManagerService 管理显示设备的服务<br>DreamManagerService 管理屏幕保护的服务<br>DropBoxManagerService 生成和管理系统运行中日志文件的服务<br>EntropyMixer 加载和保存随机信息的服务<br>IdleMaintenanceService 管理系统在空闲时执行维护任务的服务<br>InputManagerService 管理触屏输入的服务<br>InputMethodManagerService 管理系统输入法的服务<br>LightsService 管理光传感器的服务<br>LocationManagerService 管理定位和位置的服务<br>LockSettingsService 管理系统锁屏设置的服务<br>MountService 管理系统存储设备挂载和卸载的服务<br>NetWorkManagementService 管理系统网络的服务<br>NetWorkPolicyManagerService 管理网络连接策略的服务<br>NetWorkStatsService 管理网络连接状态的服务<br>NetWorkTimeUpdateService 根据网络时间更新本地时间的服务<br>NotificationManagerService 管理系统通知的服务<br>PackageManagerService 管理应用包的服务<br>PowerManagerService 管理系统电源的服务<br>PrintManagerService 管理打印的服务<br>RecognitionManagerService 管理身份识别的服务<br>SamplingProfilerService 记录和分析系统启动性能的服务<br>SchedulingPolicyService 管理系统调度策略的服务<br>SearchManagerServcie 管理系统搜索功能的服务<br>SerialServie 管理系统串口设备的服务<br>StatusBarManagerService 管理系统状态栏的服务<br>TelephonyRegistry 监听和管理通话事件和状态的服务<br>TextServicesManagerService 文本拼写检查的服务<br>UiModeManagerService 设置和管理系统UI模式的服务<br>UsbService 管理USB连接的服务<br>UserManagerService 管理系统用户身份信息的服务<br>VibratorService 管理系统振动器的服务<br>ＷallpaperManagerService 管理系统桌面背景墙纸的服务<br>WifiP2pService 管理Wifi点对点连接的服务<br>WifiService 管理系统Wifi设备的服务<br>WindowManagerService 管理窗口的服务，安卓系统的核心服务</p></blockquote><p>这些服务都会注册到Service Manager中去,完成ServcieManager对服务的管理</p><p>需要注意的是,由System Server创建的这些服务,都是存在于System Server进程中的线程</p><p>举例说明一下</p><blockquote><p>servicemanager是init的子进程</p><p>Zygote是init的子进程，fork出来所有的虚拟机</p><p>system server是Zygote的子进程</p></blockquote></li></ol><ol><li><p><strong>Home启动</strong></p><p>当所有的任务启动后,会通过ActivityManager启动Home界面</p><p>同时发送ACTION_BOOT_COMPLETED广播</p></li></ol>]]></content>
    
    
    <categories>
      
      <category>Source Code</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Android</tag>
      
      <tag>Source Code</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>JVM虚拟机中的类加载器</title>
    <link href="undefined2018/03/11/JVM-class-loader/"/>
    <url>2018/03/11/JVM-class-loader/</url>
    
    <content type="html"><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>前一篇梳理了一下类加载机制的大概流程,其中就涉及到一个很重要的东西<strong>类加载器</strong>,在加载阶段”通过一个类的全限定名获取描述此类的二进制字节流”</p><blockquote><p>我们知道二级制字节流不只是我们编写的代码</p><ol><li>可以从一些jar,war包等压缩文件中获取</li><li>已经凉了的Applet,也就是可以从网络中获取</li><li>运行时生成,如动态代理,retrofit中使用的技术之一</li><li>其他…</li></ol></blockquote><p>那么下面我要知道的是:</p><ol><li>类加载器的含义和作用</li><li>类加载器的类型</li><li>类加载器的应用</li></ol><a id="more"></a><h3 id="类加载器"><a href="#类加载器" class="headerlink" title="类加载器"></a>类加载器</h3><p>类加载器最初是为了Java Applet的需求而研发的,为了方便应用程序自己决定如何去获取所需要的类,而把这个操作放到了JAVA虚拟机外部去实现.</p><p>实现这个动作的代码模块被称为<code>类加载器</code></p><p>有一点需要注意的是,在JVM中,任意一个类都需要由类加载器和它本省共同确立其在JVM中的唯一性</p><p>每一个类加载器都拥有一个独立的类命名空间.</p><p>变现为:</p><blockquote><p> 如果同一个类,被不同的两个类加载器加载,那么它们就必然不相等.</p></blockquote><h3 id="类加载器的类型"><a href="#类加载器的类型" class="headerlink" title="类加载器的类型"></a>类加载器的类型</h3><ul><li>启动类加载器 Bootstrap ClassLoader ,是由C++实现的,作为虚拟机的一部分</li><li>其他类加载器,这些加载器都是由JAVA语言实现的,独立于JVM之外并且都是java.lang.ClassLoader的子类</li></ul><p>上面的分类是对于JVM而言的分类,在我们编码的过程中,对类加载器分为;</p><ol><li><p>启动类加载器 Bootstrap ClassLoader,</p><p>负责将<java_home>/lib 目录中的文件加载到虚拟机内存中</java_home></p></li><li><p>扩展类加载器 Extension ClassLoader</p><p>负责加载<java_home>/lib/ext 目录中的文件,或者被 java.ext.dirs系统变量指定的路径中文件</java_home></p><p>我们可以直接使用扩展类加载器</p></li><li><p>应用程序类加载器 Application ClassLoader </p><p>ClassLoader.getSystemClassLoader()方法可以返回,一般称为系统类加载器</p><p>负责加载用户路径中的类库,如果程序中没有使用自定义的类加载器,则默认是使用该类加载器的</p></li></ol><h4 id="双亲委派模型"><a href="#双亲委派模型" class="headerlink" title="双亲委派模型"></a>双亲委派模型</h4><p>#####模型结构</p><p><img src="/images/class_loader.png" srcset="/img/loading.gif" alt="classLoader"></p><p>//我们看看代码中是怎么组织的</p><pre><code class="java">protected Class&lt;?&gt; loadClass(String name, boolean resolve)        throws ClassNotFoundException    {            // First, check if the class has already been loaded            Class&lt;?&gt; c = findLoadedClass(name);            if (c == null) {                try {                    if (parent != null) {                        c = parent.loadClass(name, false);                    } else {                        c = findBootstrapClassOrNull(name);                    }                } catch (ClassNotFoundException e) {                    // ClassNotFoundException thrown if class not found                    // from the non-null parent class loader                }                if (c == null) {                    // If still not found, then invoke findClass in order                    // to find the class.                    c = findClass(name);                }            }            return c;    }</code></pre><p>上面的代码,总的来说有</p><ol><li><p><code>findLoadedClass(name)</code></p><p>查找是否已经加载过这个class了,如果不为空就直接返回了这个class</p></li><li><p>在看下一步</p><pre><code class="java"> try {      if (parent != null) {          c = parent.loadClass(name, false);      } else {          c = findBootstrapClassOrNull(name);      } }</code></pre><p>如果父加载器 <code>parent</code>不为空,则加载工作交给父加载器去执行,</p><p>而这个父加载器也会有它的父加载器</p></li><li><p>最后如果这个class还没有加载</p><pre><code class="java">if (c == null) {    // If still not found, then invoke findClass in order    // to find the class.    c = findClass(name);}</code></pre><p>才轮到自己去加载</p></li></ol><p><img src="/images/class_process.png" srcset="/img/loading.gif" alt="加载过程"></p><blockquote><p> 要注意的是,这些类加载器的父子关系,不是由继承来实现的,而是使用组合</p></blockquote><h5 id="模型加载流程"><a href="#模型加载流程" class="headerlink" title="模型加载流程"></a>模型加载流程</h5><p>类加载器收到了一个类加载的请求,但是不会立马去自己加载,而是委派给父加载器去尝试加载,然后层层委派直到顶层的启动类加载器中.如果没有成功加载,子加载器才会自己去加载.</p><p>这样做是有明显的好处的:</p><ol><li>这些类加载器都具有了优先级关系</li><li>保证了某些类的一致性,如Object,通过委派,最终都是由最顶层的启动类加载器完成加载的.</li></ol><h3 id="类加载器的应用"><a href="#类加载器的应用" class="headerlink" title="类加载器的应用"></a>类加载器的应用</h3><p>先来看一个例子,加深一下理解</p><pre><code class="java">//一个类,需要放在项目目录外,避免被系统类加载器加载public class TestClassLoader{    public void createBy(){        System.out.println(&quot;I&#39;m Batman , Come from &quot; +                  getClass().getClassLoader().getClass());    }}</code></pre><p>自定义的类加载器</p><pre><code class="java">import java.io.FileInputStream;//自定义的类加载器public class MarvelStudios extends ClassLoader {    //存放的是TestClassLoader.class的位置,记得先编译成class再使用    private final static String CLASS_FILE_PATH =            &quot;/Users/phyooos/workspace/java_workspace/kotlind/soucre/TestClassLoader.class&quot;;    private byte[] loadByte(String name) throws Exception {        FileInputStream fis = new FileInputStream(CLASS_FILE_PATH);        int len = fis.available();        byte[] data = new byte[len];        fis.read(data);        fis.close();        return data;    }    @Override    protected Class&lt;?&gt; findClass(String name) throws ClassNotFoundException {        //这里获取文件        try {            byte[] data = loadByte(name);            return defineClass(name, data, 0, data.length);        } catch (Exception e) {            e.printStackTrace();            throw new ClassNotFoundException();        }    }}</code></pre><p>测试一下</p><pre><code class="java">public class MainClass {    public static void main(String[] args){        MarvelStudios classLoader = new MarvelStudios();        Class clazz = null;        try {            clazz = classLoader.loadClass(&quot;TestClassLoader&quot;);            Object obj = clazz.newInstance();            Method createMethod = clazz.getDeclaredMethod(&quot;createBy&quot;,null);            createMethod.invoke(obj, null);        } catch (Exception e) {            e.printStackTrace();        }    }}</code></pre><p>运行结果为</p><pre><code class="java">I&#39;m Batman , Come from class MarvelStudiosProcess finished with exit code 0</code></pre><p>这里显而易见,使用了自定义的类加载器,从硬盘上加载了一个class文件,如果你想加载一个java文件,也只需要调用</p><pre><code class="java">//defineClass方法可以把二进制流字节组成的文件转换为一个java.lang.ClassClass&lt;?&gt; c = this.defineClass(name, bytes, 0, bytes.length);</code></pre><p>这只是一个简单的自定义类加载器使用,可以从硬盘上加载java代码.</p><p>其他如:</p><ul><li>代码加密</li><li>热部署</li><li>热修复</li></ul>]]></content>
    
    
    <categories>
      
      <category>Java</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Java</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>JVM虚拟机的类加载机制</title>
    <link href="undefined2018/03/10/JVM-load-class/"/>
    <url>2018/03/10/JVM-load-class/</url>
    
    <content type="html"><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>关于JVM虚拟机的类加载机制,大概有如下的几个问题</p><ol><li>类加载机制是什么?</li><li>类加载的流程</li></ol><a id="more"></a><h3 id="类加载机制"><a href="#类加载机制" class="headerlink" title="类加载机制"></a>类加载机制</h3><p>我们所写的Java代码,最终都是编译成class字节码文件,这些字节码文件描述了各种信息</p><p>需要加载到虚拟机中才能使用运行</p><p>而虚拟机啊把描述类的数据从Class文件中加载到内存,并且对数据进行校验,转换解析和初始化,</p><p>最终形成可以被虚拟机直接使用的Java类型,这就是虚拟机的类加载机制.</p><h3 id="类加载机制的流程"><a href="#类加载机制的流程" class="headerlink" title="类加载机制的流程"></a>类加载机制的流程</h3><p>虚拟机中类加载的全过程: 加载 , 验证 ,准备 , 解析 , 初始化这五个部分</p><h4 id="加载"><a href="#加载" class="headerlink" title="加载"></a>加载</h4><p>在加载阶段,完成的是:</p><ol><li>通过类的全限定名(import  <em>*</em> 这些)来获取定义此类的二进制字节流.</li><li>将这个二进制字节流的静态存储结构转化为方法区的运行时数据结构.</li><li>在内存中生成一个代表这个类的java.lang.Class对象,作为方法区这个类的各种数据的访问入口.</li></ol><p>当我们的虚拟机将二进制字节流文件加载后,会存放在方法区中,而后实例化一个Class类的对象,(对于HotSpot虚拟机而言)会放在方法区中,而不是一般存放对象,引用类型的堆(heap)中,这个Class对象就可以作为程序访问方法区中这些类型数据的外部接口.</p><p>PS:加载的过程中,也可能会伴随着 连接过程(检查,准备,解析),但是必然是先发生加载,而后才可能出现连接</p><h4 id="验证"><a href="#验证" class="headerlink" title="验证"></a>验证</h4><p>验证这个阶段非常的重要</p><p>我们知道在JAVA代码中,是无法进行一些不安全的操作的,但是class字节码文件却可以做到,类似数组越界访问,跳转到不存在的代码行….</p><p>那么,验证就非常重要了,直接决定了Java虚拟机的安全性.</p><p>大概包含:</p><h5 id="文件格式验证"><a href="#文件格式验证" class="headerlink" title="文件格式验证"></a>文件格式验证</h5><p>只有通过了文件格式验证,字节码二进制流才会进入到方法区中.</p><p>比如: 魔数CAFEBABE ,主次版本号,常量池中常量类型,编码等等…</p><p>#####元数据验证</p><p>主要目的是对类的元数据进行语义检验,确保描述信息符合JAVA的语言规范</p><p>比如:是否有父类,是否实现了所继承类或实现接口的必要方法,返回值类型…</p><p>#####字节码验证</p><p>在元数据验证对元数据中的数据类型做完检测后,这个阶段会对类的方法体进行校验分析,保证被验证的类方法不会在运行时对虚拟机做出不安全操作.</p><h5 id="符号引用验证"><a href="#符号引用验证" class="headerlink" title="符号引用验证"></a>符号引用验证</h5><p>发生在虚拟机将符号引用转化为直接引用的时候,这个转化的操作将发生在-解析阶段.</p><blockquote><p><strong>符号引用</strong>:符号引用以一组符号来描述所引用的目标，符号可以是任何形式的字面量，只要使用时能够无歧义的定位到目标即可。在编译时，java类并不知道所引用的类的实际地址，因此只能使用符号引用来代替。</p><p><strong>直接引用</strong>:如果有了直接引用，那引用的目标必定已经被加载入内存中了.直接引用有:1直接指向目标的指针</p><p>2.相对偏移量3.一个能间接定位到目标的句柄</p></blockquote><p>####准备</p><p>准备阶段是正式为变量分配内存并设置类变量初始值的阶段,这些变量的内存都将在方法区进行分配.</p><blockquote><p>类变量:被static修饰的变量,这里还有一个要注意的就是final修饰的,这是一种特殊情况,会在准备阶段就初始化为指定的值.(在字段属性表中表现为ConstantValue属性)</p><p>而不是像通常情况下,会给静态变量赋零值.</p></blockquote><h4 id="解析"><a href="#解析" class="headerlink" title="解析"></a>解析</h4><p>在符号引用验证中提到过,这个阶段是虚拟机将常量池内的符号引用替换为直接引用的过程.</p><p>解析的操作一般针对类,接口,字段,类方法,接口方法,方法类型,方法句柄和调用点限定符7类符号引用</p><p>大概分为: <strong>类或者接口的解析</strong>,<strong>字段解析</strong>,<strong>类方法解析</strong>,<strong>接口方法解析</strong></p><h4 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h4><p>初始化是类加载的最后一个阶段,之前的阶段,除了在加载阶段可以通过自定义类加载器参与之外,其他的都是由虚拟机主导和控制.而到了初始化阶段,才真正开始执行类中定义的JAVA代码,这个阶段根据代码中定义好的计划去初始化类变量和其他资源.</p><p>初始化阶段是执行类构造器<code>&lt;client&gt;()</code>方法的过程.</p>]]></content>
    
    
    <categories>
      
      <category>Java</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Java</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Android通讯机制分析-Handler</title>
    <link href="undefined2018/03/07/Handler-analyze/"/>
    <url>2018/03/07/Handler-analyze/</url>
    
    <content type="html"><![CDATA[<p>Handler在Android世界中的地位不言而喻.这篇笔记算是简单的记录一下我对于Handler的理解.</p><p>当时第一次对Handler产生兴趣是我在知乎上看到一个问题:</p><p><strong>Android中为什么主线程不会因为Looper.loop()里的死循环卡死</strong></p><a id="more"></a><h4 id="Handler消息机制的构成"><a href="#Handler消息机制的构成" class="headerlink" title="Handler消息机制的构成"></a>Handler消息机制的构成</h4><ul><li><p>Handler</p><p>主要就是发送各种消息<code>sendMessage</code>等,以及处理消息<code>handleMessage</code></p></li><li><p>Message</p><p>即是传递消息的载体,有时候也会承载硬件发出的消息.</p></li><li><p>Looper</p><p>这是一个循环<code>Looper.loop</code>,并负责将消息发送给目标.</p></li><li><p>MessageQueue</p><p>消息队负责将消息发送都消息池以及在消息池中拿走消息</p></li></ul><p><img src="/images/handler_class.png" srcset="/img/loading.gif" alt="handler"></p><h4 id="Message类分析"><a href="#Message类分析" class="headerlink" title="Message类分析"></a>Message类分析</h4><p>首先我们要看到</p><pre><code>private static Message sPool;// sometimes we store linked lists of these things/*package*/ Message next;</code></pre><p><code>sPool</code>声明为static 也就是说所有的Message实例共享</p><p><code>next</code>则为每一个实例都有的</p><p>Message类中,一系列的obtain,如下:</p><p>obtain(Handler h)</p><p>obtain(Handler h, int what)</p><p>obtain(Handler h, Runnable callback)</p><p>…</p><p>obtain()</p><ul><li><p>复用机制</p><p>我们查看源码可知,他们最后都调用obtain()获得一个Message实体</p></li></ul><pre><code class="java">    android.os.Message#obtain()    /**     * Return a new Message instance from the global pool. Allows us to     * avoid allocating new objects in many cases.     */    public static Message obtain() {        synchronized (sPoolSync) {            if (sPool != null) {                Message m = sPool;                sPool = m.next;                m.next = null;                m.flags = 0; // clear in-use flag                sPoolSize--;                return m;            }        }        return new Message();    }</code></pre><p>可以看到,当<code>sPool</code>为<code>null</code>时才会<code>new Message();</code></p><p>如果不为<code>null</code>则把当前的<code>sPool</code>赋值给<code>Message m</code>  而后把<code>sPool</code>赋值为<code>m.next()</code>(也就是sPool没有赋值前它的下一个Message对象)</p><p>查看源码分析可知,有一个Message的消息池,采用的是单链表头插法,next永远指向的是下一个可复用的实例地址</p><p>所以,如果我们在代码中要使用Message实例,就尽量使用<code>obtain()</code>这一系列方法,而不要直接New</p><ul><li><p>加入消息池</p><pre><code class="java">    android.os.Message#recycleUnchecked    /**     * Recycles a Message that may be in-use.     * Used internally by the MessageQueue and Looper when disposing of queued Messages.     */    void recycleUnchecked() {        // Mark the message as in use while it remains in the recycled object pool.        // Clear out all other details.        flags = FLAG_IN_USE;        what = 0;        arg1 = 0;        arg2 = 0;        obj = null;        replyTo = null;        sendingUid = -1;        when = 0;        target = null;        callback = null;        data = null;        synchronized (sPoolSync) {            if (sPoolSize &lt; MAX_POOL_SIZE) {                next = sPool;                sPool = this;                sPoolSize++;            }        }    }</code></pre><p>这里其实就是把无用的Message实例,加入消息池的地方.</p><p><code>sPoolSize &lt; MAX_POOL_SIZE</code>只要当前消息池没有到极限,就<code>next = sPool;</code>且<code>sPool = this;</code></p><p>可以简单理解为把之前的<code>sPool</code>可复用对象向后移动一位,把当前这个要回收的Message置为第一个可复用对象</p></li></ul><p><strong>所以,Message主要就是装载数据,并且实现了Message的复用机制</strong></p><h4 id="MessageQueue类分析"><a href="#MessageQueue类分析" class="headerlink" title="MessageQueue类分析"></a>MessageQueue类分析</h4>]]></content>
    
    
    <categories>
      
      <category>Source Code</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Android</tag>
      
      <tag>Source Code</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>RelativeLayout中Button覆盖其他View</title>
    <link href="undefined2018/03/07/RelativeLayout-Button-over/"/>
    <url>2018/03/07/RelativeLayout-Button-over/</url>
    
    <content type="html"><![CDATA[<h4 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h4><p>布局文件中,RelativeLayout包裹时,在RelativeLayout中的View,应该是”层层压上”的.</p><p>越往底下写的Viwe,在视图上越在上层.</p><a id="more"></a><h4 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h4><h5 id="activity-main-xml"><a href="#activity-main-xml" class="headerlink" title="activity_main.xml"></a><em>activity_main.xml</em></h5><pre><code>&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;&lt;layout    xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;    xmlns:app=&quot;http://schemas.android.com/apk/res-auto&quot;    xmlns:tools=&quot;http://schemas.android.com/tools&quot;&gt;    &lt;data&gt;        &lt;variable            name=&quot;click&quot;            type=&quot;com.wangzhumo.app.single.MainActivity.ClickFunc&quot;/&gt;    &lt;/data&gt;    &lt;RelativeLayout        android:layout_width=&quot;match_parent&quot;        android:layout_height=&quot;match_parent&quot;        tools:context=&quot;com.wangzhumo.app.single.MainActivity&quot;&gt;        &lt;ImageView            android:layout_width=&quot;match_parent&quot;            android:layout_height=&quot;match_parent&quot;            android:layout_marginBottom=&quot;50dp&quot;            tools:background=&quot;@tools:sample/backgrounds/scenic&quot;/&gt;        &lt;Button            android:id=&quot;@+id/button_finsh&quot;            android:layout_width=&quot;wrap_content&quot;            android:layout_height=&quot;wrap_content&quot;            android:layout_alignParentTop=&quot;true&quot;            android:layout_centerHorizontal=&quot;true&quot;            android:onClick=&quot;@{(v) -&gt; click.onFinshAct(v)}&quot;            android:text=&quot;Finsh&quot; /&gt;        &lt;Button            android:id=&quot;@+id/button_dis&quot;            android:layout_width=&quot;wrap_content&quot;            android:layout_height=&quot;wrap_content&quot;            android:layout_alignParentEnd=&quot;true&quot;            android:layout_alignParentTop=&quot;true&quot;            android:onClick=&quot;@{(v) -&gt; click.onStartAct(v)}&quot;            android:text=&quot;Start&quot;            tools:ignore=&quot;MissingConstraints&quot;            tools:layout_editor_absoluteX=&quot;88dp&quot;            tools:layout_editor_absoluteY=&quot;0dp&quot; /&gt;        &lt;Button            android:id=&quot;@+id/button_start&quot;            android:layout_width=&quot;wrap_content&quot;            android:layout_height=&quot;wrap_content&quot;            android:onClick=&quot;@{(v) -&gt; click.onShowDialog(v)}&quot;            android:text=&quot;Dialog&quot;            tools:ignore=&quot;MissingConstraints&quot;            tools:layout_editor_absoluteX=&quot;176dp&quot;            tools:layout_editor_absoluteY=&quot;0dp&quot; /&gt;        &lt;Button            android:id=&quot;@+id/button2&quot;            android:layout_width=&quot;wrap_content&quot;            android:layout_height=&quot;wrap_content&quot;            android:layout_alignParentStart=&quot;true&quot;            android:onClick=&quot;@{(v) -&gt; click.onPxActivity(v)}&quot;            android:layout_below=&quot;@+id/button_start&quot;            android:layout_marginTop=&quot;22dp&quot;            android:text=&quot;Pixe&quot; /&gt;        &lt;Button            android:id=&quot;@+id/button3&quot;            android:layout_width=&quot;wrap_content&quot;            android:layout_height=&quot;wrap_content&quot;            android:onClick=&quot;@{(v) -&gt; click.onTralActivity(v)}&quot;            android:layout_alignStart=&quot;@+id/button_finsh&quot;            android:layout_alignTop=&quot;@+id/button2&quot;            android:text=&quot;Tranl&quot;            tools:text=&quot;@tools:sample/lorem/random&quot;/&gt;        &lt;ImageView            android:layout_marginBottom=&quot;100dp&quot;            android:layout_width=&quot;match_parent&quot;            android:layout_height=&quot;match_parent&quot;            tools:background=&quot;@tools:sample/backgrounds/scenic&quot;/&gt;    &lt;/RelativeLayout&gt;&lt;/layout&gt;</code></pre><h5 id="View的结构如下"><a href="#View的结构如下" class="headerlink" title="View的结构如下:"></a>View的结构如下:</h5><p><img src="/images/button_tree.png" srcset="/img/loading.gif" alt="tree"></p><h5 id="然而实际效果如下"><a href="#然而实际效果如下" class="headerlink" title="然而实际效果如下:"></a>然而实际效果如下:</h5><p><img src="/images/button_show.png" srcset="/img/loading.gif" alt="views"></p><h5 id="分析如下"><a href="#分析如下" class="headerlink" title="分析如下:"></a>分析如下:</h5><p>造成这样效果,是Button的原因</p><p>分析:整个页面除了 2,3,4,5 这5个Button之外,其他的View都依旧遵循RelativeLayout的规则</p><h4 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h4><p>在stackoverflow上我找到了Button造成这个效果的原因</p><blockquote><p><a href="https://stackoverflow.com/questions/27080338/android-5-0-androidelevation-works-for-view-but-not-button/27112143#27112143" target="_blank" rel="noopener">https://stackoverflow.com/questions/27080338/android-5-0-androidelevation-works-for-view-but-not-button/27112143#27112143</a></p></blockquote><p>是因为Android5.0之后,Button默认添加了<a href="https://developer.android.com/reference/android/animation/StateListAnimator.html" target="_blank" rel="noopener">StateListAnimator</a>,具体就是对</p><p> <code>android:elevation</code> </p><p> <code>android:translationZ</code> </p><p>两个属性进行了修改,我们如何去掉这个默认的效果那?</p><p>##### </p><p><strong>android:stateListAnimator设置为null即可</strong></p><pre><code>&lt;Button    ...    android:stateListAnimator=&quot;@null&quot; /&gt;</code></pre><p>如果你需要添加stateListAnimator效果的话</p><pre><code>&lt;Button    ...    android:stateListAnimator=&quot;@anim/you_animator&quot; /&gt;</code></pre>]]></content>
    
    
    <categories>
      
      <category>Bug</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Android</tag>
      
      <tag>Bug</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>ConfigChanges的属性值</title>
    <link href="undefined2018/03/05/ConfigChanges/"/>
    <url>2018/03/05/ConfigChanges/</url>
    
    <content type="html"><![CDATA[<p><strong>通过设置这个属性可以使Activity捕捉设备状态变化</strong></p><pre><code>&quot;mcc&quot; 国际移动用户识别码所属国家代号是改变了----- sim被侦测到了，去更新mcc mcc是移动用户所属国家代号&quot;mnc&quot; 国际移动用户识别码的移动网号码是改变了------ sim被侦测到了，去更新mnc MNC是移动网号码，最多由两位数字组成，用于识别移动用户所归属的移动通信网&quot;locale&quot; 地址改变了-----用户选择了一个新的语言会显示出来&quot;touchscreen&quot; 触摸屏是改变了------通常是不会发生的&quot;keyboard&quot; 键盘发生了改变----例如用户用了外部的键盘&quot;keyboardHidden&quot; 键盘的可用性发生了改变&quot;navigation&quot; 导航发生了变化-----通常也不会发生&quot;screenLayout&quot; 屏幕的显示发生了变化------不同的显示被激活&quot;fontScale&quot; 字体比例发生了变化----选择了不同的全局字体&quot;uiMode&quot; 用户的模式发生了变化&quot;orientation&quot; 屏幕方向改变了&quot;screenSize&quot; 屏幕大小改变了&quot;smallestScreenSize&quot; 屏幕的物理大小改变了，如：连接到一个外部的屏幕上</code></pre><blockquote><p><a href="http://www.cnblogs.com/carlo/p/4311010.html" target="_blank" rel="noopener">http://www.cnblogs.com/carlo/p/4311010.html</a></p></blockquote>]]></content>
    
    
    <categories>
      
      <category>Android</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Android</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Activity与Fragment的生命周期</title>
    <link href="undefined2018/03/05/Activity-Fragment-life/"/>
    <url>2018/03/05/Activity-Fragment-life/</url>
    
    <content type="html"><![CDATA[<h4 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h4><p>做Android开发好些年了,这些基础的知识,完完整整的在博客上写一次.</p><h4 id="Activity生命周期"><a href="#Activity生命周期" class="headerlink" title="Activity生命周期"></a>Activity生命周期</h4><p>必不可少的一张图,来自Google Android developer 的文档上</p><p><img src="/images/activity_lifecycle.png" srcset="/img/loading.gif" alt="activity_liferycle"></p><a id="more"></a><h5 id="回调方法简述"><a href="#回调方法简述" class="headerlink" title="回调方法简述"></a>回调方法简述</h5><ul><li><p>onCreate()  </p><p>当Activity创建时,会回调该方法,常用于初始化View 或其他的一些功能的初始化</p></li><li><p>onStart()</p><p>Activity已经初始化完毕,此时的页面是可见状态,则回调onStart();方法</p><p>Activity启动：onCreate() -&gt; onStart() -&gt; onResume()</p></li><li><p>onResume()</p><p>当Activity可见,并且获得焦点,可以与用户交互时回调</p><p>在我们处理一些视屏操作,或者是Fragment懒加载等都可以用到</p></li><li><p>onPause()</p><p>当调用onPause()时,说明Activity被阻挡,部分UI已经不可见了,但是Activity的UI并没有完全消失.</p></li><li><p>onStop()</p><p>当Activity完全不可见,且到了后台之后,如果系统内存不足,系统可能会杀死当前Activity</p><p>在这个方法中可以取消一些动画效果等</p></li><li><p>onDestory()</p><p>Activity退出,销毁</p><p>常用于销毁,回收资源</p></li></ul><h5 id="经典场景"><a href="#经典场景" class="headerlink" title="经典场景"></a>经典场景</h5><p>1.正常启动</p><p>系统调用onCreate方法 , 然后调用onStart() , 最后调用 onResume() ,用户可操作.</p><pre><code>E/MainActivity: ---- onCreate ----E/MainActivity: ---- onStart ----E/MainActivity: ---- onResume ----</code></pre><p>2.正常退出</p><p>Activity先失去焦点不可交互</p><pre><code>E/MainActivity: ---- onPause ----E/MainActivity: ---- onStop ----E/MainActivity: ---- onDestroy ----</code></pre><p>2.弹出Dialog</p><p>MainActivity什么log也没有打印,说明不对Activity造成影响</p><p>3.跳转一个透明的Activity页面(1像素的同理)</p><p>MainActivity只调用了onPause()  因为MainActivity的UI被遮挡了</p><pre><code>E/MainActivity: ---- onPause ----</code></pre><p>4.从被遮挡状态恢复</p><pre><code>E/MainActivity: ---- onResume ----</code></pre><p>6.锁屏</p><pre><code>E/MainActivity: ---- onPause ----E/MainActivity: ---- onStop ----</code></pre><p>此时,MainActivity已经在后台了.</p><p>7.从锁屏恢复</p><pre><code>E/MainActivity: ---- onStart ----E/MainActivity: ---- onResume ----</code></pre><p>可以发现,不仅仅走了onResume() ,还走了一次onStart()</p><p>8.横竖屏切换</p><ul><li><p>正常切换</p><pre><code>E/MainActivity: ---- onPause ----E/MainActivity: ---- onStop ----E/MainActivity: ---- onDestroy ----E/MainActivity: ---- onCreate ----E/MainActivity: ---- onStart ----E/MainActivity: ---- onResume ----如果你什么都不设置,直接切换是这样的.</code></pre></li></ul><ul><li><p>保留Activity的切换</p><pre><code> 我在manifest.xml文件中,添加了 &lt;activity     android:name=&quot;.MainActivity&quot;     android:configChanges=&quot;orientation|screenSize&quot;&gt;     &lt;intent-filter&gt;         &lt;action android:name=&quot;android.intent.action.MAIN&quot; /&gt;        &lt;category android:name=&quot;android.intent.category.LAUNCHER&quot; /&gt;    &lt;/intent-filter&gt; &lt;/activity&gt;</code></pre><p>此时:</p><p>Activity不会被销毁,从而重新创建,而是调用onConfigurationChanged</p><pre><code>@Override  public void onConfigurationChanged(Configuration newConfig) {     super.onConfigurationChanged(newConfig);     //do somethings}</code></pre></li></ul><h4 id="Fragment生命周期"><a href="#Fragment生命周期" class="headerlink" title="Fragment生命周期"></a>Fragment生命周期</h4><p>惯例,如图:</p><p><img src="/images/fragment_lifercycle.png" srcset="/img/loading.gif" alt="fragment_lifecycle"></p><h5 id="回调方法简述-1"><a href="#回调方法简述-1" class="headerlink" title="回调方法简述"></a>回调方法简述</h5><p>其中onAttach()  onCreateView() onActivityCreated()  onDestroy() onDetach() 和Activity的不一致</p><ul><li><p>onAttach()</p><p>Fragment与它所依赖的Activity建立关联</p></li><li><p>onCreateView()</p><p>这里是给Fragment创建视图用的,在onCreate()中初始化Fragment,但是视图等还是没有加载上去的</p></li><li><p>onActivityCreated()</p><p>如果调用该方法,说明Fragment依赖的Activity中onCreate()已经执行完毕</p></li><li><p>onDestroyView()</p><p>Fragment中的布局销毁,移除</p><p>要注意的是,此时Fragment与它所依赖的Activity还是关联的</p></li><li><p>onDestroy()</p><p>此时,Fragment被销毁</p></li><li><p>onDetach()</p><p>解除与Activity的关联</p></li></ul><p>PS: Fragment中的onResume()并不十分准确,所以如果要做懒加载,要判断fragment不能使用onResume判断</p><h5 id="经典场景-1"><a href="#经典场景-1" class="headerlink" title="经典场景"></a>经典场景</h5><p>1.正常启动</p><p>真的是超级多啊</p><pre><code>E/BlankFragment: ---- onAttach ----               关联ActivityE/BlankFragment: ---- onCreate ----                Fragment初始化E/BlankFragment: ---- onCreateView ----            创建Fragment的布局E/BlankFragment: ---- onViewCreated ----        onCreateView执行完后被触发E/BlankFragment: ---- onActivityCreated ----    关联的Activity OnCreate()执行完毕后触发E/BlankFragment: ---- onStart ----                Fragment可见E/BlankFragment: ---- onResume ----                Fragment可交互,一般不使用它来判断</code></pre><p>2.正常退出(或者是它关联的Activity被销毁了)</p><pre><code>E/BlankFragment: ---- onPause ----E/BlankFragment: ---- onStop ----E/BlankFragment: ---- onDestroyView ----E/BlankFragment: ---- onDestroy ----E/BlankFragment: ---- onDetach ----</code></pre><p>3.进入后台</p><pre><code>E/BlankFragment: ---- onPause ----E/BlankFragment: ---- onStop ----</code></pre><p>4.从锁屏到解锁</p><pre><code>E/BlankFragment: ---- onPause ----E/BlankFragment: ---- onSaveInstanceState ----E/BlankFragment: ---- onStop ----E/BlankFragment: ---- onStart ----E/BlankFragment: ---- onResume ----</code></pre><p>5.切换到OtherFragment</p><pre><code>E/BlankFragment: ---- onPause ----E/BlankFragment: ---- onStop ----E/BlankFragment: ---- onDestroyView ----</code></pre><p>6.从OtherFragment切换回本Fragment</p><pre><code>E/BlankFragment: ---- onCreateView ----E/BlankFragment: ---- onActivityCreated ----E/BlankFragment: ---- onStart ----   E/BlankFragment: ---- onResume ----</code></pre>]]></content>
    
    
    <categories>
      
      <category>Android</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Android</tag>
      
      <tag>Fragment</tag>
      
      <tag>Activity</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Flutter安装指南MAC版</title>
    <link href="undefined2018/02/28/Flutter-Install-MAC/"/>
    <url>2018/02/28/Flutter-Install-MAC/</url>
    
    <content type="html"><![CDATA[<h4 id="下载Flutter-SDK"><a href="#下载Flutter-SDK" class="headerlink" title="下载Flutter SDK"></a>下载Flutter SDK</h4><h5 id="使用Git安装"><a href="#使用Git安装" class="headerlink" title="使用Git安装"></a>使用Git安装</h5><p>如果已经下载过flutter的,切换到flutter目录去直接</p><pre><code>git checkout betagit pull//可能会失败,因为这个目录中可能有修改过,要目放弃修改,要么暂存均可(如果失败,这里选择了暂存) -- Startgit checkout betagit stashgit pull(如果失败,这里选择了暂存)  -- End</code></pre><p>未下载过,第一次安装</p><pre><code>//克隆flutter的beta分支git clone -b beta https://github.com/flutter/flutter.git</code></pre><a id="more"></a><h5 id="配置”环境变量”"><a href="#配置”环境变量”" class="headerlink" title="配置”环境变量”"></a>配置”环境变量”</h5><p>熟悉命令的自己搞一下</p><pre><code>//把         安装目录/flutter/binexport PATH=`pwd`/flutter/bin:$PATH</code></pre><p>不熟悉的</p><pre><code>~ ⌚ 0:01:37$ vim ~/.bash_profile//会进入vim编辑,如下配置即可export FLUTTER_HOME=/Users/phyooos/develop/flutterexport PATH=$PATH:$FLUTTER_HOME/bin:</code></pre><p>不会的</p><pre><code>open ~/.bash_profile//编辑器,总可以了吧,如下配置即可export FLUTTER_HOME=/Users/phyooos/develop/flutterexport PATH=$PATH:$FLUTTER_HOME/bin:</code></pre><p>放一下我自己的配置:</p><pre><code>export JAVA_HOME=/Library/Java/JavaVirtualMachines/jdk1.8.0/Contents/Homeexport ANDROID_HOME=/Users/phyooos/Library/Android/sdkexport TOMCAT_HOME=/Users/phyooos/develop/apache-tomcat-7.0.77export GRADLE_USER_HOME=/Users/phyooos/develop/gradleexport MYSQL_HOME=/usr/local/mysql-5.7.18-macos10.12-x86_64export GOROOT=/usr/local/goexport GOPATH=/Users/phyooos/develop/workspaceexport GOBIN=$GOPATH/binexport SCALA_HOME=/Users/phyooos/develop/scala-2.11.8export MAVEN_HOME=/Users/phyooos/develop/apache-maven-3.5.0export FLUTTER_HOME=/Users/phyooos/develop/flutterexport PATH=/usr/local/Cellar/git/2.15.0/bin:$PATH:$JAVA_HOME/bin:$ANDROID_HOME/tools:$ANDROID_HOME/platform-tools:$TOMCAT_HOME/bin:$GRADLE_HOME/bin:$MYSQL_HOME/bin:$GOROOT/bin:$GOPATH:$GOBIN:$GOPATH/bin:$FLUTTER_HOME/bin:$MAVEN_HOME/bin:$SCALA_HOME/bin</code></pre><h4 id="安装Flutter"><a href="#安装Flutter" class="headerlink" title="安装Flutter"></a>安装Flutter</h4><pre><code>flutter doctor</code></pre><blockquote><p>这里要注意的是,这个配置需要”良好的网络环境”,最好翻墙下载为妙,但是<strong>终端不走代理</strong></p><p>所以,需要手动给终端配置一下,请看我另一篇文章</p><p><a href="http://www.wangzhumo.com/Flutter/Flutter-%E5%AE%89%E8%A3%85/">Flutter 安装</a></p></blockquote>]]></content>
    
    
    <categories>
      
      <category>Flutter</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Flutter</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Android Studio 中使用tools:sample</title>
    <link href="undefined2018/02/26/Android-Studio-tools-sample/"/>
    <url>2018/02/26/Android-Studio-tools-sample/</url>
    
    <content type="html"><![CDATA[<blockquote><p>Google 官方文档</p><p><a href="https://developer.android.com/studio/write/tool-attributes.html#toolssample_resources" target="_blank" rel="noopener">https://developer.android.com/studio/write/tool-attributes.html#toolssample_resources</a></p></blockquote><p>他所能达到的效果就是,提供给你一些数据,并直接在 Preview 或者 Design面板中查看样式</p><a id="more"></a><h4 id="效果"><a href="#效果" class="headerlink" title="效果"></a>效果</h4><p>不如放一个图来的直观</p><p>item中使用 sample资源</p><p><img src="/images/tools_item.png" srcset="/img/loading.gif" alt="item"></p><p>将item加入到list中查看效果</p><p><img src="/images/tools_list.png" srcset="/img/loading.gif" alt="list"></p><h4 id="准备使用tools"><a href="#准备使用tools" class="headerlink" title="准备使用tools"></a>准备使用tools</h4><h5 id="Android-Studio"><a href="#Android-Studio" class="headerlink" title="Android Studio"></a>Android Studio</h5><p>注意要使用Android Studio 3.0 + 的版本</p><h5 id="命名空间"><a href="#命名空间" class="headerlink" title="命名空间"></a>命名空间</h5><p><code>xmlns:tools=&quot;http://schemas.android.com/tools&quot;</code></p><p>然后就可以使用tools的相关属性了</p><p>在google文档中我们可以看到有很多其他可用的,具体使用效果请自行查阅文档.</p><p>如:</p><p><strong>context</strong>   <strong>showIn</strong>  <strong>layout</strong>   <strong>listitem</strong>   <strong>layoutManager</strong>     <strong>itemCount</strong></p><p>使用方式为:</p><pre><code class="xml">&lt;layout    xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;    xmlns:tools=&quot;http://schemas.android.com/tools&quot;&gt;    &lt;RelativeLayout        android:layout_width=&quot;match_parent&quot;        android:layout_height=&quot;match_parent&quot;        tools:context=&quot;com.wangzhumo.app.tips.page.NearbyFragment&quot;&gt;        &lt;com.jcodecraeer.xrecyclerview.XRecyclerView            android:id=&quot;@+id/recycleview&quot;            android:layout_width=&quot;match_parent&quot;            android:layout_height=&quot;match_parent&quot;            tools:layoutManager=&quot;GridLayoutManager&quot;            tools:itemCount=&quot;5&quot;            tools:spanCount=&quot;2&quot;            tools:listitem=&quot;@layout/nearby_list_item&quot;&gt;        &lt;/com.jcodecraeer.xrecyclerview.XRecyclerView&gt;    &lt;/RelativeLayout&gt;&lt;/layout&gt;</code></pre><h4 id="可用资源"><a href="#可用资源" class="headerlink" title="可用资源"></a>可用资源</h4><h5 id="google已提供的资源"><a href="#google已提供的资源" class="headerlink" title="google已提供的资源"></a>google已提供的资源</h5><p><img src="/images/tools_google.png" srcset="/img/loading.gif" alt="google"></p><p>这些资源可以在xml中直接使用,也可以在自定义的资源中使用</p><p>使用方式为:</p><pre><code class="xml">&lt;!-- 这里面的资源在Android Studio/Applications/Android Studio.app/Contents/plugins/android/lib/sampleData/backgrounds/scenic--&gt;&lt;ImageView    ...    tools:src=&quot;@tools:sample/backgrounds/scenic&quot;&gt;&lt;/ImageView&gt;    &lt;!-- 这个是一段假文章 --&gt;&lt;TextView    ...          tools:text=&quot;@tools:sample/lorem/random&quot;/&gt;&lt;/TextView&gt;</code></pre><h5 id="自定义的资源"><a href="#自定义的资源" class="headerlink" title="自定义的资源"></a>自定义的资源</h5><p><img src="/images/tools_new.png" srcset="/img/loading.gif" alt="new"></p><p>创建一个 sampledata 文件夹</p><p><img src="/images/tools_files.png" srcset="/img/loading.gif" alt="file"></p><ul><li><p><code>sampledata/images</code> 文件中都是些图片资源</p></li><li><p><code>description</code>文件中是描述性文字, 注意<strong>每一行为一项个元素</strong></p></li><li><p><code>hotels</code> 也是一些文字,不过是一些酒店名字</p></li><li><p><code>hotel.json</code></p><pre><code class="json">{  &quot;data&quot;:[    {        &quot;name&quot;:&quot;@sample/hotels&quot;,    //这里使用的是自己定义的  hotels 文件中的字段      &quot;img&quot;:&quot;@tools:sample/backgrounds/scenic&quot;,      &quot;desc&quot;:&quot;@sample/description&quot;   //这里使用的是自己定义的  description 文件中的字段    },    {      &quot;name&quot;:&quot;@sample/hotels&quot;,      &quot;img&quot;:&quot;@tools:sample/backgrounds/scenic&quot;,  //这里的就是自带的资源了      &quot;desc&quot;:&quot;@sample/description&quot;    },    {      &quot;name&quot;:&quot;@sample/hotels&quot;,      &quot;img&quot;:&quot;@sample/images&quot;,  //这种就是/images 文件中的资源      &quot;desc&quot;:&quot;@sample/description&quot;    },    {      &quot;name&quot;:&quot;@sample/hotels&quot;,      &quot;img&quot;:&quot;@tools:sample/backgrounds/scenic&quot;,      &quot;desc&quot;:&quot;@sample/description&quot;    },    {      &quot;name&quot;:&quot;@sample/hotels&quot;,      &quot;img&quot;:&quot;@tools:sample/backgrounds/scenic&quot;,      &quot;desc&quot;:&quot;@sample/description&quot;    }  ]}</code></pre></li></ul><p>使用方式为:</p><pre><code class="xml">&lt;TextView    ...    tools:text=&quot;@sample/hotels&quot;/&gt;&lt;ImageView    ...    tools:src=&quot;@sample/images&quot;/&gt;</code></pre>]]></content>
    
    
    <categories>
      
      <category>Android Studio</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Android</tag>
      
      <tag>Android Studio</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Android项目中使用Timber + Logger日志输出</title>
    <link href="undefined2018/02/07/Android-Timber-Logger/"/>
    <url>2018/02/07/Android-Timber-Logger/</url>
    
    <content type="html"><![CDATA[<p>不啰嗦了,直接开始.</p><h4 id="添加依赖"><a href="#添加依赖" class="headerlink" title="添加依赖"></a>添加依赖</h4><blockquote><p>Logger   <a href="https://github.com/orhanobut/logger" target="_blank" rel="noopener">orhanobut/Logger</a></p><p>Timber  <a href="https://github.com/JakeWharton/timber" target="_blank" rel="noopener">JakeWharton/timber</a></p></blockquote><pre><code class="groovy">//loggerimplementation &#39;com.orhanobut:logger:2.1.1&#39;//timberimplementation &#39;com.jakewharton.timber:timber:4.6.0&#39;</code></pre><a id="more"></a><h4 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h4><p>我放在了我的Application.java中初始化的</p><pre><code class="java">    /**     * 初始化Timber     */    private void initTimber() {          //配置Logger        FormatStrategy formatStrategy = PrettyFormatStrategy.newBuilder()                .showThreadInfo(true)                   .methodCount(2)                .methodOffset(7)                .tag(&quot;MY_LOG&quot;)                .build();          //配置Logger在Debug时不打印        Logger.addLogAdapter(new AndroidLogAdapter(formatStrategy){            @Override            public boolean isLoggable(int priority, String tag) {                return BuildConfig.DEBUG;            }        });          //给Timber一个树...大神这么打比喻的 😆        Timber.plant(new Timber.DebugTree(){            @Override            protected void log(int priority, String tag,                                @NotNull String message, Throwable t) {                Logger.log(priority,tag,message,t);            }        });    }</code></pre><p><img src="https://github.com/orhanobut/logger/blob/master/art/logger_output.png" srcset="/img/loading.gif" alt="logger"></p><p>其中:</p><p><code>showThreadInfo(true)</code>  是否显示ThreadInfo</p><p><code>methodCount(2)</code>        日志输出时显示几行</p><p><code>methodOffset(7)</code>      方法偏移量,默认是5,这个自己调大,调小看看就明白了</p><p><code>tag(&quot;MY_LOG&quot;)</code>          自定义的Tag,默认值是PRETTY_LOGGER</p><h4 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h4><pre><code class="java">Timber.e(&quot;下载状态发生改变 = %s&quot;, downLoadInfo.status )Timber.e(&quot;下载进度 = %d&quot;, mBindingView.progressBar.progress )</code></pre><p>logger负责生成message的方法</p><pre><code class="Java">  private String createMessage(String message, Object... args) {    return args == null || args.length == 0 ? message : String.format(message, args);  }</code></pre><p><code>String.format(message, args)</code>这就赋予了我们在写信息的时候使用占位符.记得要符合format的格式哦</p><h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><p>其实按我现在的需求,Logger完全符合我,为什么加上Timber那?</p><p>Timber可以做到分发,到时候我可以加上 DiskFileTree  …  什么的,方便后期有变化的时候修改</p><p>然而,我在Logger里发现了一个类</p><p><code>com.orhanobut.logger.DiskLogAdapter</code></p><p>原来它已经支持写到本地了.. 宝宝心里苦</p>]]></content>
    
    
    <categories>
      
      <category>Android</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Android</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Jenkins搭建Android自动打包</title>
    <link href="undefined2018/02/05/Jenkins-Android/"/>
    <url>2018/02/05/Jenkins-Android/</url>
    
    <content type="html"><![CDATA[<h4 id="下载安装"><a href="#下载安装" class="headerlink" title="下载安装"></a>下载安装</h4><ul><li><p>Jenkins的下载与安装</p><p><strong>下载</strong></p><blockquote><p> <a href="https://jenkins.io/download/" target="_blank" rel="noopener">https://jenkins.io/download/</a></p><p> 下载war包</p><p> <a href="http://mirrors.jenkins.io/war-stable/latest/jenkins.war" target="_blank" rel="noopener">Generic Java package (.war)</a></p></blockquote><p>因为打算使用Tomcat来部署,所以需要下载war包,也可以直接下对应版本的安装文件,直接安装</p></li></ul><pre><code>**安装**war包放到`./apache-tomcat-7.0.77/webapps`    Tomcat的wabapps包下即可</code></pre><ul><li><p>Tomcat (略)</p><p>记得配置一下环境变量,等会方便启动</p><pre><code class="shell">export TOMCAT_HOME=/Users/phyooos/develop/apache-tomcat-7.0.77export PATH.....:$TOMCAT/bin</code></pre></li></ul><a id="more"></a><h4 id="初始化Jenkins"><a href="#初始化Jenkins" class="headerlink" title="初始化Jenkins"></a>初始化Jenkins</h4><ul><li><p>启动Jenkins,即启动tomcat</p><pre><code class="shell">$ startup.shUsing CATALINA_BASE:   /Users/phyooos/develop/apache-tomcat-7.0.77Using CATALINA_HOME:   /Users/phyooos/develop/apache-tomcat-7.0.77Using CATALINA_TMPDIR: /Users/phyooos/develop/apache-tomcat-7.0.77/tempUsing JRE_HOME:        /Library/Java/JavaVirtualMachines/jdk1.8.0/Contents/HomeUsing CLASSPATH:       /Users/phyooos/develop/apache-tomcat-7.0.77/bin/bootstrap.jar:/Users/phyooos/develop/apache-tomcat-7.0.77/bin/tomcat-juli.jarTomcat started.</code></pre><p>看到这个就说明,已经正常启动</p></li><li><p>访问<a href="http://localhost:8080/jenkins/" target="_blank" rel="noopener">http://localhost:8080/jenkins/</a></p><p>打开后需要输入一个密钥,mac的在<code>jenkins/secrets/initialAdminPassword</code></p><pre><code class="shell">~ ⌚ 10:11:03$ cat ~/.jenkins/secrets/initialAdminPassword55ad44431f6d4ebdb53a7c1971d12df4</code></pre><p>输入此密钥即可.</p></li><li><p>创建用户</p></li></ul><h4 id="配置Jenkins"><a href="#配置Jenkins" class="headerlink" title="配置Jenkins"></a>配置Jenkins</h4><h5 id="1-安装插件"><a href="#1-安装插件" class="headerlink" title="1.安装插件"></a>1.安装插件</h5><pre><code>Build Timeoutbuild-name-setterCredentials Binding Plugindescription setter pluginDynamic Parameter Plug-in(这个插件,搜不到了,因为安全问题被屏蔽了)Environment Injector PluginGit pluginGitHub Branch Source PluginGitlab Authentication pluginGitLab PluginGradle PluginPipelineSSH Slaves pluginSSH pluginTimestamperUpload to pgyer(上传到蒲公英,没有需要的不用安装)Workspace Cleanup Plugin</code></pre><p>以上插件,是常用的插件,尽量全部安装</p><h5 id="2-配置环境变量"><a href="#2-配置环境变量" class="headerlink" title="2.配置环境变量"></a>2.配置环境变量</h5><p><strong>系统管理 - 全局工具配置</strong></p><p>需要配置</p><p>Java</p><p><img src="/images/jenkins_java.png" srcset="/img/loading.gif" alt="Java"></p><p>Git</p><p><img src="/images/jenkins_git.png" srcset="/img/loading.gif" alt="Git"></p><p>Gradle</p><p><img src="/images/jenkins_gradle.png" srcset="/img/loading.gif" alt="Gradle"></p><p>配置好保存即可</p><p><strong>系统管理 - 系统设置</strong></p><p>记得配置gitlab或者 github账号</p><h5 id="3-初始化项目"><a href="#3-初始化项目" class="headerlink" title="3.初始化项目"></a>3.初始化项目</h5><p>创建项目</p><p><img src="/images/jenkins_init.png" srcset="/img/loading.gif" alt="init"></p><hr><p><strong>General</strong></p><p>选择参数化构建过程</p><p>IS_JENKINS  是否Jenkins打包,这里肯定是一直true的</p><p>PRODUCT_FLAVORS  环境</p><p>BUILD_TYPE  构建版本</p><p>VERSION_NAME 版本名字</p><p>JENKINS_OUTPUT Apk生成目录</p><p>JENKINS_TIME  时间戳</p><p><img src="/images/jenkins_init1.png" srcset="/img/loading.gif" alt="General"></p><p><img src="/images/jenkins_init2.png" srcset="/img/loading.gif" alt="General"></p><p><img src="/images/jenkins_init3.png" srcset="/img/loading.gif" alt="General"></p><p>这些参数定义完就可以使用了 ${参数名} 的形式,这些参数会写入到 App项目中的 gradle.properties文件</p><p>App项目中的 gradle.properties文件</p><pre><code class="java"># When configured, Gradle will run in incubating parallel mode.# This option should only be used with decoupled projects. More details, visit# http://www.gradle.org/docs/current/userguide/multi_project_builds.html#sec:decoupled_projects# org.gradle.parallel=trueorg.gradle.jvmargs=-Xmx4608MVERSION_NAME=1.4.0VERSION_CODE=12IS_JENKINS=falseJENKINS_OUTPUT=&#39;output/&#39;JENKINS_TIME=&#39;201802021231&#39;</code></pre><hr><p>进入下一个配置页面,到<strong>源码管理</strong>那块</p><p><img src="/images/jenkins_gitlab.png" srcset="/img/loading.gif" alt="gitlab"></p><p>只要你能下载到源码即可,无所谓非要和我这个一致,branch  就是指定分支了,我这儿是  dev 分支</p><hr><p>下一个配置<strong>构建</strong></p><p><img src="/images/jenkins_build.png" srcset="/img/loading.gif" alt="build"></p><p>选择 Invoke Gradle </p><p>Tasks 里面的命令,我来解释一下</p><pre><code>#清理clean  #打包assemble${PRODUCT_FLAVORS}${BUILD_TYPE}#这里的意思是 打包指定的一个FLAVOR版本(Release + 版本)#关于assemble ...  的,请搜 gradle 打包命令#其他参数-PVERSION_NAME=${VERSION_NAME}-PVERSION_CODE=${VERSION_CODE}-PJENKINS_OUTPUT=${JENKINS_OUTPUT}-PJENKINS_TIME=${JENKINS_TIME}-PIS_JENKINS=${IS_JENKINS}#-P意味着参数#-P后面是参数名#=${} 则为参数值,就是上面General里面配置的</code></pre><hr><p><strong>构建后操作</strong></p><p><img src="/images/jenkins_pgy.png" srcset="/img/loading.gif" alt="pgy"></p><blockquote><p>参考 <a href="https://www.pgyer.com/doc/view/jenkins_plugin" target="_blank" rel="noopener">https://www.pgyer.com/doc/view/jenkins_plugin</a></p></blockquote><p>保存即可</p><h5 id="改造App"><a href="#改造App" class="headerlink" title="改造App"></a>改造App</h5><ul><li>./gradle.properties文件</li></ul><pre><code>VERSION_NAME=1.4.0VERSION_CODE=12IS_JENKINS=falseJENKINS_OUTPUT=&#39;output/&#39;JENKINS_TIME=&#39;201802021231&#39;</code></pre><p>以上文件,写完请build一次,便于build.gradle中使用</p><p>使用jenkins时,jenkins会把定义的值注入到这里,覆盖这里定义的值</p><ul><li>app/build.gradle</li></ul><pre><code class="groovy">android{    defaultConfig {        ...        //此处使用gradle.properties中的值   VERSION_CODE和VERSION_NAME        versionCode VERSION_CODE as Integer        versionName VERSION_NAME    }    //自定义apk名字    android.applicationVariants.all { variant -&gt;        //获取时间戳        def timeNow = getDate()        //如果是IS_JENKINS构建,则修改打包apk的目录        if (&#39;true&#39;.equals(IS_JENKINS)) {            //使用JENKINS_OUTPUT的目录            def outputFile = JENKINS_OUTPUT            //使用JENKINS_TIME的时间戳            timeNow = JENKINS_TIME            //定义apk目录            variant.getPackageApplication().outputDirectory = new File(outputFile)        }        variant.getPackageApplication().outputScope.apkDatas.forEach { apkData -&gt;            //这个修改输出APK的文件名            apkData.outputFileName = &quot;一号车市_${variant.versionName}_${timeNow}.apk&quot;        }    }    flavorDimensions &#39;env&#39;    productFlavors {        envapp {            dimension &#39;env&#39;            //此处使用jenkins传的VERSION_NAME            versionName VERSION_NAME            manifestPlaceholders = [UMENG_CHANNEL_VALUE: &quot;app&quot;]            buildConfigField &quot;String&quot;, &quot;SERVER_HOST&quot;, &#39;&quot;https://app.wangzhumo.com/&quot;&#39;        }        envtest {            dimension &#39;env&#39;            //为了方便测试看出当前app环境,就不用VERSION_NAME了            versionName &quot;Test&quot;            manifestPlaceholders = [UMENG_CHANNEL_VALUE: &quot;app&quot;]            buildConfigField &quot;String&quot;, &quot;SERVER_HOST&quot;, &#39;&quot;http://app-test.wangzhumo.com/&quot;&#39;        }        envpre {            dimension &#39;env&#39;            versionName &quot;Pre&quot;            manifestPlaceholders = [UMENG_CHANNEL_VALUE: &quot;app&quot;]            buildConfigField &quot;String&quot;, &quot;SERVER_HOST&quot;, &#39;&quot;https://app-pre.wangzhumo.com/&quot;&#39;        }        envdev {            dimension &#39;env&#39;            versionName &quot;Dev&quot;            manifestPlaceholders = [UMENG_CHANNEL_VALUE: &quot;app&quot;]            buildConfigField &quot;String&quot;, &quot;SERVER_HOST&quot;, &#39;&quot;http://192.168.1.16:8080/app2c/&quot;&#39;        }        //其实UMENG_CHANNEL_VALUE    SERVER_HOST   也都可以使用jenkins定义参数,并使用    }     //一个获取时间戳的方法    static def getDate() {        def date = new Date()        def formattedDate = date.format(&#39;yyyyMMddHHmm&#39;)        return formattedDate    }}</code></pre><p>记得改完app,上传代码哦</p><h4 id="Jenkins打包"><a href="#Jenkins打包" class="headerlink" title="Jenkins打包"></a>Jenkins打包</h4><p><img src="/images/jenkins_go.png" srcset="/img/loading.gif" alt="打包"></p><p>OK了,可以愉快的打包了,打包完就会自动上传到蒲公英.</p>]]></content>
    
    
    <categories>
      
      <category>Android</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Android</tag>
      
      <tag>Server</tag>
      
      <tag>Jenkins</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Java中String.format()的使用指北</title>
    <link href="undefined2018/02/04/Java-String-format/"/>
    <url>2018/02/04/Java-String-format/</url>
    
    <content type="html"><![CDATA[<blockquote><p>本文非原创,来自<a href="http://blog.csdn.net/lonely_fireworks/article/details/7962171/" target="_blank" rel="noopener">http://blog.csdn.net/lonely_fireworks/article/details/7962171/</a></p><p>这里做一个备份,方便随时查询</p></blockquote><a id="more"></a><h4 id="常规类型的格式化"><a href="#常规类型的格式化" class="headerlink" title="常规类型的格式化"></a>常规类型的格式化</h4><p>String类的format()方法用于创建格式化的字符串以及连接多个字符串对象,format()方法有两种重载形式。</p><ul><li><p>format(String format, Object… args) </p><p>新字符串使用本地语言环境，制定字符串格式和参数生成格式化的新字符串。</p></li><li><p>format(Locale locale, String format, Object… args) </p><p>使用指定的语言环境，制定字符串格式和参数生成格式化的字符串。</p></li></ul><h5 id="显示不同转换符实现不同数据类型到字符串的转换，如图所示。"><a href="#显示不同转换符实现不同数据类型到字符串的转换，如图所示。" class="headerlink" title="显示不同转换符实现不同数据类型到字符串的转换，如图所示。"></a>显示不同转换符实现不同数据类型到字符串的转换，如图所示。</h5><table><thead><tr><th>转  换  符</th><th>说    明</th><th>示    例</th></tr></thead><tbody><tr><td>%s</td><td>字符串类型</td><td>“mingrisoft”</td></tr><tr><td>%c</td><td>字符类型</td><td>‘m’</td></tr><tr><td>%b</td><td>布尔类型</td><td>true</td></tr><tr><td>%d</td><td>整数类型（十进制）</td><td>99</td></tr><tr><td>%x</td><td>整数类型（十六进制）</td><td>FF</td></tr><tr><td>%o</td><td>整数类型（八进制）</td><td>77</td></tr><tr><td>%f</td><td>浮点类型</td><td>99.99</td></tr><tr><td>%a</td><td>十六进制浮点类型</td><td>FF.35AE</td></tr><tr><td>%e</td><td>指数类型</td><td>9.38e+5</td></tr><tr><td>%g</td><td>通用浮点类型（f和e类型中较短的）</td><td></td></tr><tr><td>%h</td><td>散列码</td><td></td></tr><tr><td>%%</td><td>百分比类型</td><td>％</td></tr><tr><td>%n</td><td>换行符</td><td></td></tr><tr><td>%tx</td><td>日期与时间类型（x代表不同的日期与时间转换符</td></tr></tbody></table><p>测试用例</p><pre><code class="java">    public static void main(String[] args) {        String str=null;        str=String.format(&quot;Hi,%s&quot;, &quot;王力&quot;);        System.out.println(str);        str=String.format(&quot;Hi,%s:%s.%s&quot;, &quot;王南&quot;,&quot;王力&quot;,&quot;王张&quot;);                  System.out.println(str);                                 System.out.printf(&quot;字母a的大写是：%c %n&quot;, &#39;A&#39;);        System.out.printf(&quot;3&gt;7的结果是：%b %n&quot;, 3&gt;7);        System.out.printf(&quot;100的一半是：%d %n&quot;, 100/2);        System.out.printf(&quot;100的16进制数是：%x %n&quot;, 100);        System.out.printf(&quot;100的8进制数是：%o %n&quot;, 100);        System.out.printf(&quot;50元的书打8.5折扣是：%f 元%n&quot;, 50*0.85);        System.out.printf(&quot;上面价格的16进制数是：%a %n&quot;, 50*0.85);        System.out.printf(&quot;上面价格的指数表示：%e %n&quot;, 50*0.85);        System.out.printf(&quot;上面价格的指数和浮点数结果的长度较短的是：%g %n&quot;, 50*0.85);        System.out.printf(&quot;上面的折扣是%d%% %n&quot;, 85);        System.out.printf(&quot;字母A的散列码是：%h %n&quot;, &#39;A&#39;);    }</code></pre><p>输出结果</p><pre><code class="java">Hi,王力Hi,王南:王力.王张字母a的大写是：A 3&gt;7的结果是：false 100的一半是：50 100的16进制数是：64 100的8进制数是：144 50元的书打8.5折扣是：42.500000 元上面价格的16进制数是：0x1.54p5 上面价格的指数表示：4.250000e+01 上面价格的指数和浮点数结果的长度较短的是：42.5000 上面的折扣是85% 字母A的散列码是：41</code></pre><h5 id="搭配转换符的标志"><a href="#搭配转换符的标志" class="headerlink" title="搭配转换符的标志"></a>搭配转换符的标志</h5><table><thead><tr><th>标    志</th><th>说    明</th><th>示    例</th><th>结    果</th></tr></thead><tbody><tr><td>+</td><td>为正数或者负数添加符号</td><td>(“%+d”,15)</td><td>+15</td></tr><tr><td>−</td><td>左对齐</td><td>(“%-5d”,15)</td><td>\</td><td>15   \</td><td></td></tr><tr><td>0</td><td>数字前面补0</td><td>(“%04d”, 99)</td><td>0099</td></tr><tr><td>空格</td><td>在整数之前添加指定数量的空格</td><td>(“% 4d”, 99)</td><td>\</td><td>99\</td><td></td></tr><tr><td>,</td><td>以“,”对数字分组</td><td>(“%,f”, 9999.99)</td><td>9,999.990000</td></tr><tr><td>(</td><td>使用括号包含负数</td><td>(“%(f”, -99.99)</td><td>(99.990000)</td></tr><tr><td>#</td><td>如果是浮点数则包含小数点，如果是16进制或8进制则添加0x或0</td><td>(“%#x”, 99)(“%#o”, 99)</td><td>0x630143</td></tr><tr><td>&lt;</td><td>格式化前一个转换符所描述的参数</td><td>(“%f和%&lt;3.2f”, 99.45)</td><td>99.450000和99.45</td></tr><tr><td>$</td><td>被格式化的参数索引</td><td>(“%1$d,%2$s”, 99,”abc”)</td><td>99,abc</td></tr></tbody></table><p>测试用例</p><pre><code class="java">public static void main(String[] args) {      String str=null;      //$使用      str=String.format(&quot;格式参数的使用：%1d,%2$s&quot;, 99,&quot;abc&quot;);                 System.out.println(str);                              //+使用      System.out.printf(&quot;显示正负数的符号：%+d与%d%n&quot;, 99,-99);      //补O使用      System.out.printf(&quot;最牛的编号是：%03d%n&quot;, 7);      //空格使用      System.out.printf(&quot;Tab键的效果是：% 8d%n&quot;, 7);      //.使用      System.out.printf(&quot;整数分组的效果是：%,d%n&quot;, 9989997);      //空格和小数点后面个数      System.out.printf(&quot;一本书的价格是：% 50.5f元%n&quot;, 49.8);  }</code></pre><p>输出结果</p><pre><code class="java">格式参数$的使用：99,abc显示正负数的符号：+99与-99最牛的编号是：007Tab键的效果是：       7整数分组的效果是：9,989,997一本书的价格是： 49.80000元</code></pre><h4 id="日期和事件字符串格式化"><a href="#日期和事件字符串格式化" class="headerlink" title="日期和事件字符串格式化"></a>日期和事件字符串格式化</h4><p>字符串格式中还有%tx转换符没有详细介绍，它是专门用来格式化日期和时 间的。%tx转换符中的x代表另外的处理日期和时间格式的转换符，它们的组合能够将日期和时间格式化成多种格式。</p><h5 id="常见日期和时间组合的格式"><a href="#常见日期和时间组合的格式" class="headerlink" title="常见日期和时间组合的格式"></a>常见日期和时间组合的格式</h5><table><thead><tr><th>转  换  符</th><th>说    明</th><th>示    例</th></tr></thead><tbody><tr><td>c</td><td>包括全部日期和时间信息</td><td>星期六 十月 27 14:21:20 CST 2007</td></tr><tr><td>F</td><td>“年-月-日”格式</td><td>2007-10-27</td></tr><tr><td>D</td><td>“月/日/年”格式</td><td>10/27/07</td></tr><tr><td>r</td><td>“HH:MM:SS PM”格式（12时制）</td><td>02:25:51 下午</td></tr><tr><td>T</td><td>“HH:MM:SS”格式（24时制）</td><td>14:28:16</td></tr><tr><td>R</td><td>“HH:MM”格式（24时制）</td><td>14:28</td></tr></tbody></table><p>测试用例</p><pre><code class="Java">    public static void main(String[] args) {        Date date=new Date();                                        //c的使用        System.out.printf(&quot;全部日期和时间信息：%tc%n&quot;,date);                //f的使用        System.out.printf(&quot;年-月-日格式：%tF%n&quot;,date);        //d的使用        System.out.printf(&quot;月/日/年格式：%tD%n&quot;,date);        //r的使用        System.out.printf(&quot;HH:MM:SS PM格式（12时制）：%tr%n&quot;,date);        //t的使用        System.out.printf(&quot;HH:MM:SS格式（24时制）：%tT%n&quot;,date);        //R的使用        System.out.printf(&quot;HH:MM格式（24时制）：%tR&quot;,date);    }</code></pre><p>输出结果</p><pre><code>全部日期和时间信息：星期一 九月 10 10:43:36 CST 2012年-月-日格式：2012-09-10月/日/年格式：09/10/12HH:MM:SS PM格式（12时制）：10:43:36 上午HH:MM:SS格式（24时制）：10:43:36HH:MM格式（24时制）：10:43</code></pre><p>定义日期格式的转换符可以使日期通过指定的转换符生成新字符串。这些日期转换符如图所示。</p><pre><code class="Java">public static void main(String[] args) {  Date date=new Date();                                      //b的使用，月份简称  String str=String.format(Locale.US,&quot;英文月份简称：%tb&quot;,date);       System.out.println(str);                                                                              System.out.printf(&quot;本地月份简称：%tb%n&quot;,date);  //B的使用，月份全称  str=String.format(Locale.US,&quot;英文月份全称：%tB&quot;,date);  System.out.println(str);  System.out.printf(&quot;本地月份全称：%tB%n&quot;,date);  //a的使用，星期简称  str=String.format(Locale.US,&quot;英文星期的简称：%ta&quot;,date);  System.out.println(str);  //A的使用，星期全称  System.out.printf(&quot;本地星期的简称：%tA%n&quot;,date);  //C的使用，年前两位  System.out.printf(&quot;年的前两位数字（不足两位前面补0）：%tC%n&quot;,date);  //y的使用，年后两位  System.out.printf(&quot;年的后两位数字（不足两位前面补0）：%ty%n&quot;,date);  //j的使用，一年的天数  System.out.printf(&quot;一年中的天数（即年的第几天）：%tj%n&quot;,date);  //m的使用，月份  System.out.printf(&quot;两位数字的月份（不足两位前面补0）：%tm%n&quot;,date);  //d的使用，日（二位，不够补零）  System.out.printf(&quot;两位数字的日（不足两位前面补0）：%td%n&quot;,date);  //e的使用，日（一位不补零）  System.out.printf(&quot;月份的日（前面不补0）：%te&quot;,date);}</code></pre><p>输出结果</p><pre><code>英文月份简称：Sep本地月份简称：九月英文月份全称：September本地月份全称：九月英文星期的简称：Mon本地星期的简称：星期一年的前两位数字（不足两位前面补0）：20年的后两位数字（不足两位前面补0）：12一年中的天数（即年的第几天）：254两位数字的月份（不足两位前面补0）：09两位数字的日（不足两位前面补0）：10月份的日（前面不补0）：10</code></pre><h5 id="和日期格式转换符相比，时间格式的转换符要更多、更精确。它可以将时间格式化成时、分、秒甚至时毫秒等单位。格式化时间字符串的转换符如图所示。"><a href="#和日期格式转换符相比，时间格式的转换符要更多、更精确。它可以将时间格式化成时、分、秒甚至时毫秒等单位。格式化时间字符串的转换符如图所示。" class="headerlink" title="和日期格式转换符相比，时间格式的转换符要更多、更精确。它可以将时间格式化成时、分、秒甚至时毫秒等单位。格式化时间字符串的转换符如图所示。"></a>和日期格式转换符相比，时间格式的转换符要更多、更精确。它可以将时间格式化成时、分、秒甚至时毫秒等单位。格式化时间字符串的转换符如图所示。</h5><table><thead><tr><th>转  换  符</th><th>说    明</th><th>示    例</th></tr></thead><tbody><tr><td>H</td><td>2位数字24时制的小时（不足2位前面补0）</td><td>15</td></tr><tr><td>I</td><td>2位数字12时制的小时（不足2位前面补0）</td><td>03</td></tr><tr><td>k</td><td>2位数字24时制的小时（前面不补0）</td><td>15</td></tr><tr><td>l</td><td>2位数字12时制的小时（前面不补0）</td><td>3</td></tr><tr><td>M</td><td>2位数字的分钟（不足2位前面补0）</td><td>03</td></tr><tr><td>S</td><td>2位数字的秒（不足2位前面补0）</td><td>09</td></tr><tr><td>L</td><td>3位数字的毫秒（不足3位前面补0）</td><td>015</td></tr><tr><td>N</td><td>9位数字的毫秒数（不足9位前面补0）</td><td>562000000</td></tr><tr><td>p</td><td>小写字母的上午或下午标记</td><td>中：下午英：pm</td></tr><tr><td>z</td><td>相对于GMT的RFC822时区的偏移量</td><td>+0800</td></tr><tr><td>Z</td><td>时区缩写字符串</td><td>CST</td></tr></tbody></table><table><thead><tr><th>s</th><th>1970-1-1 00:00:00 到现在所经过的秒数</th><th>1193468128</th></tr></thead><tbody><tr><td>Q</td><td>1970-1-1 00:00:00 到现在所经过的毫秒数</td><td>1193468128984</td></tr></tbody></table><p>测试代码</p><pre><code class="java">    public static void main(String[] args) {        Date date = new Date();        //H的使用        System.out.printf(&quot;2位数字24时制的小时（不足2位前面补0）:%tH%n&quot;, date);        //I的使用        System.out.printf(&quot;2位数字12时制的小时（不足2位前面补0）:%tI%n&quot;, date);        //k的使用        System.out.printf(&quot;2位数字24时制的小时（前面不补0）:%tk%n&quot;, date);        //l的使用        System.out.printf(&quot;2位数字12时制的小时（前面不补0）:%tl%n&quot;, date);        //M的使用        System.out.printf(&quot;2位数字的分钟（不足2位前面补0）:%tM%n&quot;, date);        //S的使用        System.out.printf(&quot;2位数字的秒（不足2位前面补0）:%tS%n&quot;, date);        //L的使用        System.out.printf(&quot;3位数字的毫秒（不足3位前面补0）:%tL%n&quot;, date);        //N的使用        System.out.printf(&quot;9位数字的毫秒数（不足9位前面补0）:%tN%n&quot;, date);        //p的使用        String str = String.format(Locale.US, &quot;小写字母的上午或下午标记(英)：%tp&quot;, date);        System.out.println(str);         System.out.printf(&quot;小写字母的上午或下午标记（中）：%tp%n&quot;, date);        //z的使用        System.out.printf(&quot;相对于GMT的RFC822时区的偏移量:%tz%n&quot;, date);        //Z的使用        System.out.printf(&quot;时区缩写字符串:%tZ%n&quot;, date);        //s的使用        System.out.printf(&quot;1970-1-1 00:00:00 到现在所经过的秒数：%ts%n&quot;, date);        //Q的使用        System.out.printf(&quot;1970-1-1 00:00:00 到现在所经过的毫秒数：%tQ%n&quot;, date);    }</code></pre><p>输出结果</p><pre><code class="java">2位数字24时制的小时（不足2位前面补0）:112位数字12时制的小时（不足2位前面补0）:112位数字24时制的小时（前面不补0）:112位数字12时制的小时（前面不补0）:112位数字的分钟（不足2位前面补0）:032位数字的秒（不足2位前面补0）:523位数字的毫秒（不足3位前面补0）:7739位数字的毫秒数（不足9位前面补0）:773000000小写字母的上午或下午标记(英)：am小写字母的上午或下午标记（中）：上午相对于GMT的RFC822时区的偏移量:+0800时区缩写字符串:CST1970-1-1 00:00:00 到现在所经过的秒数：13472462321970-1-1 00:00:00 到现在所经过的毫秒数：1347246232773</code></pre>]]></content>
    
    
    <categories>
      
      <category>Java</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Java</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Room --AppDatabase_Impl does not exist的异常解决</title>
    <link href="undefined2018/01/17/Room-AppDatabase-Impl-does-not-exist/"/>
    <url>2018/01/17/Room-AppDatabase-Impl-does-not-exist/</url>
    
    <content type="html"><![CDATA[<p>Bug如下:</p><pre><code>Caused by: java.lang.RuntimeException: cannot find implementation for com.wangzhumo.app.datasource.database.AppDB. AppDB_Impl does not exist</code></pre><a id="more"></a><h4 id="寻找原因"><a href="#寻找原因" class="headerlink" title="寻找原因"></a>寻找原因</h4><p>debug依次发现:</p><ul><li><p>getInstance()为空</p><pre><code class="java">  public static AppDB getInstance(Context context) {        if (sInstance == null) {            synchronized (AppDB.class) {                if (sInstance == null) {                    //此处返回为空                    sInstance = buildDatabase(context);                    sInstance.updateDatabaseCreated(context);                }            }        }        return sInstance;    }</code></pre></li><li><p>buildDatabase(context) 返回为空</p><pre><code class="java">/** * Build the database. * creates a new instance of the database. */private static AppDB buildDatabase(final Context appContext) {     AppDB appDB = Room.databaseBuilder(appContext, AppDB.class, DATABASE_NAME)            .addCallback(new Callback() {                @Override                public void onCreate(@NonNull SupportSQLiteDatabase db) {                    super.onCreate(db);                    AppDB database = AppDB.getInstance(appContext);                    database.setDatabaseCreated();                }                @Override                public void onOpen(@NonNull SupportSQLiteDatabase db) {                    super.onOpen(db);                    Log.e(TAG, &quot;onOpen: &quot; + db.getPath());                }            }).build();    return appDB;}</code></pre></li></ul><ul><li>databaseBuilder是创建数据库的方法,但是它构建失败了,那么剩下的就是源码了</li></ul><h4 id="Debug源码"><a href="#Debug源码" class="headerlink" title="Debug源码"></a>Debug源码</h4><ul><li>databaseBuilder 方法</li></ul><pre><code class="java">@SuppressWarnings(&quot;WeakerAccess&quot;)    @NonNull    public static &lt;T extends RoomDatabase&gt; RoomDatabase.Builder&lt;T&gt; databaseBuilder(            @NonNull Context context, @NonNull Class&lt;T&gt; klass, @NonNull String name) {        //noinspection ConstantConditions        if (name == null || name.trim().length() == 0) {            throw new IllegalArgumentException              (&quot;Cannot build a database with null or empty name.&quot;                    + &quot; If you are trying to create an in memory database, use Room&quot;                    + &quot;.inMemoryDatabaseBuilder&quot;);        }        return new RoomDatabase.Builder&lt;&gt;(context, klass, name);    }</code></pre><p>我们可以明显的看出,此处抛出的异常不是AppDB_Impl does not exist 的提示,可以肯定并不是此处的问题</p><p>应该是正常返回的 return new RoomDatabase.Builder&lt;&gt;(context, klass, name);</p><p><code>RoomDatabase.Builder</code></p><p>那么出问题的就可以肯定是</p><ul><li><p>build()方法</p><pre><code>@NonNull        public T build() {            //noinspection ConstantConditions            if (mContext == null) {                throw new IllegalArgumentException                (&quot;Cannot provide null context for the database.&quot;);            }            //noinspection ConstantConditions            if (mDatabaseClass == null) {                throw new IllegalArgumentException                (&quot;Must provide an abstract class that&quot;                        + &quot; extends RoomDatabase&quot;);            }            if (mFactory == null) {                mFactory = new FrameworkSQLiteOpenHelperFactory();            }            DatabaseConfiguration configuration =                    new DatabaseConfiguration(mContext, mName, mFactory, mMigrationContainer,                            mCallbacks, mAllowMainThreadQueries, mRequireMigration);            T db = Room.getGeneratedImplementation(mDatabaseClass, DB_IMPL_SUFFIX);            db.init(configuration);            return db;        }</code></pre><p>此处,debug发现,是到</p><p><code>T db = Room.getGeneratedImplementation(mDatabaseClass, DB_IMPL_SUFFIX);</code></p><p>抛出异常的.</p></li></ul><h4 id="锁定问题"><a href="#锁定问题" class="headerlink" title="锁定问题"></a>锁定问题</h4><p><code>getGeneratedImplementation</code></p><pre><code class="java">@NonNull    static &lt;T, C&gt; T getGeneratedImplementation(Class&lt;C&gt; klass, String suffix) {        final String fullPackage = klass.getPackage().getName();        String name = klass.getCanonicalName();        final String postPackageName = fullPackage.isEmpty()                ? name                : (name.substring(fullPackage.length() + 1));        final String implName = postPackageName.replace(&#39;.&#39;, &#39;_&#39;) + suffix;        //noinspection TryWithIdenticalCatches        try {            @SuppressWarnings(&quot;unchecked&quot;)            final Class&lt;T&gt; aClass = (Class&lt;T&gt;) Class.forName(                    fullPackage.isEmpty() ? implName : fullPackage + &quot;.&quot; + implName);            return aClass.newInstance();        } catch (ClassNotFoundException e) {            //**很明显,就是这个地方了**            throw new RuntimeException(&quot;cannot find implementation for &quot;                    + klass.getCanonicalName() + &quot;. &quot; + implName + &quot; does not exist&quot;);        } catch (IllegalAccessException e) {            throw new RuntimeException(&quot;Cannot access the constructor&quot;                    + klass.getCanonicalName());        } catch (InstantiationException e) {            throw new RuntimeException(&quot;Failed to create an instance of &quot;                    + klass.getCanonicalName());        }    }</code></pre><p>其实就是,生成类失败了</p><p>其他参数都正常,偏偏生成失败,所以就怀疑到 </p><p> Java  -&gt;     <code>apt</code> 的问题</p><p>Kotlin -&gt;  <code>kapt</code>的问题</p><p>这两个就是用来生成代码的,这里的生成失败,有很大概率是这个问题</p><h4 id="解决问题"><a href="#解决问题" class="headerlink" title="解决问题"></a>解决问题</h4><p>查看项目的依赖  <code>lib_opensource  -&gt; build.gradle</code></p><pre><code>    //arch    api deps.archLibs.archExtensions    api deps.archLibs.archLifecycleCommon    api deps.archLibs.archRoomRuntime    kapt deps.archLibs.archRoomCompiler</code></pre><p>查看发现,我已经添加了,那么什么鬼问题呢?</p><p><strong>怀疑是library的问题,打开我使用Room的library</strong>    ,查看 <code>lib_datasource -&gt; build.gradle</code></p><pre><code>apply plugin: &#39;com.android.library&#39;...dependencies {    implementation fileTree(dir: &#39;libs&#39;, include: [&#39;*.jar&#39;])    api project(&#39;:lib_opensource&#39;)//    kapt deps.archLibs.archRoomCompiler}</code></pre><p>果然忘了加</p><pre><code>apply plugin: &#39;com.android.library&#39;apply plugin: &#39;kotlin-android&#39;apply plugin: &#39;kotlin-kapt&#39;...dependencies {    implementation fileTree(dir: &#39;libs&#39;, include: [&#39;*.jar&#39;])    api project(&#39;:lib_opensource&#39;)//    kapt deps.archLibs.archRoomCompiler}</code></pre><p>就Ok了,我又可以愉快的玩耍了</p><h4 id="记得-kapt"><a href="#记得-kapt" class="headerlink" title="记得:  kapt"></a>记得:  kapt</h4>]]></content>
    
    
    <categories>
      
      <category>Bug</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Android</tag>
      
      <tag>Bug</tag>
      
      <tag>Room</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>使用Charles抓Https的数据请求</title>
    <link href="undefined2018/01/11/Charles-Https/"/>
    <url>2018/01/11/Charles-Https/</url>
    
    <content type="html"><![CDATA[<p>之前的文章中给项目中加入了Https,此时使用charles抓包就是一堆乱码,</p><p>但是我们还需要常常使用Charles,调试接口,查找问题等,所以就要让Charles作为一个中间人,帮我们接收转发请求</p><p>以达到抓包的效果,其实此时已经完全是Charles与服务器之间的事了.</p><a id="more"></a><h4 id="导出证书"><a href="#导出证书" class="headerlink" title="导出证书"></a>导出证书</h4><p>1.打开Charles</p><p>2.Help -&gt; SSL Proxying -&gt; Save Charles Root Certificate…</p><p>3.保存到~/Downloads/charles-ssl-proxying-certificate.pem</p><h4 id="安装证书到设备"><a href="#安装证书到设备" class="headerlink" title="安装证书到设备"></a>安装证书到设备</h4><p>1.把证书推送到设备</p><pre><code class="shell">$ adb push charles-ssl-proxying-certificate.pem /sdcard/Download/charles-ssl-proxying-certificate.pem: 1 file pushed. 0.1 MB/s (1921 bytes in 0.012s)</code></pre><p>2.安装证书</p><p>设置 -&gt; 安全 -&gt; 设备管理与凭证 -&gt; 从存储安装 -&gt; charles-ssl-proxying-certificate.pem’</p><h4 id="设置Charles"><a href="#设置Charles" class="headerlink" title="设置Charles"></a>设置Charles</h4><p>1.Proxy -&gt; SSL Proxying Settings</p><p>2.打开手机,开始请求</p>]]></content>
    
    
    
    <tags>
      
      <tag>Android</tag>
      
      <tag>Https</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Android开发中常用的Adb命令</title>
    <link href="undefined2018/01/11/Android-shell-Adb/"/>
    <url>2018/01/11/Android-shell-Adb/</url>
    
    <content type="html"><![CDATA[<p>在做这些之前,先配置好adb环境变量,以我的配置为例</p><pre><code class="shell">$ vim ~/.bash_profileexport ANDROID_HOME=/Users/phyooos/Library/Android/sdk...export PATH={省略}:$ANDROID_HOME/tools:$ANDROID_HOME/platform-tools$ source ~/.bas$ adbAndroid Debug Bridge version 1.0.39Version 0.0.1-4500957Installed as /Users/phyooos/Library/Android/sdk/platform-tools/adb...</code></pre><p>补充</p><blockquote><p>adb shell pm list packages   当前手机安装的所有app包名<br>adb shell pm list packages | grep ‘google’  在所有包名中查找带’google’的</p></blockquote><a id="more"></a><h4 id="连接设备"><a href="#连接设备" class="headerlink" title="连接设备"></a>连接设备</h4><p>打开开发者 -&gt; 打开调试 -&gt; 允许调试</p><ul><li><p>通过usb连接</p></li><li><p>通过wifi连接</p><p>保证Android设备与电脑在局域网中,网段好像也要一致 eg:  <code>192.168.2.98 , 192.168.2.111</code></p><pre><code class="shell">~ ⌚ 9:44:55$ adb connect 192.168.6.51unable to connect to 192.168.6.51:5555: Connection refused</code></pre><p>此时是连接不上的,要先tcpip 5555,如下:</p><pre><code class="shell">#使用Tcp并监听端口5555adb tcpip 5555#连接设备adb connect 192.168.6.51</code></pre><p>如果你想用usb调试</p><pre><code class="shell">#使用usb调试  adb usb</code></pre><p>PS:有的设备直接adb connect  即可,所以不妨先试试</p></li></ul><h4 id="查看设备"><a href="#查看设备" class="headerlink" title="查看设备"></a>查看设备</h4><ul><li><p>查看所有连接的设备</p><pre><code class="shell">$ adb devicesList of devices attached3080b82d    device860BCML228J8    device</code></pre></li><li><p>指定设备(adb 命令必须指定一个设备使用)</p></li></ul><pre><code class="shell">abd -s 编号 命令比如我要连接3080b82d    device 这个设备,安装一个apkeg:$ adb -s 3080b82d install Test.apkSuccess</code></pre><h4 id="安装-卸载apk"><a href="#安装-卸载apk" class="headerlink" title="安装,卸载apk"></a>安装,卸载apk</h4><ul><li>安装<pre><code class="shell">$ adb -s 3080b82d install Users/phyooos/develop/Test.apkSuccess</code></pre>install 跟上apk的path即可</li></ul><p>install 可以搭配几个参数使用,比较常用的是</p><p><code>install -r</code>   替换掉原来的apk.(被称为强制安装)    至于其他的参数去google官网看吧</p><p><code>install -t</code>  可以安装测试包</p><ul><li>卸载</li></ul><pre><code class="shell">adb uninstall [软件包名]adb uninstall -k [软件包名]</code></pre><p>-k 参数,卸载软件但是保留配置和缓存文件.</p><p>包名使用文章开始的命令查找即可(当前有两个手机,还要指定设备)</p><pre><code class="shell">$ adb -s 3080b82d shell pm list packages | grep &#39;miui&#39;package:com.miui.screenrecorderpackage:com.miui.contentextensionpackage:com.miui.powerkeeper...</code></pre><h4 id="拉取-推送文件"><a href="#拉取-推送文件" class="headerlink" title="拉取,推送文件"></a>拉取,推送文件</h4><ul><li>发送文件到Android设备</li></ul><p>　　<code>adb push [本地路径] [远程路径]</code></p><ul><li>从Android设备中下载文件</li></ul><p>　　<code>adb pull [远程路径] [本地路径]</code></p><h4 id="截图录屏"><a href="#截图录屏" class="headerlink" title="截图录屏"></a>截图录屏</h4><ul><li><p>截图<code>adb shell screencap [path]</code></p><pre><code>adb shell screencap /sdcard/screen.png#截图并保存到/sdcard/screen.png</code></pre></li><li><p>录屏<code>adb shell screenrecord [path]</code></p><pre><code>adb shell screenrecord /sdcard/demo.mp4#录屏</code></pre><p>注意:   按Ctrl-C 结束录制</p><pre><code>adb shell screenrecord --size &lt;WIDTHxHEIGHT&gt;adb shell screenrecord --bit-rate &lt;RATE&gt;adb shell screenrecord --bit-rate 5000000 /sdcard/demo.mp4adb shell screenrecord --time-limit &lt;TIME&gt;adb shell screenrecord --rotateadb shell screenrecord --verbose</code></pre></li></ul><h4 id="Package"><a href="#Package" class="headerlink" title="Package"></a>Package</h4><ul><li><p>查看系统内app信息  <code>adb shell pm list packages</code></p><ul><li><p>查看当前所有包</p><p><code>adb shell pm list packages</code></p><pre><code class="shell">$ adb shell pm list packagespackage:com.flyme.roamingpaypackage:com.android.cts.priv.ctsshimpackage:com.meizu.ppspackage:com.meizu.net.pedometerpackage:com.android.providers.telephony</code></pre></li><li><p>系统应用</p><p><code>adb shell pm list packages -s</code></p><pre><code class="shell">$ adb shell pm list packages -spackage:com.miui.screenrecorderpackage:com.android.cts.priv.ctsshimpackage:com.qualcomm.qti.auth.sampleextauthservicepackage:com.qualcomm.qti.perfdump...</code></pre></li><li><p>普通外来应用</p><p><code>adb shell pm list packages -3</code></p><pre><code class="shell">$ adb shell pm list packages -3package:com.google.android.youtubepackage:com.hpbr.bosszhipinpackage:de.blinkt.openvpnpackage:org.iggymedia.periodtrackerpackage:com.daimajia.gold</code></pre></li><li><p>其他参数</p><pre><code class="shell">#See their associated file.adb shell pm list packages -f #Filter to only show disabled packages.adb shell pm list packages -d #Filter to only show enabled packages.adb shell pm list packages -e #See the installer for the packages.adb shell pm list packages -i #Also include uninstalled packages.adb shell pm list packages -u</code></pre></li></ul></li><li><p>通过包名查找app位置 <code>adb shell pm path [packagename]</code></p><pre><code>$ adb shell pm path com.miui.screenrecorderpackage:/system/app/MiuiScreenRecorder/MiuiScreenRecorder.apk</code></pre></li><li><p>清除缓存<code>adb shell pm clear  [packageName]</code></p><p>清除了该app的  data  cache</p><pre><code>$ adb shell pm clear com.yhcs.carmartSuccess</code></pre></li></ul><h4 id="shell"><a href="#shell" class="headerlink" title="shell"></a>shell</h4><p>我们知道android其实精简了linux的命令,有一大部分linux命令没法用的</p><pre><code class="shell">$ adb shell#即可进入如果要root权限,国内手机好像不一致,我是用过的为$ adb root$ adb shell此时权限就是root进入shell后,就可以为所欲为,一般和linux一致</code></pre><p>不过这些,还是管用的</p><pre><code>ls , cd , rm , mkdir , touch , pwd ,cp , mv ,netstat , ping, ip</code></pre><p>举一个例子,我想查看当前wifi的ip是多少.</p><pre><code class="shell">$ adb shellsagit:/ $ ip -f inet addr show wlan023: wlan0: &lt;BROADCAST,MULTICAST,UP,LOWER_UP&gt; mtu 1500 qdisc mq state UP group default qlen 3000    inet 192.168.6.51/23 brd 192.168.7.255 scope global wlan0       valid_lft forever preferred_lft foreversagit:/ $#ip  inet 192.168.6.51  这个就是</code></pre><h4 id="Logcat"><a href="#Logcat" class="headerlink" title="Logcat"></a>Logcat</h4><p><code>adb logcat [option] [filter]</code></p><ul><li><p>查看log <code>adb logcat</code></p><p>通过  control + c  退出</p></li></ul><ul><li>查看Debug的log <code>adb logcat *:D</code></li></ul><p>Logcat,还是Android studio 看起来方便,所以没有继续去看,也就不说了</p><h4 id="dumpsys"><a href="#dumpsys" class="headerlink" title="dumpsys"></a>dumpsys</h4><p>这是一个很强大的命令</p><ul><li>电量 <code>adb shell dumpsys battery</code></li></ul><ul><li><p>服务列表 <code>adb shell dumpsys</code></p><p>下面的命令  <code>| more</code> 是为了显示所有的数据 </p><pre><code>$ adb shell dumpsys | moreCurrently running services:  DockObserver  MiuiBackup  MiuiInit  SurfaceFlinger  accessibility  account  activity  alarm  ...</code></pre><p>这个Currently running services   所有的项目,都可以详细查询</p></li><li><p>查询单个service  <code>adb shell dumpsys [service name]</code></p><p>搞几个例子看看:</p><ul><li>屏幕分辨率<code>adb shell dumpsys window displays</code></li></ul><pre><code>$ adb shell dumpsys window displaysWINDOW MANAGER DISPLAY CONTENTS (dumpsys window displays)  Display: mDisplayId=0    init=1080x1920 480dpi cur=1080x1920 app=1080x1920 rng=1080x1020-1920x1860    deferred=false mLayoutNeeded=false</code></pre><p>其中:</p><p>init=1080x1920  分辨率</p><p>480dpi   dpi值</p></li></ul><ul><li><p>activity信息<code>adb shell dumpsys activity</code></p><p>比如我想看看我activity的信息<code>adb shell dumpsys activity | grep &#39;com.yhcs.carmart&#39;</code></p><pre><code>$ adb shell dumpsys activity | grep &quot;com.yhcs.carmart&quot;  * com.yhcs.carmart: 2 items    #0: PendingIntentRecord{c526be3 com.yhcs.carmart startService}    #1: PendingIntentRecord{8949e0 com.yhcs.carmart broadcastIntent}      -&gt; 8161:com.yhcs.carmart/u0a460 s1/1 u0/0 +44s372ms      -&gt; 8556:com.yhcs.carmart:channel/u0a460 s1/1 u0/0 +33s684ms      ...  * Recent #0: TaskRecord{6019b81 #14799 A=com.yhcs.carmart U=0 StackId=1 sz=1}   packageName=com.yhcs.carmart processName=com.yhcs.carmart   launchedFromUid=10460 launchedFromPackage=com.yhcs.carmart userId=0   app=ProcessRecord{3c52934 8161:com.yhcs.carmart/u0a460}   Intent { cmp=com.yhcs.carmart/.ui.main.MainActivity }   frontOfTask=true task=TaskRecord{6019b81 #14799 A=com.yhcs.carmart U=0 StackId=1 sz=1}   taskAffinity=com.yhcs.carmart   realActivity=com.yhcs.carmart/.ui.main.MainActivity</code></pre><p>现在指定查看这个activity</p><pre><code>$ adb shell dumpsys activity com.yhcs.carmart/.ui.main.MainActivityTASK com.yhcs.carmart id=14799 userId=0  ACTIVITY com.yhcs.carmart/.ui.main.MainActivity a99200b pid=8161    Local Activity 90efa41 State:      mResumed=false mStopped=true mFinished=false      mChangingConfigurations=false      mCurrentConfig={1.0 460mcc11mnc [zh_CN] ldltr sw360dp w360dp h620dp 480dpi nrml long port finger -keyb/v/h -nav/h appBounds=Rect(0, 0 - 1080, 1920) s.12 themeChanged=0 themeChangedFlags=0}      ...View Hierarchy:      DecorView@ce71c9e[MainActivity]        android.widget.LinearLayout{6106377 V.E...... ......ID 0,0-1080,1920}      ...Active Fragments       ...</code></pre><p>里面有很多信息</p></li></ul>]]></content>
    
    
    <categories>
      
      <category>Android</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Android</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>OkHttp中添加https支持</title>
    <link href="undefined2018/01/10/OkHttp-support-https/"/>
    <url>2018/01/10/OkHttp-support-https/</url>
    
    <content type="html"><![CDATA[<p><strong>基础知识</strong></p><p>感觉就是一堆有信誉的机构,说: 我们这些机构的公钥是可信的,我们下面的小弟当然也是可以信任的啦</p><p>然后大家就去当人家小弟,就是可信的了….</p><p>当然这里面有的大佬不高兴,就自己搞一套证书,比如12306</p><a id="more"></a><p>Https中,值得注意的密钥有:</p><ul><li>服务器端的<code>公钥</code>和<code>私钥</code></li></ul><ul><li>客户端的<code>随机密钥</code></li></ul><p>值得注意的是一个HTTPS请求实际上就是两次HTTP传输.</p><p>1.客户端向服务器发起HTTPS请求，连接到服务器的443端口。</p><p>2.服务端收到请求,向客户端发送自己的<code>公钥</code></p><p>3.客户端收到服务器公钥,开始验证证书的合法性,我们知道系统内置了一些证书,应该是叫顶级证书吧</p><p>我们的证书并不是啥大机构发的,肯定不在里面,那么就没法验证合法.</p><pre><code> 合法 &gt; 继续 不合法 &gt; 此次Https请求终止</code></pre><p>4.客户端验证公钥合格后(也就是给你发消息的服务器是正经服务器)，那么客户端会生成一个 随机密码,客户端会拿着这个随机密码和刚才收到的服务器密钥做非对称加密 &gt;&gt; 得到密文的密码</p><p>——–以上第一次http请求结束了——–</p><p>5.客户端会发起HTTPS中的第二个HTTP请求,发送客户端密钥(密文)给服务器。</p><p>6.服务器收到密文，会用自己的私钥对其进行非对称解密,得到客户端刚才生成的客户端随机密码.</p><p>此时服务器使用客户端随机密码,对数据进行对称加密</p><p>7.把对称加密后的数据返回给客户端,客户端对称解密,OK    此次Https完美结束</p><p>——–整个https请求结束了——–</p><p>其中 , <code>对称加密</code>和<code>非对称加密</code>,  各司其职,共同完成整个请求.</p><p>  对称加密: 最快速,最简单</p><p>  非对称加密:速度慢,很安全,不需要把秘钥分发,客户端利用公钥加密的数据,只能是拥有秘钥的服务器解密</p><p>利用非对称加密的特性传递  客户端生成的随机密钥 ,达到只有服务器和客户端互相知道的密钥,从而使用密钥进行(高速简单的)对称加密数据.</p><p><strong>第一部分:信任所有</strong></p><p>这就是,我不管是谁传递的消息,不是你家服务器传递的消息,你也会信</p><p><strong>Api.java</strong> (提供okhttp实例,并创建Retroit服务)</p><pre><code> OkHttpClient okHttpClient = new OkHttpClient.Builder()                .hostnameVerifier(new HostnameVerifier() {                    @Override                    public boolean verify(String hostname, SSLSession session) {                        return true;                    }                })                .sslSocketFactory(createSSLSocketFactory())                .build(); ... //这里是创建一个SSLSocketFactory,提供给上面的 .sslSocketFactory() private  SSLSocketFactory createSSLSocketFactory() {        SSLSocketFactory ssfFactory = null;        try {            SSLContext sc = SSLContext.getInstance(&quot;TLS&quot;);            sc.init(null, new TrustManager[]{new TrustAllCerts()}, new SecureRandom());            ssfFactory = sc.getSocketFactory();        } catch (Exception e) {        }        return ssfFactory;    }</code></pre><p>其中涉及到<strong>TrustAllCerts.java</strong>,可以看到只是实现X509TrustManager,所有方法都是默认实现</p><pre><code>/** * If you have any questions, you can contact by email { wangzhumoo@gmail.com} * @author 王诛魔 2018/1/8 下午2:25 */public class TrustAllCerts implements X509TrustManager {    @Override    public void checkClientTrusted(X509Certificate[] chain, String authType) throws CertificateException {}    @Override    public void checkServerTrusted(X509Certificate[] chain, String authType) throws CertificateException {}    @Override    public X509Certificate[] getAcceptedIssuers() {        return new X509Certificate[0];    }}</code></pre><p>这里就以及可以了,信任所有的连接</p><hr><p><strong>第二部分:(强验证)</strong></p><p>我只信任证书合法的服务器传递的数据.</p><ul><li>查看Https的证书</li></ul><p><img src="images/https_zhengshu.png" srcset="/img/loading.gif" alt="https证书"></p><p>在浏览器上看到这个,这个已经是我把证书添加为信任了,所以他是一个 <code>安全</code> 的标志</p><ul><li>分析</li></ul><p><img src="images/https_root.png" srcset="/img/loading.gif" alt="https证书"></p><p>这里是我查看当前网站证书的结构</p><p>最顶—是根证书,到期时间是2028年</p><p>最底—是我司证书,到期时间是2018.12.9日</p><p>这里我们可以发现,我们网站的证书是有时间限制的,那么就会有一个问题,到了2018.12.9这一天怎么办.</p><blockquote><p>我也不知道会怎么样,应该是续签吧!那么万一这个证书变化了怎么办?</p></blockquote><p>所以,我们应该把根证书置为信任.</p><ul><li>下载保存</li></ul><p><img src="images/https_save.png" srcset="/img/loading.gif" alt="https证书"></p><p>Mac的在  钥匙串访问  中</p><p>Windows 没法放图,在chrome上查看证书的时候应该就能保存.</p><p><strong>HttpsUtils.java </strong></p><pre><code>/** * If you have any questions, you can contact by email { wangzhumoo@gmail.com} * @author 王诛魔 2018/1/10 下午5:07 * 支持https的工具类 */public class HttpsUtils {    private static final String TAG = &quot;OkHttp&quot;;    /**     * 创建一个空白的KeyStore     * @return KeyStore     * @throws GeneralSecurityException     */    private static KeyStore createEmptyKeyStore() throws GeneralSecurityException {        try {            KeyStore keystore = KeyStore.getInstance(KeyStore.getDefaultType());            //此处密码随意,不会产生问题            keystore.load(null, &quot;password&quot;.toCharArray());            return keystore;        } catch (IOException e) {            return null;        }    }    /**     * TrustManager  生成     * @return     * @throws GeneralSecurityException     */    private static TrustManager[] generateTrustManager() throws GeneralSecurityException {        //创建一个X.509格式的CertificateFactory        CertificateFactory certificateFactory = CertificateFactory.getInstance(&quot;X.509&quot;);        Certificate ca;        //证书工厂根据证书文件的流生成证书Certificate        InputStream assets = App.getContext().getResources().openRawResource(R.raw.rootca);        ca = certificateFactory.generateCertificate(assets);        Log.e(TAG, &quot;trustManager: ca = &quot; + ((X509Certificate) ca).getSubjectDN() );        //创建KeyStore，用来存储信任证书        KeyStore keyStor = createEmptyKeyStore();        keyStor.setCertificateEntry(&quot;ca&quot;,ca);        //创建一个默认类型的TrustManagerFactory        String defaultAlgorithm = TrustManagerFactory.getDefaultAlgorithm();        TrustManagerFactory tmf = TrustManagerFactory.getInstance(defaultAlgorithm);        //用keyStore实例初始化TrustManagerFactory,此时TrustManagerFactory会信任我们保存的证书        tmf.init(keyStor);        //通过tmf获取TrustManager数组，TrustManager也会信任keyStor中的证书        return tmf.getTrustManagers();    }    /**     * 提供一个一个SSLSocketFactory     * @return SSLSocketFactory实例     */    public static SSLSocketFactory generateSSLSocketFactory()  {        try {            SSLContext sc = SSLContext.getInstance(&quot;TLS&quot;);            sc.init(null, generateTrustManager(), new SecureRandom());            Log.e(TAG, &quot;generateSSLSocketFactory &quot;);            return sc.getSocketFactory();        } catch (GeneralSecurityException e) {            return null;        }    }}</code></pre><p>注释很清楚了.</p><p><strong>关键:</strong></p><p>1.拿到帧数的流</p><pre><code>InputStream assets = App.getContext().getResources().openRawResource(R.raw.rootca);</code></pre><p>2.保存到keystore</p><pre><code>KeyStore keyStor = createEmptyKeyStore();keyStor.setCertificateEntry(&quot;ca&quot;,ca);</code></pre><p>3.初始化并拿到TrustManager[]</p><pre><code>tmf.init(keyStor);tmf.getTrustManagers()</code></pre><p><strong>使用即可:</strong></p><pre><code>//这样就OkOkHttpClient okHttpClient = new OkHttpClient.Builder()                .hostnameVerifier((hostname, session) -&gt; true)                .sslSocketFactory(HttpsUtils.generateSSLSocketFactory())                .build();</code></pre><blockquote><p>超好的两篇</p><p><a href="http://blog.csdn.net/lmj623565791/article/details/48129405" target="_blank" rel="noopener">http://blog.csdn.net/lmj623565791/article/details/48129405</a></p><p><a href="http://blog.csdn.net/iispring/article/details/51615631" target="_blank" rel="noopener">http://blog.csdn.net/iispring/article/details/51615631</a></p></blockquote>]]></content>
    
    
    
    <tags>
      
      <tag>Android</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>WebView播放H5视屏没有画面,只有声音</title>
    <link href="undefined2018/01/04/webview-video-without-image/"/>
    <url>2018/01/04/webview-video-without-image/</url>
    
    <content type="html"><![CDATA[<p><strong>描述:点击播放按钮后,只能听到声音,而画面是白的….一直白…想到应该是硬件加速的问题</strong></p><p><strong>1.确认硬件加速(非此因素)</strong></p><p>在WebViewActivity.java中发现</p><pre><code>webView.setLayerType(View.LAYER_TYPE_HARDWARE, null);</code></pre><p><strong>2.确认AndroidManifest.xml(非此因素)</strong></p><p>application节点下并没有发现</p><pre><code>android:hardwareAccelerated=&quot;true&quot;</code></pre><p>在WebViewActivity中,也无该配置</p><ul><li>尝试: WebViewActivity.java中,注释</li></ul><pre><code>#webView.setLayerType(View.LAYER_TYPE_HARDWARE, null);</code></pre><p>在AndroidManifest.xml节点下加入<code>android:hardwareAccelerated=&quot;true&quot;</code></p><ul><li>结果……没用</li></ul><p><strong>3.检查activity_web_view.xml</strong></p><pre><code class="xml">        &lt;WebView            android:id=&quot;@+id/webView&quot;            android:layout_width=&quot;match_parent&quot;            android:layout_height=&quot;match_parent&quot;            android:scrollbars=&quot;none&quot;            android:visibility=&quot;@{showError?View.GONE:View.VISIBLE}&quot; /&gt;</code></pre><p>没问题.</p><p>BUT….</p><pre><code class="xml">&lt;LinearLayout    android:layerType=&quot;software&quot;    android:layout_width=&quot;match_parent&quot;    android:layout_height=&quot;match_parent&quot;    android:orientation=&quot;vertical&quot;&gt;    &lt;include layout=&quot;@layout/layout_toolbar&quot; /&gt;    &lt;ProgressBar        android:id=&quot;@+id/web_load_progress&quot;        style=&quot;?android:attr/progressBarStyleHorizontal&quot;        android:layout_width=&quot;match_parent&quot;        android:layout_height=&quot;2dp&quot;        android:indeterminateOnly=&quot;false&quot;        android:max=&quot;100&quot;        android:progress=&quot;@{progress}&quot;        android:progressDrawable=&quot;@drawable/progress_bar_states&quot;        android:visibility=&quot;gone&quot; /&gt;    &lt;WebView        android:id=&quot;@+id/webView&quot;        android:layout_width=&quot;match_parent&quot;        android:layout_height=&quot;match_parent&quot;        android:scrollbars=&quot;none&quot;        android:visibility=&quot;@{showError?View.GONE:View.VISIBLE}&quot; /&gt;&lt;/LinearLayout&gt;</code></pre><p>####父布局竟然<code>android:layerType=&quot;software&quot;</code></p><ul><li>解决,删掉该属性即可</li></ul>]]></content>
    
    
    <categories>
      
      <category>Bug</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Android</tag>
      
      <tag>Bug</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Room中List&lt;&gt;使用详解</title>
    <link href="undefined2018/01/03/room-list/"/>
    <url>2018/01/03/room-list/</url>
    
    <content type="html"><![CDATA[<blockquote><p>手摸手教你在Room中使用List<object>.</object></p></blockquote><p>实际项目有很多这样的结构:</p><pre><code>{  &quot;id&quot;: &quot;001&quot;,  &quot;name&quot;: &quot;王诛魔&quot;,  &quot;age&quot;: 2018,  &quot;books&quot;: [    {      &quot;bookId&quot;: 10081,      &quot;userId&quot;: 1,      &quot;book&quot;: &quot;断罪小学&quot;,      &quot;desc&quot;: &quot;漫画讲述了李杀神、王诛魔和刘斩仙三位少年，为了十万小学生的未来、为了改变被诅咒的命运，相聚在狼牙区飞虎路私立断罪小学，誓死打败四年级的魔神赵日天的故事。&quot;    },    {      &quot;bookId&quot;: 10088,      &quot;userId&quot;: 1,      &quot;book&quot;: &quot;狂霸天下之断罪学园&quot;,      &quot;desc&quot;: &quot;《狂霸天下之断罪学园》，后来因为名字太长，而且“学园”和“学院”容易混淆的原因而改名。&quot;    }  ]}</code></pre><a id="more"></a><p>也就是,类似books这样的,List<object>作为一个元素存在.</object></p><blockquote><p>下面就以上面的结构为例,做一个简单的演示,按照最简答的方法实现.</p></blockquote><p><strong>1.添加依赖</strong></p><p><a href="https://developer.android.google.cn/topic/libraries/architecture/adding-components.html" target="_blank" rel="noopener">https://developer.android.google.cn/topic/libraries/architecture/adding-components.html</a></p><p>值得注意的是,如果你在kotlin中使用</p><pre><code class="java">apply plugin: &#39;kotlin-kapt&#39;...dependencies{  ...      //这个无法生成代码,要用下面的那一条,不要疏忽忘掉了.    //annotationProcessor &quot;android.arch.persistence.room:compiler:1.0.0&quot;    kapt &quot;android.arch.persistence.room:compiler:1.0.0&quot;}</code></pre><p>一定记得使用kapt,要不然就会遇到这个BUG.</p><p><strong>2.创建表</strong></p><ul><li><p>User.java表</p><pre><code class="java">/** * If you have any questions, you can contact by email { wangzhumoo@gmail.com} * @author 王诛魔 2018/1/3 下午1:31 */@Entity(tableName = &quot;users&quot;)public class User {    @PrimaryKey    public int id;    public String name;    public int age;}</code></pre><p>@Entity 中指定了表名</p><p>@PrimaryKey 主键</p><p>这张表users 用于保存用户数据</p></li></ul><ul><li><p>Book.java表</p><pre><code class="java">/** * If you have any questions, you can contact by email { wangzhumoo@gmail.com} * @author 王诛魔 2018/1/3 下午1:30 */@Entity(foreignKeys = {        @ForeignKey(                entity = User.class,                parentColumns ={&quot;id&quot;},                childColumns = {&quot;userId&quot;})},tableName = &quot;books&quot;)public class Book {    @PrimaryKey    public int bookId;    public int userId;//同User.java中的id    public String book;    public String desc;}</code></pre><p>@Entity 中</p><ul><li>foreignKeys = {} 中外键,可以是多个,这里只关联了User表</li><li>tableName = “books” 指定了表名</li></ul><p>@PrimaryKey 该表主键</p></li></ul><ul><li><p>UserAndBook.java表 —-UserAndBook只是辅助,不作为一张表存在.</p><pre><code class="Java">/** * If you have any questions, you can contact by email { wangzhumoo@gmail.com} * @author 王诛魔 2018/1/3 下午1:43 */public class UserAndBook {    @Embedded   //请看之前的文章,这是指把User中所有元素带入到这里作为元素存在    public User userEntity;      //@Relation    @Relation(parentColumn = &quot;id&quot;,entityColumn = &quot;userId&quot;,entity = Book.class)    public List&lt;Book&gt; books;}</code></pre><p>@Embedded   请看另一篇,有解释</p></li></ul><p>  @Relation <a href="https://developer.android.google.cn/reference/android/arch/persistence/room/Relation.html" target="_blank" rel="noopener"> 点这里去看官方文档  </a></p><blockquote><p>A convenience annotation which can be used in a Pojo to automatically fetch relation entities. When the Pojo is returned from a query, all of its relations are also fetched by Room.</p></blockquote><p>  个人以为就是一注解,指明关系,可以把实体关联起来,然后自动组装起来.   </p><p>  并且在文档中还展示了一种高端的功能,用上面做例</p><pre><code class="java">  //@Relation      @Relation(parentColumn = &quot;id&quot;,entityColumn = &quot;userId&quot;,                entity = Book.class ,projection = {&quot;book&quot;})      public List&lt;String&gt; bookNames;</code></pre><p>  解释一下,projection指定了要取出的值,当前指明要在 books表中寻找符合条件parentColumn = “id”,entityColumn = “userId”   的项,找到之后会拿到book这个值并返回.</p><p><strong>3.Dao实现</strong></p><pre><code class="java">/** * If you have any questions, you can contact by email { wangzhumoo@gmail.com} * @author 王诛魔 2018/1/3 下午4:20 */@Daopublic abstract class UserAndBookDao {    @Insert(onConflict = OnConflictStrategy.REPLACE)    public abstract void insert(User user);    @Insert(onConflict = OnConflictStrategy.REPLACE)    public abstract void insert(List&lt;Book&gt; books);    @Transaction    public void insert(UserAndBook userAndBook){        insert(userAndBook.userEntity);        insert(userAndBook.books);    }    @Query(&quot;SELECT * FROM users&quot;)    public abstract List&lt;UserAndBook&gt; getAll();}</code></pre><p><code>insert(User user);</code>  ,<code>insert(List&lt;Book&gt; books);</code></p><p>两个方法,也可以私有化,只对外提供<code>insert(UserAndBook userAndBook)</code></p><p>最近换公司项目的数据库,用sql,真的有意思,可以很方便的实现很多功能</p><p><strong>4.建立数据库</strong></p><pre><code class="java">/** * If you have any questions, you can contact by email { wangzhumoo@gmail.com} * @author 王诛魔 2017/10/24 上午10:13 * 数据库 */@Database(entities = {Book.class, User.class},           version = 1, exportSchema = false)public abstract class AppDB extends RoomDatabase {    private static final String TAG = &quot;AppDB&quot;;    /**     * 数据库实例     */    private static AppDB sInstance;    private static String DATABASE_NAME = &quot;developer.db&quot;;    private ObservableBoolean mIsDatabaseCreated = new ObservableBoolean(false);    public abstract UserAndBookDao userbook();    /**     * 单例     * @param context     * @return     */    public static AppDB getInstance(Context context) {        if (sInstance == null) {            synchronized (AppDB.class) {                if (sInstance == null) {                    sInstance = buildDatabase(context);                    sInstance.updateDatabaseCreated(context);                }            }        }        return sInstance;    }    /**     * Build the database.     * creates a new instance of the database.     */    private static AppDB buildDatabase(Context appContext) {         AppDB appDB = Room.databaseBuilder(appContext, AppDB.class, DATABASE_NAME)                .addCallback(new Callback() {                    @Override                    public void onCreate(@NonNull SupportSQLiteDatabase db) {                        super.onCreate(db);                        AppDB database = AppDB.getInstance(appContext);                        database.setDatabaseCreated();                    }                    @Override                    public void onOpen(@NonNull SupportSQLiteDatabase db) {                        super.onOpen(db);                        Log.e(TAG, &quot;onOpen: &quot; + db.getPath());                    }                }).build();        return appDB;    }    /**     * Check whether the database already exists and expose it via      */    private void updateDatabaseCreated(final Context context) {        if (context.getDatabasePath(DATABASE_NAME).exists()) {            setDatabaseCreated();        }    }    private void setDatabaseCreated() {        mIsDatabaseCreated.set(true);    }    public ObservableBoolean getDatabaseCreated() {        return mIsDatabaseCreated;    }}</code></pre><p>为了方便使用,在Application中添加了</p><pre><code class="java">public static AppDB getDatabase() {    return AppDB.getInstance(context);}</code></pre><p><strong>5.使用</strong></p><p>这里的使用方式,不建议使用,太粗暴了.</p><p>可以学学Demo,Google出的<a href="https://github.com/googlesamples/android-architecture-components" target="_blank" rel="noopener">googlesamples/android-architecture-components</a></p><pre><code class="java">class RoomActivity : BindingActivity&lt;ActivityRoomBinding, RoomViewModel&gt;() {    val gson = Gson()    override fun getBundle(extras: Bundle) {    }    override fun layoutID(): Int = R.layout.activity_room    override fun initViews(savedInstanceState: Bundle?) {        //点击事件  ADD按钮,添加数据到数据库        mBindingView.button.setOnClickListener({            val userBook = UserAndBook()            val jsonStr = FileUtils.getJson(this, &quot;data.txt&quot;)            val objectJson = JsonParser().parse(jsonStr).asJsonObject            //获取用户            val user = objectJson.get(&quot;user&quot;)            userBook.userEntity = gson.fromJson&lt;User&gt;(user, User::class.java)            //保存用户            Observable                .empty&lt;Any&gt;()                .observeOn(Schedulers.io())                .subscribe(object : EmptyObserver&lt;Any?&gt;() {                    override fun onComplete() {                        App.getDatabase().userbook().insert(userBook.userEntity)                    }                })            //获取书籍            val books = objectJson.get(&quot;books&quot;)            userBook.books = gson.fromJson&lt;ArrayList&lt;Book&gt;&gt;                                (books, object : TypeToken&lt;List&lt;Book&gt;&gt;() {}.type)            //保存书籍            Observable                .empty&lt;Any&gt;()                .observeOn(Schedulers.io())                .subscribe(object : EmptyObserver&lt;Any?&gt;() {                        override fun onComplete() {                        App.getDatabase().userbook().insert(userBook.books)                    }                })        })        //点击事件,按钮QUERY   查询数据        mBindingView.button2.setOnClickListener {            Flowable.create(FlowableOnSubscribe&lt;List&lt;UserAndBook&gt;&gt; { e -&gt;                val userBook = App.getDatabase().userbook().all                e.onNext(userBook)                e.onComplete()            }, BackpressureStrategy.DROP)                    .compose(DatabaseTransformer())                    .subscribe(object : DatabaseSubscriber&lt;List&lt;UserAndBook&gt;&gt;() {                        override fun onNext(userAndBooks: List&lt;UserAndBook&gt;) {                            mBindingView.data = userAndBooks[0]                        }                    })        }    }}</code></pre><pre><code class="xml">&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;&lt;layout    xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;&gt;    &lt;data&gt;        &lt;import type=&quot;com.wangzhumo.app.data.UserAndBook&quot;/&gt;        &lt;import type=&quot;com.wangzhumo.app.data.User&quot;/&gt;        &lt;import type=&quot;com.wangzhumo.app.data.Book&quot;/&gt;        &lt;variable            name=&quot;data&quot;            type=&quot;com.wangzhumo.app.data.UserAndBook&quot;/&gt;    &lt;/data&gt;    &lt;RelativeLayout        android:layout_width=&quot;match_parent&quot;        android:layout_height=&quot;match_parent&quot;&gt;        &lt;Button            android:id=&quot;@+id/button&quot;            android:layout_width=&quot;wrap_content&quot;            android:layout_height=&quot;wrap_content&quot;            android:layout_alignParentLeft=&quot;true&quot;            android:layout_alignParentStart=&quot;true&quot;            android:layout_alignParentTop=&quot;true&quot;            android:layout_marginLeft=&quot;57dp&quot;            android:layout_marginStart=&quot;57dp&quot;            android:layout_marginTop=&quot;125dp&quot;            android:text=&quot;Add&quot; /&gt;        &lt;Button            android:id=&quot;@+id/button2&quot;            android:layout_width=&quot;wrap_content&quot;            android:layout_height=&quot;wrap_content&quot;            android:layout_alignBaseline=&quot;@+id/button&quot;            android:layout_alignBottom=&quot;@+id/button&quot;            android:layout_alignParentEnd=&quot;true&quot;            android:layout_alignParentRight=&quot;true&quot;            android:layout_marginEnd=&quot;56dp&quot;            android:layout_marginRight=&quot;56dp&quot;            android:text=&quot;Query&quot; /&gt;        &lt;RelativeLayout            android:layout_width=&quot;match_parent&quot;            android:layout_height=&quot;match_parent&quot;            android:layout_alignParentLeft=&quot;true&quot;            android:layout_alignParentStart=&quot;true&quot;            android:layout_below=&quot;@+id/button&quot;            android:layout_marginTop=&quot;68dp&quot;&gt;            &lt;TextView                android:id=&quot;@+id/textView&quot;                android:layout_width=&quot;wrap_content&quot;                android:layout_height=&quot;wrap_content&quot;                android:layout_alignParentLeft=&quot;true&quot;                android:layout_alignParentStart=&quot;true&quot;                android:layout_alignParentTop=&quot;true&quot;                android:layout_marginLeft=&quot;36dp&quot;                android:layout_marginStart=&quot;36dp&quot;                android:layout_marginTop=&quot;32dp&quot;                android:text=&quot;@{data.userEntity.name}&quot; /&gt;            &lt;TextView                android:id=&quot;@+id/textView2&quot;                android:layout_width=&quot;wrap_content&quot;                android:layout_height=&quot;wrap_content&quot;                android:layout_alignLeft=&quot;@+id/textView&quot;                android:layout_alignStart=&quot;@+id/textView&quot;                android:layout_below=&quot;@+id/textView&quot;                android:layout_marginTop=&quot;41dp&quot;                android:text=&quot;@{data.books.get(0).book}&quot; /&gt;            &lt;TextView                android:id=&quot;@+id/textView3&quot;                android:layout_width=&quot;wrap_content&quot;                android:layout_height=&quot;wrap_content&quot;                android:layout_alignLeft=&quot;@+id/textView2&quot;                android:layout_alignStart=&quot;@+id/textView2&quot;                android:layout_centerVertical=&quot;true&quot;                android:text=&quot;@{data.books.get(0).desc}&quot; /&gt;        &lt;/RelativeLayout&gt;    &lt;/RelativeLayout&gt;&lt;/layout&gt;</code></pre><p><img src="images/room_shot.png" srcset="/img/loading.gif" alt="如图"></p><p>​    </p><p>​     </p>]]></content>
    
    
    <categories>
      
      <category>Android</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Android</tag>
      
      <tag>Room</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Android字体不跟随系统变化</title>
    <link href="undefined2017/12/28/Android-Font-Size/"/>
    <url>2017/12/28/Android-Font-Size/</url>
    
    <content type="html"><![CDATA[<p>已知的方法有两种:</p><p><strong>第一种</strong></p><p>不使用sp 而使用 dp</p><p><strong>第二种</strong></p><p>在Application中加入</p><pre><code>@Overridepublic void onConfigurationChanged(Configuration newConfig) {    if (newConfig.fontScale != 1)        getResources();    super.onConfigurationChanged(newConfig);}@Overridepublic Resources getResources() {     Resources res = super.getResources();     if (res.getConfiguration().fontScale != 1) {        Configuration newConfig = new Configuration();        newConfig.setToDefaults();        res.updateConfiguration(newConfig, res.getDisplayMetrics());      }     return res;}</code></pre>]]></content>
    
    
    <categories>
      
      <category>Android</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Android</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Apk Install 的各种问题</title>
    <link href="undefined2017/12/28/Apk-Install-Error/"/>
    <url>2017/12/28/Apk-Install-Error/</url>
    
    <content type="html"><![CDATA[<p><strong>[INSTALL_FAILED_TEST_ONLY: installPackageLI]</strong></p><ul><li><p>方法1：<br>AndroidManifest.xml 加入android:testOnly=”false”。</p></li><li><p>方法2：<br>adb install -t *.apk</p></li></ul>]]></content>
    
    
    <categories>
      
      <category>Bug</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Android</tag>
      
      <tag>Bug</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Android Studio报错Error Running app: cannot debug application</title>
    <link href="undefined2017/12/26/Android-Studio-Error-Running-app-cannot-debug-application/"/>
    <url>2017/12/26/Android-Studio-Error-Running-app-cannot-debug-application/</url>
    
    <content type="html"><![CDATA[<p>Android Studio报错Error Running app: cannot debug application</p><a id="more"></a><p>这里有一位仁兄帮忙翻译了.</p><blockquote><p><a href="http://blog.csdn.net/yishichangan1/article/details/77451486" target="_blank" rel="noopener">http://blog.csdn.net/yishichangan1/article/details/77451486</a></p></blockquote><pre><code>Cannot debug application xx.xxx.xxx.app on device lge_nexus_5x(此处表示你的手机型号).你的xxxapp不能在型号为Nexus 5x的LGE手机上调试。This application does not have the debuggable attribute enabled in its manifest.这个项目在清单文件（AndroidManifest.xml）中没有设置可以调试的参数。If you have manually set it in the manifest, then remove it and let the IDE automatically assign it.如果你已经手动在清单文件种设置了这个属性，请remove掉，让IDE自动生成。If you are using Gradle, make sure that your current variant is debuggable.如果你使用Gradle，确认你现在的变体是可调试的。</code></pre><p>####我就知道是我自己选了release….果然</p><p><img src="/images/canot_debug.png" srcset="/img/loading.gif" alt="cannotdebug"></p>]]></content>
    
    
    <categories>
      
      <category>Bug</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Android</tag>
      
      <tag>Android Studio</tag>
      
      <tag>Bug</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Centos 创建用户并实现免密码登录</title>
    <link href="undefined2017/12/25/Centos-Login-SSH/"/>
    <url>2017/12/25/Centos-Login-SSH/</url>
    
    <content type="html"><![CDATA[<blockquote><p>比如,创建一个名为wzm的账号</p></blockquote><p>####创建账号</p><p>1.创建</p><pre><code>[root@localhost ~]# adduser wzm[root@localhost ~]# passwd wzm#此时,输入两次密码即可</code></pre><a id="more"></a><p>2.赋予sudo</p><pre><code>#找到sudoers[root@localhost ~]# whereis sudoers#修改sudoers的读写权限[root@localhost ~]# chmod -v u+w /etc/sudoers#加入新用户## Allow root to run any commands anywher  root    ALL=(ALL)       ALL  linuxidc  ALL=(ALL)       ALL  #这个是新增的用户#把sudoers权限还给他[root@localhost ~]# chmod -v u-w /etc/sudoers</code></pre><p>3.尽情享用吧</p><p>####ssh免密码登录</p><p>1.修改配置文件<br><code>sudo vim /etc/ssh/sshd_config</code></p><p>2.重启ssh服务<br><code>service sshd restart</code></p><p>3.生成密钥</p><pre><code>ssh-keygen -t rsa     默认在 ~/.ssh目录生成两个文件：    id_rsa      ：私钥    id_rsa.pub  ：公钥</code></pre><p>4.导入本机<br><code>cat ~/.ssh/id_rsa.pub &gt;&gt; ~/.ssh/authorized_keys</code></p><p>5.下载到客户端并设置</p><pre><code>scp [-r] 用户名@ip:文件路径 本地路径#下载文件scp [-r] 本地文件 用户名@ip:上传路径 eg:~/.ssh ⌚ 16:27:33$ scp id_rsa.pub root@45.XX.XX.XX:/home/id_rsa.pub</code></pre><p>6.改权限<br>如果希望ssh公钥生效需满足至少下面两个条件：　　　　　<br>1) .ssh目录的权限必须是700<br>2) .ssh/authorized_keys文件权限必须是600</p><p>eg:</p><pre><code>~ ⌚ 16:33:21$ ssh wzm@45.XX.XX.XXLast login: Mon Dec 25 16:21:11 2017 from 118.102.XXX.XXX[wzm@wangzhumo ~]$</code></pre>]]></content>
    
    
    <categories>
      
      <category>Server</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Server</tag>
      
      <tag>Linux</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Android项目中使用RxBus进行通讯</title>
    <link href="undefined2017/12/25/Android-RxBus/"/>
    <url>2017/12/25/Android-RxBus/</url>
    
    <content type="html"><![CDATA[<p>加入JakeWharton大神的RxRelay</p><p><a href="https://github.com/JakeWharton/RxRelay" target="_blank" rel="noopener">JakeWharton/RxRelay</a></p><pre><code>compile &#39;com.jakewharton.rxrelay2:rxrelay:2.0.0&#39;</code></pre><a id="more"></a><p>RxBus.java</p><pre><code>/** * If you have any questions, you can contact by email {wangzhumoo@gmail.com} * @author 王诛魔 2017/11/30 下午6:09 * */public class RxBus {    private Relay&lt;Object&gt; mBus = null;    private static volatile RxBus mDefaultInstance;    public RxBus() {        mBus = PublishRelay.create().toSerialized();    }    public static RxBus getDefault() {        if (mDefaultInstance == null) {            synchronized (RxBus.class) {                if (mDefaultInstance == null) {                    mDefaultInstance = new RxBus();                }            }        }        return mDefaultInstance;    }    /**     * 发送事件     */    public void post(Object event) {        mBus.accept(event);    }    /**     * 根据传递的 eventType 类型返回特定类型(eventType)的 被观察者     */    public &lt;T&gt; Observable&lt;T&gt; toObservable(Class&lt;T&gt; eventType) {        return mBus.ofType(eventType);    }    /**     * 判断是否有订阅者     */    public boolean hasObservers() {        return mBus.hasObservers();    }    /**     * 取消订阅     * @param disposable     */    public void unregister(Disposable disposable) {        if (disposable != null &amp;&amp; !disposable.isDisposed()) {            disposable.dispose();        }    }    public &lt;T&gt; Disposable register(Class&lt;T&gt; eventType, Scheduler scheduler, Consumer&lt;T&gt; onNext) {        return toObservable(eventType).observeOn(scheduler).subscribe(onNext);    }    public &lt;T&gt; Disposable register(Class&lt;T&gt; eventType, Scheduler scheduler, Consumer&lt;T&gt; onNext, Consumer onError,                                   Action onComplete, Consumer onSubscribe) {        return toObservable(eventType).observeOn(scheduler).subscribe(onNext, onError, onComplete, onSubscribe);    }    public &lt;T&gt; Disposable register(Class&lt;T&gt; eventType, Scheduler scheduler, Consumer&lt;T&gt; onNext, Consumer onError,                                   Action onComplete) {        return toObservable(eventType).observeOn(scheduler).subscribe(onNext, onError, onComplete);    }    public &lt;T&gt; Disposable register(Class&lt;T&gt; eventType, Scheduler scheduler, Consumer&lt;T&gt; onNext, Consumer onError) {        return toObservable(eventType).observeOn(scheduler).subscribe(onNext, onError);    }    public &lt;T&gt; Disposable register(Class&lt;T&gt; eventType, Consumer&lt;T&gt; onNext) {        return toObservable(eventType).observeOn(AndroidSchedulers.mainThread()).subscribe(onNext);    }    public &lt;T&gt; Disposable register(Class&lt;T&gt; eventType, Consumer&lt;T&gt; onNext, Consumer onError, Action onComplete, Consumer onSubscribe) {        return toObservable(eventType).observeOn(AndroidSchedulers.mainThread()).subscribe(onNext, onError, onComplete, onSubscribe);    }    public &lt;T&gt; Disposable register(Class&lt;T&gt; eventType, Consumer&lt;T&gt; onNext, Consumer onError, Action onComplete) {        return toObservable(eventType).observeOn(AndroidSchedulers.mainThread()).subscribe(onNext, onError, onComplete);    }    public &lt;T&gt; Disposable register(Class&lt;T&gt; eventType, Consumer&lt;T&gt; onNext, Consumer onError) {        return toObservable(eventType).observeOn(AndroidSchedulers.mainThread()).subscribe(onNext, onError);    }}</code></pre><p>还有一个通用的Event.java<br>依据自己的需要制定即可</p><pre><code>/** * If you have any questions, you can contact by email {wangzhumoo@gmail.com} * @author 王诛魔 2017/10/19 下午5:38 * * 发送事件包装类 */public class Event&lt;T&gt; {    public static final int EVENT_CLOSE_ALL_ACTIVITY = 10001;    /**     * reserved data     */    private T data;    /**     * this code distinguish between different events     */    private int eventCode = -1;    public Event(int eventCode) {        this(eventCode, null);    }    public Event(int eventCode, T data) {        this.eventCode = eventCode;        this.data = data;    }    /**     * get event code     *     * @return     */    public int getCode() {        return this.eventCode;    }    /**     * get event reserved data     *     * @return     */    public T getData() {        return this.data;    }}</code></pre><p><strong>RxBus的使用</strong></p><p><strong>注册</strong></p><p>最好是再基类中,加上.</p><pre><code>if (useEventBus()) {            //注册eventbus            Disposable disposable = RxBus.getDefault()                    .register(Event.class, new Consumer&lt;Event&gt;() {                        @Override                        public void accept(Event event)  {                            int eventCode = event.getCode();                            Log.e(&quot;RxBus&quot;, event.toString());                            switch (eventCode) {                                case Event.EVENT_CLOSE_ALL_ACTIVITY:                                    break;                                default:                                    onEvent(event);                                    break;                            }                        }                    });            addDispose(disposable);}</code></pre><p>其中:</p><ul><li><p>useEventBus()<br>由子类实现,是否开启RxBus,避免浪费</p></li><li><p>addDispose(disposable);<br>addDispose 是基类的方法</p></li></ul><pre><code>    /**     * RxJava 添加订阅     */    protected void addDispose(Disposable disposable) {        if (mDisposables == null) {            mDisposables = new CompositeDisposable();        }        //将所有disposable放入,集中处理        mDisposables.add(disposable);    }</code></pre><p>统一管理,销毁时一起销毁,避免爆内存</p><ul><li>onEvent(event);<br>是一个空方法,如果子类重写就把事件交给子类处理</li></ul><p><strong>发送</strong></p><pre><code>RxBus.getDefault().post(new Event(100,&quot;message&quot;))//code最好在Event.java中统一定义,方便管理</code></pre><p><strong>处理</strong></p><pre><code>override fun onEvent(event: Event&lt;*&gt;?) {    super.onEvent(event)}</code></pre><p>这一部分,其实在 <strong>注册</strong> 中已经完成,只要子类自己重写方法,就能取到数据</p>]]></content>
    
    
    <categories>
      
      <category>Android</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Rxjava</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Nginx安装及其简单配置</title>
    <link href="undefined2017/12/25/Nginx-install-config/"/>
    <url>2017/12/25/Nginx-install-config/</url>
    
    <content type="html"><![CDATA[<p>环境: centos7</p><p><strong>1.下载安装</strong></p><p>下载nginx-1.12.0,官网<br><code>sudo wget http://nginx.org/download/nginx-1.12.0.tar.gz</code></p><p>解压<br><code>sudo tar -zxvf nginx-1.12.0.tar.gz</code></p><p>其他的库,nginx依赖的库</p><ul><li>安装gcc<br><code>yum -y install gcc</code></li><li>安装pcre<br><code>yum -y install pcre pcre-devel</code></li><li>安装zlib<br><code>yum -y install zlib zlib-devel</code></li><li>安装openssl<br><code>yum -y install openssl openssl-devel</code></li></ul><p>安装</p><pre><code>sudo ./configuresudo makesudo make install</code></pre><blockquote><p>默认位置 /usr/local/nginx</p></blockquote><p>如果安装过程中出现文件目录权限问题,百度即可解决.</p><a id="more"></a><p><strong>2.系统中配置</strong></p><p>1.在系统服务目录里创建nginx.service文件</p><pre><code>vim /lib/systemd/system/nginx.service</code></pre><pre><code>[Unit]Description=nginxAfter=network.target[Service]Type=forkingExecStart=/usr/local/nginx/sbin/nginxExecReload=/usr/local/nginx/sbin/nginx -s reloadExecStop=/usr/local/nginx/sbin/nginx -s quitPrivateTmp=true[Install]WantedBy=multi-user.target</code></pre><p>2.设置开机启动</p><p><code>systemctl enable nginx.service</code></p><p>3.其他命令</p><p>启动nginx服务<code>systemctl start nginx.service</code></p><p>设置开机自启动<code>systemctl enable nginx.service</code></p><p>停止开机自启动<code>systemctl disable nginx.service</code></p><p>查看服务当前状态<code>systemctl status nginx.service</code></p><p>重新启动服务<code>systemctl restart nginx.service</code></p><p>查看所有已启动的服务 <code>systemctl list-units --type=service</code></p><p><strong>3.nginx.conf的配置</strong></p><pre><code>[root@wangzhumo hooks]# cd /usr/local/nginx/[root@wangzhumo nginx]# lltotal 96drwx------ 2 root root  4096 Dec 24 20:57 client_body_tempdrwxr-xr-x 3 root root  4096 Dec 24 23:24 confdrwx------ 2 root root  4096 Dec 24 20:57 fastcgi_tempdrwxr-xr-x 2 root root  4096 Dec 23 10:38 htmldrwxr-xr-x 2 root root  4096 Dec 24 22:43 logs-rw-r--r-- 1 root root 53861 Dec 25 13:37 ondrwx------ 2 root root  4096 Dec 24 20:57 proxy_tempdrwxr-xr-x 2 root root  4096 Dec 23 10:38 sbindrwx------ 2 root root  4096 Dec 24 20:57 scgi_tempdrwx------ 2 root root  4096 Dec 24 20:57 uwsgi_temp</code></pre><p>其中/conf存放配置文件/conf/nginx.conf<br><code>vim /conf/nginx.conf</code></p><p>什么都不要动,在nginx.conf第一条server配置下面写入:<br><code>include vhost/*.conf;</code></p><pre><code> } #此处是第一条可用的server的结束    #加入这句,其实是把其他地方配置的配置文件加载到里面来    #主要是为了方便管理,修改    include vhost/*.conf;    # another virtual host using mix of IP-, name-, and port-based configuration    #    #server {    #    listen       8000;    #    listen       somename:8080;    #    server_name  somename  alias  another.alias;    #    location / {    #        root   html;    #        index  index.html index.htm;    #    }    #}</code></pre><p><strong>3.1 /vhost/*.conf的配置</strong></p><p>当前目录到<br><code>cd /usr/local/nginx/conf</code></p><p>创建目录vhost<br><code>mkdir /usr/local/nginx/conf/vhost</code></p><p>创建.conf文件(我只用到hexo的配置,所以只有一个配置文件)<br><code>vim /usr/local/nginx/conf/vhost/hexo.conf</code></p><pre><code>server{    listen 80;    #listen [::]:80;    server_name www.phyooos.top phyooos.top;    index index.html index.htm index.php default.html default.htm default.php;    #web root path    root  /home/wzm/hexo;    #error_page   404   /404.html;    location ~ .*\.(ico|gif|jpg|jpeg|png|bmp|swf)$    {        access_log   on;        expires      1d;    }    location ~ .*\.(js|css|txt|xml)?$    {        access_log   on;        expires      12h;    }    location / {        try_files $uri $uri/ =404;    }    access_log  /usr/local/nginx/logs/hexo.log  combined;}</code></pre><p><strong>4.重启</strong><br><code>systemctl reload nginx</code></p><p>在外面访问即可</p>]]></content>
    
    
    <categories>
      
      <category>Server</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Server</tag>
      
      <tag>Linux</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Room数据库使用指北List&lt;&gt;的问题</title>
    <link href="undefined2017/12/25/room-list-object/"/>
    <url>2017/12/25/room-list-object/</url>
    
    <content type="html"><![CDATA[<p>Room依赖</p><pre><code>implementation &quot;android.arch.persistence.room:runtime:1.0.0&quot;annotationProcessor &quot;android.arch.persistence.room:compiler:1.0.0&quot;</code></pre><a id="more"></a><p>查找**</p><ul><li>查找表中所有数据</li></ul><pre><code>  /**     * 查找user     * @return     */    @Query(&quot;SELECT * FROM banners&quot;)    List&lt;BannerModel&gt; findBanners();</code></pre><ul><li>按条件查找</li></ul><pre><code>    /**     * filters     * @return     * @param typeSort     */    @Query(&quot;SELECT * FROM filters WHERE type != :typeSort&quot;)    List&lt;FilterItemModel&gt; findFilters(String typeSort);</code></pre><ul><li>限制条数的条件查找</li></ul><pre><code>    /**     * 获取排序     * @return     */    @Query(&quot;SELECT * FROM filters WHERE type = :name LIMIT 0,1&quot;)    FilterItemModel findSort(String name);</code></pre><p>现在获取的是第一条数据</p><p>//文档中的例子</p><pre><code>@Daopublic interface MyDao {    @Query(&quot;SELECT first_name, last_name FROM user WHERE region IN (:regions)&quot;)    public List&lt;NameTuple&gt; loadUsersFromRegions(List&lt;String&gt; regions);}</code></pre><p>在user表中查找满足集合List<string> regions中条件的元素</string></p><ul><li>获取总行数</li></ul><pre><code>    /**     * 获取数据库表中总条数     * @return     */    @Query(&quot;SELECT count(*) FROM search_history&quot;)    long findHistoryCount();</code></pre><ul><li>获取某一列的和</li></ul><pre><code>    /**     * 求和     * @return     */    @Query(&quot;SELECT sum(count) FROM status_stock&quot;)    long findStatusStockCount();</code></pre><ul><li>按照降序排列(ASC升序  DESC降序)</li></ul><pre><code>    /**     * 查找user     * @return     */    @Query(&quot;SELECT * FROM search_history ORDER BY time DESC&quot;)    List&lt;SearchHistoryModel&gt; findSearchHistory();</code></pre><hr><p>文档中的例子:</p><pre><code>@Daopublic interface MyDao {    //正常的查询    @Query(&quot;SELECT * FROM user WHERE age != :minAge&quot;)    public User[] loadAllUsersOlderThan(int minAge);}@Daopublic interface MyDao {    //区间中的值    @Query(&quot;SELECT * FROM user WHERE age BETWEEN :minAge AND :maxAge&quot;)    public User[] loadAllUsersBetweenAges(int minAge, int maxAge);    //或关系的查询    @Query(&quot;SELECT * FROM user WHERE first_name LIKE :search &quot;           + &quot;OR last_name LIKE :search&quot;)    public List&lt;User&gt; findUserWithName(String search);}</code></pre><p><strong>如果,你不想查到表 行中所有字段,则</strong><br>1.定义一个实体</p><pre><code>public class NameTuple {    @ColumnInfo(name=&quot;first_name&quot;)    public String firstName;    @ColumnInfo(name=&quot;last_name&quot;)    public String lastName;}</code></pre><p>2.查询</p><pre><code>@Daopublic interface MyDao {    @Query(&quot;SELECT first_name, last_name FROM user&quot;)    public List&lt;NameTuple&gt; loadFullName();}</code></pre><ul><li>多表查询Querying multiple tables</li></ul><pre><code>@Daopublic interface MyDao {   @Query(&quot;SELECT user.name AS userName, pet.name AS petName &quot;          + &quot;FROM user, pet &quot;          + &quot;WHERE user.id = pet.user_id&quot;)   public LiveData&lt;List&lt;UserPet&gt;&gt; loadUserAndPetNames();   // You can also define this class in a separate file, as long as you add the   // &quot;public&quot; access modifier.   //注意 public   static class UserPet {       public String userName;       public String petName;   }}</code></pre><p><strong>更新</strong></p><ul><li>更新指定条目</li></ul><pre><code>    /**     * 更新时间     * @param time     */    @Query(&quot;UPDATE search_history SET time = :time WHERE content = :content&quot;)    void updateSearchHistory(String content,long time);</code></pre><p><strong>删除数据</strong></p><ul><li>删除所有数据</li></ul><pre><code>    /**     * 删除表     * @return     */    @Query(&quot;DELETE FROM filters&quot;)    void delectFilters();</code></pre><ul><li>删除最后一条</li></ul><pre><code>    /**     * 删除最后一个     * @return     */    @Query(&quot;DELETE FROM search_history WHERE time in(SELECT time FROM search_history ORDER BY time ASC LIMIT 1 )&quot;)    void delectLastHistory();</code></pre><ul><li>按条件删除</li></ul><pre><code>    /**     * 删除表by listtype     * @return     */    @Query(&quot;DELETE FROM vehicle_model WHERE listType = :type&quot;)    void delectVehicleByType(String type);</code></pre><p>####补充</p><p><strong><code>1.List&lt;String&gt;</code>这样的元素</strong></p><pre><code>   private ArrayList&lt;String&gt; tags;</code></pre><p>这样的元素,可以通过Converter搞定</p><pre><code>    /**    * If you have any questions, you can contact by email { wangzhumoo@gmail.com}    *    * @author 王诛魔 2017/12/27 上午11:51    */    public class TagsConverter {        @TypeConverter        public static ArrayList&lt;String&gt; fromString(String value) {            Type listType = new TypeToken&lt;ArrayList&lt;String&gt;&gt;() {}.getType();            return new Gson().fromJson(value, listType);        }        @TypeConverter        public static String fromArrayList(ArrayList&lt;String&gt; list) {            Gson gson = new Gson();            String json = gson.toJson(list);            return json;        }    }</code></pre><p>在db中,会存为 </p><pre><code>[&quot;精选&quot;][&quot;精选&quot;,&quot;急售&quot;][&quot;准新&quot;,&quot;SUV&quot;]</code></pre><p><strong>3.@Embedded</strong></p><p>作用是,把已经写好的普通的类添加到数据表中.<br>用Room的文档做说明:</p><pre><code>//这是一个标准的数据表@Entityclass User {    @PrimaryKey    public int id;    public String firstName;}</code></pre><p>其中只有id , firstName</p><p>而我想添加<br>    street;<br>    state;<br>    city;<br>    postCode;<br>刚好之前写了一个类叫Address</p><pre><code>class Address {    public String street;    public String state;    public String city;    @Ignore    public String nothing;    @ColumnInfo(name = &quot;post_code&quot;)    public int postCode;}</code></pre><p>那么我通过 @Embedded</p><pre><code>@Entityclass User {    @PrimaryKey    public int id;    public String firstName;    @Embedded    public Address address;}</code></pre><p>表中就会有:<br><code>names: id, firstName, street, state, city, and post_code</code></p><p>如果你想给@Embedded的类中所有元素前面加上统一的标志</p><p><code>@Embedded(prefix = &quot;address_&quot;)</code></p><p>表中就会有:</p><p><code>names: id, firstName, address_street, address_state, address_city, and address_post_code</code></p><p><strong>3.<code>List&lt;Object&gt;</code>这样的数据</strong></p><ul><li>解决方法<br><a href="https://developer.android.com/reference/android/arch/persistence/room/Relation.html" target="_blank" rel="noopener">google developer</a></li></ul><p>真的给谷歌跪了,什么鬼文档</p><pre><code>@Entitypublic class User {    // 这里是用户的 Id    @PrimaryKey    public int id;    //省略    ...}@Entitypublic class Book {    //书的id    @PrimaryKey    public int bookId;    //这里就是这本书与 User的关系,这里的是User.id    public int userId;    public String name;    public String desc;}//注意,什么注解也不要加public class UserAndBooks {    //加入所有的user的属性   @Embedded   public User user;    //这里定义User 和 Book的关系   @Relation(parentColumn = &quot;id&quot;, entityColumn = &quot;userId&quot;, entity = Book.class)   public List&lt;Book&gt; books; }//文档上还讲了一个比较牛逼的功能,这里不讨论public class UserAndAllPets {   @Embedded   public User user;   @Relation(parentColumn = &quot;id&quot;, entityColumn = &quot;userId&quot;, entity = Book.class,           projection = {&quot;name&quot;})   public List&lt;String&gt; bookNames; }//然后,dao是这样的@Daopublic interface UserDao {    @Query(&quot;SELECT * FROM User&quot;)    public List&lt;UserAndBooks&gt; loadUserWithBooks();}PS:当然你存的时候,分辨别存User  和 Book 即可</code></pre>]]></content>
    
    
    <categories>
      
      <category>Android</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Android</tag>
      
      <tag>Room</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Retrofit2 + Okhttp3 + Rxjava2 网络请求封装(下)</title>
    <link href="undefined2017/12/25/Retrofit2-Okhttp3-Rxjava2-2/"/>
    <url>2017/12/25/Retrofit2-Okhttp3-Rxjava2-2/</url>
    
    <content type="html"><![CDATA[<pre><code>//请求:RetrofitApis.getNetworkApis().getFriendsCircle(userBean.token, String.valueOf(45),null,lastId)    .compose(new DefaultTransformer&lt;&gt;())    .subscribe(new Defaultubscriber&lt;List&lt;FriendItem&gt;&gt;() {        @Override        protected void onError(ApiException ex) {                //请求错误,ex中可以拿到code 和 msg  便于展示给用户        }        @Override        public void onNext(List&lt;FriendItem&gt; friends) {            //请求成功,friends就是数据        }        @Override        public void onComplete() {                    //没有错误的话,最后会走着        }});</code></pre><p>compose()  转化<br>subscribe() 订阅</p><p>DefaultTransformer.java</p><pre><code>/** * If you have any questions, you can contact by email {wangzhumoo@gmail.com} * @author 王诛魔 2017/11/3 下午5:06 * * 默认的切换线程,并返回实体类 */public class DefaultTransformer&lt;T extends ResultResponse&lt;RP&gt;, RP&gt; implements FlowableTransformer&lt;T, RP&gt; {    @Override    public Publisher&lt;RP&gt; apply(Flowable&lt;T&gt; upstream) {        return upstream                .map(t -&gt; t.getResult())                .subscribeOn(Schedulers.io())                .observeOn(AndroidSchedulers.mainThread());    }}</code></pre><p>1.map 将返回的ResultResponse&lt;&gt;  转化,直接取ResultResponse的泛型实体</p><pre><code>{&quot;result&quot;:{}&quot;code&quot;:&quot;&quot;,&quot;msg&quot;:&quot;&quot;}</code></pre><p>中的result</p><p>2.subscribeOn(Schedulers.io())  网络请求的耗时操作,放在方便io操作的线程里面<br>3.observeOn(AndroidSchedulers.mainThread())  后面的操作,都在主线程进行</p><p>Defaultubscriber.java</p><pre><code>/** * If you have any questions, you can contact by email {wangzhumoo@gmail.com} * @author 王诛魔 2017/10/24 上午10:36 * * 用于没有网络时停止网络请求 */public abstract class Defaultubscriber&lt;T&gt; extends DisposableSubscriber&lt;T&gt; {    @CallSuper    @Override    public void onError(Throwable e) {        if (e instanceof ApiException) {            onError((ApiException) e);        } else {            onError(new ApiException(&quot;&quot;,&quot;&quot;));        }    }    @Override    protected void onStart() {        if (!SystemUtils.isNetworkConnected()) {            onError(new ApiException(Utils.getString(R.string.net_error_title),&quot;999&quot;));            cancel();            return;        }        super.onStart();    }    /**     * 错误回调     *     * @param ex 异常信息     */    protected abstract void onError(ApiException ex);}</code></pre><p>1.extends DisposableSubscriber  便于通过CompositeDisposable管理请求,此处没有展示,不用管<br>2.onStart()  中,判断是否有网络</p><ul><li><p>没有网络</p><p>onError(new ApiException(Utils.getString(R.string.net_error), false));<br>抛出没有网络的错误,由各个页面自行处理</p><p>cancel(); 取消</p><ul><li>有网络则继续</li></ul></li></ul><p>3.重写的 onError()中.<br>    是ApiException实例的,是自己抛出的异常,已经处理过了,直接onError给各个页面处理<br>    不是的再处理一次,在分发给各个页面处理</p><p>####未完待续…</p>]]></content>
    
    
    <categories>
      
      <category>Android</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Android</tag>
      
      <tag>Okhttp</tag>
      
      <tag>Rxjava</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Retrofit2 + Okhttp3 + Rxjava2 网络请求封装(上)</title>
    <link href="undefined2017/12/25/Retrofit2-Okhttp3-Rxjava2-1/"/>
    <url>2017/12/25/Retrofit2-Okhttp3-Rxjava2-1/</url>
    
    <content type="html"><![CDATA[<p>最终结构</p><pre><code>net├── RequestBuilder.java├── RetrofitApis.java├── base│   ├── ApiException.java│   ├── CustomGsonConverter.java│   ├── DefaultSubscriber.java│   └── DefaultTransformer.java└── response    ├── BaseResponse.java    └── ResultResponse.javaNetworkApis.java</code></pre><a id="more"></a><p><strong>1.添加依赖</strong></p><pre><code>implementation &quot;io.reactivex.rxjava2:rxjava:2.1.7&quot;implementation &quot;io.reactivex.rxjava2:rxandroid:2.0.1&quot;implementation &quot;com.squareup.okhttp3:okhttp:3.9.0&quot;implementation &quot;com.squareup.okhttp3:logging-interceptor:3.9.0&quot;implementation &quot;com.squareup.retrofit2:retrofit:2.3.0&quot;implementation &quot;com.squareup.retrofit2:converter-gson:2.3.0&quot;implementation &quot;com.squareup.retrofit2:adapter-rxjava2:2.3.0&quot;</code></pre><p><strong>2.请求服务构建</strong></p><pre><code>/** * If you have any questions, you can contact by email {wangzhumoo@gmail.com} * @author 王诛魔 2017/11/1 下午11:13 * */public class RetrofitApis {    private static OkHttpClient okHttpClient = null;    private static NetworkApis networkApis = null;    private static Gson gson = new Gson();    private static final String TAG = &quot;RetrofitApis&quot;;    /**     * 为HOST创建一个请求客户端     * @return     */    public static NetworkApis getNetworkApis() {        initOkhttp();        if (networkApis == null) {            Retrofit retrofit = new Retrofit.Builder()                    .client(okHttpClient)                    .baseUrl(Constants.HOST)                    .addConverterFactory(CustomGsonConverter.create(gson))                    .addCallAdapterFactory(RxJava2CallAdapterFactory.create())                    .build();            networkApis = retrofit.create(NetworkApis.class);        }        return networkApis;    }    /**     * 初始化一个OkHttpClient     */    private static void initOkhttp(){        //没有创建就实例一个        if(okHttpClient == null){            final OkHttpClient.Builder builder = new OkHttpClient.Builder();            //设置log等级            if(BuildConfig.DEBUG){                HttpLoggingInterceptor interceptor = new HttpLoggingInterceptor();                //BODY  包含请求url 参数  response ,会打印在logcat                interceptor.setLevel(HttpLoggingInterceptor.Level.BODY);                builder.addInterceptor(interceptor);            }            //打开一个File用于缓存            File cacheFile = new File(Constants.PATH_CACHE);            Cache cache = new Cache(cacheFile,1024*1024*50);            //一个拦截器                Interceptor cacheInterceptor = new Interceptor() {                @Override                public Response intercept(Chain chain) throws IOException {                    Request.Builder builder = chain.request().newBuilder();                    if(SystemUtils.isNetworkConnected()){                        int maxAge = 0 ;                        //有网络,不缓存,最长保存时间为0                        builder.removeHeader(&quot;Pragma&quot;)                                .header(&quot;Cache-Control&quot;, &quot;public, max-age=&quot; + maxAge)                                .build();                    } else {                        // 无网络时，设置超时为2周                        int maxStale = 60 * 60 * 24 * 14;                        builder.removeHeader(&quot;Pragma&quot;)                                .header(&quot;Cache-Control&quot;, &quot;public, only-if-cached, max-stale=&quot; + maxStale)                                .build();                      throw new ApiException(false);                    }                    return chain.proceed(builder.build());                }            };            //设置缓存拦截器            builder.addInterceptor(cacheInterceptor);            builder.addNetworkInterceptor(cacheInterceptor);            //这里通过Interceptor 可以实现添加公共参数,不详细说明了            //stetho,如果使用则需要添加            //builder.addNetworkInterceptor(new StethoInterceptor());            builder.cache(cache);            //错误重连            builder.retryOnConnectionFailure(true);            //设置超时            builder.connectTimeout(15, TimeUnit.SECONDS);            builder.readTimeout(15, TimeUnit.SECONDS);            builder.writeTimeout(15, TimeUnit.SECONDS);            okHttpClient = builder.build();        }    }}</code></pre><p>以上;</p><p>使用 <code>CustomGsonConverter.java / NetworkApis.java</code><br>通过getNetworkApis()方法,向外提供了一个请求服务.<br>其中 .addConverterFactory(CustomGsonConverter.create(gson))<br>是使用自定义的Converter替代了默认提供的</p><p>CustomGsonConverter.java</p><pre><code>/** * If you have any questions, you can contact by email {wangzhumoo@gmail.com} * @author 王诛魔 2017/10/24 上午10:31 * * GsonConverter 用于在不解析返回正文的前提下获取请求成功失败和 返回信息 */public class CustomGsonConverter extends Converter.Factory {    private final Gson gson;    private CustomGsonConverter(Gson gson) {        if (gson == null) {            throw new NullPointerException(&quot;gson == null&quot;);        }        this.gson = gson;    }    public static CustomGsonConverter create() {        return create(new Gson());    }    public static CustomGsonConverter create(Gson gson) {        return new CustomGsonConverter(gson);    }    @Override    public Converter&lt;ResponseBody, ?&gt; responseBodyConverter(Type type, Annotation[] annotations, Retrofit retrofit) {        TypeAdapter&lt;?&gt; adapter = gson.getAdapter(TypeToken.get(type));        return new CustomGsonResponseBodyConverter&lt;&gt;(gson, adapter);    }    private class CustomGsonResponseBodyConverter&lt;T&gt; implements Converter&lt;ResponseBody, T&gt; {        private final Gson gson;        private final TypeAdapter&lt;T&gt; adapter;        public CustomGsonResponseBodyConverter(Gson gson, TypeAdapter&lt;T&gt; adapter) {            this.gson = gson;            this.adapter = adapter;        }        @Override        public T convert(ResponseBody value) throws IOException {            String response = value.string();            BaseResponse baseResponse = gson.fromJson(response,BaseResponse.class);            if (!baseResponse.isCodeSuccess()) {                value.close();                throw new ApiException(baseResponse.error);            }            MediaType contentType = value.contentType();            Charset charset = contentType != null ? contentType.charset(UTF_8) : UTF_8;            InputStream inputStream = new ByteArrayInputStream(response.getBytes());            Reader reader = new InputStreamReader(inputStream, charset);            JsonReader jsonReader = gson.newJsonReader(reader);            try {                return adapter.read(jsonReader);            } finally {                value.close();            }        }    }    @Nullable    @Override    public Converter&lt;?, RequestBody&gt; requestBodyConverter(Type type, Annotation[] parameterAnnotations, Annotation[] methodAnnotations, Retrofit retrofit) {        return super.requestBodyConverter(type,parameterAnnotations,methodAnnotations,retrofit);    }}</code></pre><p>requestBodyConverter没有重写,后面发现了一个bug,上传文件+文字参数时,可能会造成 Length出错.<br>responseBodyConverter 重写,先把response解析,如果有问题则<br><code>throw new ApiException(baseResponse.error);</code><br>会主动走RxJava的 onError()</p><p>如果没有问题,则继续,好像有点多余……</p><p>ApiException.java  就是用于封装异常</p><pre><code>/** * If you have any questions, you can contact by email {wangzhumoo@gmail.com} * @author 王诛魔 2017/10/24 上午10:29 * * 此类作为网络请求异常的基 */public class ApiException extends IOException {    String code;    String msg;    public ApiException(String code){        this.code = code;    }    public ApiException(String msg, String code){        super(msg);        this.msg = msg;        this.code = code;    }    public boolean getCode() {        return code;    }    @Override    public String getMessage() {        return msg;    }}</code></pre><p><strong>3.Response返回数据的封装</strong></p><blockquote><p>这里根据后台返回数据结构</p></blockquote><p>我们的返回是</p><pre><code>{    &quot;result&quot;:{    },    &quot;msg&quot;:&quot;请求成功&quot;,    &quot;code&quot;:&quot;0000&quot;}</code></pre><p>BaseResponse.java</p><pre><code>/** * If you have any questions, you can contact by email {wangzhumoo@gmail.com} * @author 王诛魔 2017/10/19 下午5:41 * */public class BaseResponse{    public String code;    public String msg;    /**     * API是否请求失败     *     * @return 失败返回true, 成功返回false     */    public boolean isCodeSuccess() {        return &quot;0000&quot;.equals(code);    }}</code></pre><p>所有的返回数据类,都要继承它,便于CustomGsonConverter 中判断返回数据的正确性</p><p>ResultResponse.java</p><pre><code>/** * If you have any questions, you can contact by email {wangzhumoo@gmail.com} * @author 王诛魔 2017/10/19 下午5:37 */public class ResultResponse&lt;T&gt; extends BaseResponse {    private T result;    public T getResult() {        return result;    }}</code></pre><p>通过T泛型,指定返回result的结构,让gson解析成实体对象</p><p>T 可能是 实体对象  可能是 List&lt;实体对象&gt;  ….</p><p><strong>4.请求数据</strong></p><p>NetworkApis.java</p><pre><code>/** * If you have any questions, you can contact by email {wangzhumoo@gmail.com} * @author 王诛魔 2017/10/19 下午5:40 * * 所有网络请求 */public interface NetworkApis {    /**     * 获取朋友圈列表     * @param token     * @return     */    @POST(&quot;QCRL/qcrl?command=getFriendsCircle&quot;)    @FormUrlEncoded    Flowable&lt;ResultResponse&lt;List&lt;FriendItem&gt;&gt;&gt; getFriendsCircle(            @Field(&quot;token&quot;) String token,            @Field(&quot;number&quot;) String number,            @Field(&quot;userId&quot;) String userId,            @Field(&quot;lastDate&quot;) String lastId);    /**     * 删除     * @param token     * @param circleId     * @return     */    @POST(&quot;QCRL/qcrl?command=updateFriendsCircle&quot;)    @FormUrlEncoded    Flowable&lt;ResultResponse&lt;String&gt;&gt; updateFriendsCircle(            @Field(&quot;token&quot;) String token,            @Field(&quot;circleId&quot;) String circleId);    /**     * 赞     * @param token     * @param circleId     * @param userId     * @return     */    @POST(&quot;QCRL/qcrl?command=addFavor&quot;)    @FormUrlEncoded    Flowable&lt;ResultResponse&lt;Object&gt;&gt; addFavor(            @Field(&quot;token&quot;) String token,            @Field(&quot;circleId&quot;) String circleId,            @Field(&quot;toId&quot;) String userId);    ...}</code></pre><p>根据自己的接口编写即可<br>@POST() 指请求方式为 POST  </p><blockquote><p>注意,括号中的网址,开头不可以使用/QCRL/…<br>否则会直接拼到HOST后面,url可能会错误 </p></blockquote><p>@FormUrlEncoded  表示form表单提交,会Encoded编码参数</p><p>@Field 每一个参数</p>]]></content>
    
    
    <categories>
      
      <category>Android</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Android</tag>
      
      <tag>Okhttp</tag>
      
      <tag>Rxjava</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Android项目的build.gradle通用设置</title>
    <link href="undefined2017/12/25/Android-build-gradle-config/"/>
    <url>2017/12/25/Android-build-gradle-config/</url>
    
    <content type="html"><![CDATA[<pre><code>apply plugin: &#39;com.android.application&#39;android {    //开启dataBinding    dataBinding{        enabled = true    }    defaultConfig {        //开启multiDex        multiDexEnabled true        //使用jni        ndk {            //设置支持的SO库架构,这里的意思是只支持&#39;armeabi&#39;, &#39;armeabi-v7a&#39;, &#39;x86&#39;            //这三种架构            abiFilters &#39;armeabi&#39;, &#39;armeabi-v7a&#39;, &#39;x86&#39;        }    }    //设置一个编译的配置    signingConfigs {        //名为release的配置项        release {            //签名文件的位置,当前位置是根目录            storeFile file(&quot;/keyfile.jks&quot;)            //storePassword            storePassword &quot;xxxxxxxx&quot;            //keyAlias            keyAlias &quot;wangzhumo&quot;            //keyPassword            keyPassword &quot;xxxxxxxx&quot;            //是否使用v2Signing            v2SigningEnabled false        }    }    //编译的版本    buildTypes {        //debug时的配置        debug {            minifyEnabled false            //这里使用上面配置的签名,可以做到debug时,也使用的是正式签名,而不是debug的 keystore            signingConfig signingConfigs.release            //buildConfig 的一个参数,是否开启log            buildConfigField &quot;boolean&quot;, &quot;LOG_DEBUG&quot;, &quot;true&quot;            proguardFiles getDefaultProguardFile(&#39;proguard-android.txt&#39;), &#39;proguard-rules.pro&#39;        }        release {            // 显示Log            minifyEnabled false            signingConfig signingConfigs.release            buildConfigField &quot;boolean&quot;, &quot;LOG_DEBUG&quot;, &quot;false&quot;            proguardFiles getDefaultProguardFile(&#39;proguard-android.txt&#39;), &#39;proguard-rules.pro&#39;        }    }    //adb的配置项    adbOptions {        //超时时间        timeOutInMs = 5 * 1000        //adb install -r /path..apk        installOptions &#39;-r&#39;    }    flavorDimensions &#39;env&#39;    productFlavors {        //正式版本        envydemo{            dimension &#39;env&#39;            //此处是versionName            versionName &quot;V1.1&quot;            //manifestPlaceholders            //是manifest已经定义的参数,这里给该参数赋值            manifestPlaceholders = [UMENG_CHANNEL_VALUE: &quot;wangzhumoo&quot;]            //buildConfig 的参数,App当前的HOST地址            buildConfigField &quot;String&quot;,&quot;SERVER_HOST&quot;,&#39;&quot;http://app....com/&quot;&#39;        }        envtest {            dimension &#39;env&#39;            versionName &quot;Test&quot;            manifestPlaceholders = [UMENG_CHANNEL_VALUE: &quot;wangzhumoo&quot;]            buildConfigField &quot;String&quot;,&quot;SERVER_HOST&quot;,&#39;&quot;http://app.test....com/&quot;&#39;        }    }    //自定义apk名字    android.applicationVariants.all { variant -&gt;        variant.outputs.all {            //apk的名字            outputFileName = &quot;App_${variant.versionName}.apk&quot;        }    }    android {         //排除        configurations.all {            resolutionStrategy.force &#39;com.google.code.findbugs:jsr305:1.3.9&#39;        }    }    //使用java8     compileOptions {        sourceCompatibility JavaVersion.VERSION_1_8        targetCompatibility JavaVersion.VERSION_1_8    }}</code></pre><p>以上代码,删除了常见的部分.</p><ul><li>buildConfigField</li></ul><pre><code>/** * 常量类 */public class Constants {    //取到在productFlavors.envyhcs配置的参数    //buildConfigField &quot;String&quot;,&quot;SERVER_HOST&quot;,&#39;&quot;http://app....com/&quot;&#39;    public static final String BASE_URL = BuildConfig.SERVER_HOST;}</code></pre><ul><li>manifestPlaceholders</li></ul><pre><code>&lt;manifest&gt;    &lt;application&gt;        //取到在productFlavors.envyhcs配置的参数        //manifestPlaceholders = [UMENG_CHANNEL_VALUE: &quot;wangzhumo&quot;]        &lt;meta-data            android:name=&quot;UMENG_CHANNEL&quot;            android:value=&quot;${UMENG_CHANNEL_VALUE}&quot; /&gt;    &lt;/application&gt;&lt;/manifest&gt;</code></pre><ul><li>Build Variants<br>在build.gradle中配置了productFlavors{  envdemo{} , envtest{}}</li></ul><p>其中dimension一个维度<br>其中buildTypes一个维度</p><p>debug + evndemo<br>debug + evntest<br>release + evndeme<br>release + evntest</p><p>共4种,其他的并没有使用到,所以不做说明</p><p><img src="/images/build_var.png" srcset="/img/loading.gif" alt="Build Variants"></p><p>可以选择debug默认的版本…</p>]]></content>
    
    
    <categories>
      
      <category>Android</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Android</tag>
      
      <tag>Gradle</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Android 项目统一管理依赖版本</title>
    <link href="undefined2017/12/25/Android-dependent-config/"/>
    <url>2017/12/25/Android-dependent-config/</url>
    
    <content type="html"><![CDATA[<p>准备引入Arouter,做一个组件的demo,就开始慢慢的改造项目</p><pre><code>.|-- app|   |-- build.gradle|   |-- libs|   |-- src|   |   |-- androidTest|   |   |-- main|   |   `-- test||-- opensource|   |-- build.gradle|   |-- libs|   `-- src|       `-- main|-- build.gradle|-- settings.gradle`-- versions.gradle</code></pre><blockquote><p>app 为主项目<br>opensource 作为library存在,将来会成为baseLib的依赖,其中是所有的三方依赖,开源代码等等</p></blockquote><a id="more"></a><p><strong>1.根目录创建versions.gradle</strong></p><p><code>/versions.gradle</code></p><pre><code>ext.deps = [:]    def versions = [:]    versions.arch = &quot;1.0.0&quot;    versions.support = &quot;27.0.1&quot;    versions.dagger = &quot;2.13&quot;    versions.stetho = &quot;1.5.0&quot;    versions.dialogs = &quot;0.9.6.0&quot;    versions.glide = &quot;4.3.1&quot;    versions.gradle = &quot;3.0.1&quot;    versions.rxJava = &quot;2.1.7&quot;    versions.rxAndroid = &quot;2.0.1&quot;    versions.rxRelay = &quot;2.0.0&quot;    versions.rxBinding = &quot;2.0.0&quot;    versions.paging = &quot;1.0.0-alpha3&quot;    versions.okhttp = &quot;3.9.0&quot;    versions.retrofit = &quot;2.3.0&quot;    versions.kotlin = &quot;1.2.0&quot;    versions.kotlinBind = &quot;3.0.1&quot;    versions.gson = &quot;2.8.2&quot;    versions.arouterVersion = &quot;1.2.4&quot;    versions.arouterProcessor = &quot;1.1.4&quot;    versions.atslRunner = &quot;1.0.1&quot;    versions.atslRules = &quot;1.0.1&quot;    versions.hamcrest = &quot;1.3&quot;    versions.timber = &quot;4.5.1&quot;    versions.mockwebserver = &quot;3.8.1&quot;    versions.apache_commons = &quot;2.5&quot;    versions.mockito = &quot;2.7.19&quot;    versions.mockito_all = &quot;1.10.19&quot;    versions.dexmaker = &quot;2.2.0&quot;    versions.constraint = &quot;1.0.2&quot;    versions.junit = &quot;4.12&quot;    versions.espresso = &quot;3.0.1&quot;    def deps = [:]    def rxLib = [:]    rxLib.rxJava = &quot;io.reactivex.rxjava2:rxjava:$versions.rxJava&quot;    rxLib.rxAndroid = &quot;io.reactivex.rxjava2:rxandroid:$versions.rxAndroid&quot;    rxLib.rxBinding = &quot;com.jakewharton.rxbinding2:rxbinding:$versions.rxBinding&quot;    rxLib.rxBingingV4 = &quot;com.jakewharton.rxbinding2:rxbinding-support-v4:$versions.rxBinding&quot;    rxLib.rxBingingRecycler = &quot;com.jakewharton.rxbinding2:rxbinding-recyclerview-v7:$versions.rxBinding&quot;        rxLib.rxBingingV7 = &quot;com.jakewharton.rxbinding2:rxbinding-appcompat-v7:$versions.rxBinding&quot;    rxLib.rxBingingDesign = &quot;com.jakewharton.rxbinding2:rxbinding-design:$versions.rxBinding&quot;    rxLib.rxRelay = &quot;com.jakewharton.rxrelay2:rxrelay:$versions.rxRelay&quot;    deps.rxLibs = rxLib    def support = [:]    support.annotations = &quot;com.android.support:support-annotations:$versions.support&quot;    support.appCompat = &quot;com.android.support:appcompat-v7:$versions.support&quot;    support.recyclerview = &quot;com.android.support:recyclerview-v7:$versions.support&quot;    support.cardview = &quot;com.android.support:cardview-v7:$versions.support&quot;    support.design = &quot;com.android.support:design:$versions.support&quot;    support.v4 = &quot;com.android.support:support-v4:$versions.support&quot;    support.coreUtils = &quot;com.android.support:support-core-utils:$versions.support&quot;    deps.support = support    def archLib = [:]    archLib.archExtensions = &quot;android.arch.lifecycle:extensions:$versions.arch&quot;    archLib.archRoomRuntime = &quot;android.arch.persistence.room:runtime:$versions.arch&quot;    archLib.archRoomCompiler = &quot;android.arch.persistence.room:compiler:$versions.arch&quot;    archLib.archLifecycleCommon = &quot;android.arch.lifecycle:common-java8:$versions.arch&quot;    deps.archLibs = archLib    def glide = [:]    glide.glide = &quot;com.github.bumptech.glide:glide:$versions.glide&quot;    glide.glideCompiler = &quot;com.github.bumptech.glide:compiler:$versions.glide&quot;    deps.glide = glide    def stethos = [:]    stethos.stetho = &quot;com.facebook.stetho:stetho:$versions.stetho&quot;    stethos.stethoHttp = &quot;com.facebook.stetho:stetho-okhttp3:$versions.stetho&quot;    deps.stetho = stethos    def okhttp = [:]    okhttp.okhttp = &quot;com.squareup.okhttp3:okhttp:$versions.okhttp&quot;    okhttp.okhttpLogging = &quot;com.squareup.okhttp3:logging-interceptor:$versions.okhttp&quot;    deps.okhttp = okhttp    def retrofit = [:]    retrofit.retrofit = &quot;com.squareup.retrofit2:retrofit:$versions.retrofit&quot;    retrofit.converterGson = &quot;com.squareup.retrofit2:converter-gson:$versions.retrofit&quot;    retrofit.adapterRxjava = &quot;com.squareup.retrofit2:adapter-rxjava2:$versions.retrofit&quot;    deps.retrofit = retrofit    def arouter = [:]    arouter.runtime = &quot;com.alibaba:arouter-api:$versions.arouterVersion&quot;    arouter.compiler = &quot;com.alibaba:arouter-compiler:$versions.arouterProcessor&quot;    deps.arouter = arouter    def dagger = [:]    dagger.dagger = &quot;com.google.dagger:dagger:$versions.dagger&quot;    dagger.daggerAndroid = &quot;com.google.dagger:dagger-android:$versions.dagger&quot;    dagger.daggerAndroidSupport = &quot;com.google.dagger:dagger-android-support:$versions.dagger&quot;    dagger.daggerCompiler = &quot;com.google.dagger:dagger-compiler:$versions.dagger&quot;    dagger.daggerAndroidCompiler = &quot;com.google.dagger:dagger-android-processor:$versions.dagger&quot;    deps.dagger = dagger    def kotlin = [:]    kotlin.kotlinStdlib = &quot;org.jetbrains.kotlin:kotlin-stdlib-jre8:$versions.kotlin&quot;    kotlin.kotlinPlugin = &quot;org.jetbrains.kotlin:kotlin-gradle-plugin:$versions.kotlin&quot;    kotlin.kotlinDatabind = &quot;com.android.databinding:compiler:$versions.kotlinBind&quot;    deps.kotlin = kotlin    def espresso = [:]    espresso.core = &quot;com.android.support.test.espresso:espresso-core:$versions.espresso&quot;    espresso.contrib = &quot;com.android.support.test.espresso:espresso-contrib:$versions.espresso&quot;    espresso.intents = &quot;com.android.support.test.espresso:espresso-intents:$versions.espresso&quot;    deps.espresso = espresso    def atsl = [:]    atsl.runner = &quot;com.android.support.test:runner:$versions.atsl_runner&quot;    atsl.rules = &quot;com.android.support.test:rules:$versions.atsl_runner&quot;    deps.atsl = atsl    deps.multidex = &quot;com.android.support:multidex:1.0.1&quot;    deps.dialog =  &quot;com.afollestad.material-dialogs:core:$versions.dialogs&quot;    deps.gson = &quot;com.google.code.gson:gson:$versions.gson&quot;    deps.paging = &quot;android.arch.paging:runtime:$versions.paging&quot;    deps.dexmaker = &quot;com.linkedin.dexmaker:dexmaker-mockito:$versions.dexmaker&quot;    deps.constraint = &quot;com.android.support.constraint:constraint-layout:$versions.constraint&quot;    deps.timber = &quot;com.jakewharton.timber:timber:$versions.timber&quot;    deps.gradlePlugin = &quot;com.android.tools.build:gradle:$versions.gradle&quot;    deps.kotlinPlugin = &quot;org.jetbrains.kotlin:kotlin-gradle-plugin:$versions.kotlin&quot;    ext.deps = deps    def buildVersions = [:]    buildVersions.minSDK = 14    buildVersions.targetSDK = 26    buildVersions.compileSDK = 27    buildVersions.buildTools = &quot;26.0.2&quot;    ext.buildVersion = buildVersions    def addRepos(RepositoryHandler handler) {        handler.google()        handler.jcenter()        handler.mavenCentral()        handler.maven { url &#39;https://oss.jfrog.org/libs-snapshot&#39; }        handler.maven { url &#39;https://jitpack.io&#39; }    }    ext.addRepos = this.&amp;addRepos</code></pre><p>其中声明了所有已经用到,或者可能使用的Lib版本,以及Android sdk tools 的版本.</p><p><strong>2.将声明的版本,添加到项目中,方便引用</strong></p><p><code>/build.gradle</code></p><p>项目的build.gradle中</p><pre><code>buildscript {    //加入引用    apply from: &#39;versions.gradle&#39;    //添加rep    addRepos(repositories)    dependencies {        //由versions.gradle管理的版本        classpath deps.gradlePlugin        classpath deps.kotlinPlugin        // NOTE: Do not place your application dependencies here; they belong        // in the individual module build.gradle files    }}allprojects {    //添加rep    addRepos(repositories)}</code></pre><p><strong>3.对Android Tools,SDK版本的控制</strong><br>项目/app/build.gradle</p><pre><code>android {    //sdk的版本    compileSdkVersion buildVersion.compileSDK    //tools的版本    buildToolsVersion buildVersion.buildTools    defaultConfig {        //sdk版本        minSdkVersion buildVersion.minSDK        targetSdkVersion buildVersion.targetSDK        versionCode 1  //也可以使用        versionName &quot;1.0&quot;    }//}</code></pre><p><strong>4.其他Lib的依赖</strong><br>按照这样的格式即可</p><pre><code>dependencies {    //support    api deps.support.appCompat    api deps.support.recyclerview    api deps.support.cardview    api deps.support.design    api deps.multidex    api deps.constraint    //rxjava    api deps.rxLibs.rxJava    api deps.rxLibs.rxAndroid    api deps.rxLibs.rxRelay    //http    api deps.okhttp.okhttp    api deps.okhttp.okhttpLogging    api deps.retrofit.retrofit    api deps.retrofit.converterGson    api deps.retrofit.adapterRxjava    api deps.gson    //arch    api deps.archLibs.archExtensions    api deps.archLibs.archRoomRuntime    api deps.archLibs.archLifecycleCommon    annotationProcessor deps.archLibs.archRoomCompiler    //stetho    api deps.stetho.stetho    api deps.stetho.stethoHttp    //dialog    api deps.dialog    //glide    api deps.glide.glide    annotationProcessor deps.glide.glideCompiler}</code></pre>]]></content>
    
    
    <categories>
      
      <category>Android</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Android</tag>
      
      <tag>Gradle</tag>
      
      <tag>组件化</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>常用的Google Chrome 浏览器插件</title>
    <link href="undefined2017/12/25/Google-Chrome-Plug-In/"/>
    <url>2017/12/25/Google-Chrome-Plug-In/</url>
    
    <content type="html"><![CDATA[<p>###几个比较常用的Chrome插件</p><p><strong>1.<a href="https://chrome.google.com/webstore/detail/adblock/gighmmpiobklfepjocnamgkkbiglidom" target="_blank" rel="noopener">AdBlock</a></strong></p><p>最受欢迎的Chrome扩展，拥有超过4000万用户！屏蔽整个互联网上的广告。</p><p><img src="../images/adblock.png" srcset="/img/loading.gif" alt="adblock"></p><p>推荐: ★★★</p><a id="more"></a><p><strong>2.<a href="https://chrome.google.com/webstore/detail/insightio-for-github/pmhfgjjhhomfplgmbalncpcohgeijonh" target="_blank" rel="noopener">Insight.io for Github</a></strong></p><p>Improve GitHub code browsing experienc.<br>通过插件可以在github的项目页面上,结构化的查看代码,甚至还有”引用”,”查找”等等功能.<br>就像是把github项目页,变成了一个只能查看的ide.<br>对了,还能很方便的下载单个文件</p><p><img src="/images/chrome_insight.io.png" srcset="/img/loading.gif" alt="Insight.io for Github"></p><p>推荐: ★★★★★</p><p><strong>3.<a href="https://chrome.google.com/webstore/detail/infinity-new-tab/dbfmnekepjoapopniengjbcpnbljalfg" target="_blank" rel="noopener">Infinity新标签页</a></strong></p><p>重新定义了新标签页，一个追求极简美学和一站式服务体验更少的东西体验更多的功能。</p><p>简洁,方便,实用</p><p><img src="/images/chrome_infinity.png" srcset="/img/loading.gif" alt="Infinity新标签页"></p><p>推荐:★★★★</p><p><strong>4.<a href="https://chrome.google.com/webstore/detail/postman/fhbjgbiflinjbdggehcddcbncdddomop" target="_blank" rel="noopener">Postman</a></strong><br>Postman makes API development faster, easier, and better.</p><p>更快…..哈哈<br>超级方便,模拟请求的App,支持post get,可以测试文件上传等<br>还有比较方便的一点是,可以生成当前请求的okhttp代码,虽然只能作参考…..</p><p>推荐:★★★★★</p><blockquote><p>和它一样的还有<a href="https://chrome.google.com/webstore/detail/restlet-client-rest-api-t/aejoelaoggembcahagimdiliamlcdmfm" target="_blank" rel="noopener">Restlet Client - REST API Testing</a></p></blockquote><p><strong>5.<a href="https://github.com/acgotaku/BaiduExporter" target="_blank" rel="noopener">BaiduExporter</a></strong><br>可以方便的把网盘的下载地址导出到aria2/aria2-rpc，支持YAAW。<br>配合Aria2GUI,可以高速下载百度云限速的文件..</p><p>虽然还能用,但是作者说不维护了,还有替代品:<a href="https://chrome.google.com/webstore/detail/aria2c-integration/edcakfpjaobkpdfpicldlccdffkhpbfk?hl=en-US" target="_blank" rel="noopener">Aria2c Integration</a>没有用过,不知道是否可用.</p><p><a href="https://aria2.github.io/" target="_blank" rel="noopener">Aria2GUI</a><br>Github : <a href="https://github.com/aria2/aria2" target="_blank" rel="noopener">https://github.com/aria2/aria2</a></p><p>推荐:★★★★★</p><p><strong>其他</strong><br>推荐:★★★</p><p><a href="https://chrome.google.com/webstore/detail/singlefile/mpiodijhokgodhhofbcjdecpffjipkle" target="_blank" rel="noopener">SingleFile</a><br>Archive a complete page into a single HTML file<br>可以将网页保存为单文件,方便保存</p><p><a href="https://chrome.google.com/webstore/detail/evernote-web-clipper/pioclpoplcdbaefihamjohnefbikjilc" target="_blank" rel="noopener">印象笔记·剪藏</a><br>使用印象笔记扩展程序一键保存精彩网页内容到印象笔记帐户。</p><p><a href="https://github.com/callumlocke/json-formatter" target="_blank" rel="noopener">JSON Formatter</a><br>Chrome extension for printing JSON and JSONP nicely when you visit it ‘directly’ in a browser tab.<br>Github : <a href="https://github.com/callumlocke/json-formatter" target="_blank" rel="noopener">https://github.com/callumlocke/json-formatter</a></p>]]></content>
    
    
    <categories>
      
      <category>Tools</category>
      
    </categories>
    
    
    <tags>
      
      <tag>tools</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>jni使用指南,关于.so你应该知道的</title>
    <link href="undefined2017/12/25/jni-with-so/"/>
    <url>2017/12/25/jni-with-so/</url>
    
    <content type="html"><![CDATA[<p><strong>其实这些都是Android设备CPU的:</strong></p><ul><li><p>armeabi: 早期的手机用的比较多,针对普通的或旧的arm v5 cpu,。</p></li><li><p>armeabiv-v7a:目前主流版本 2011年以后的生产的大部分设备,针对有浮点运算或高级扩展功能的arm v7 cpu.</p></li><li>arm64-v8a:  8代、64位ARM处理器，64位支持.</li><li>x86: 我们见到的模拟器大多就是这个。</li><li>x86_64: 64位的平板。</li></ul><p>然后特意说一下x86系列的,是兼容arm的,但是性能损失特别大.</p><a id="more"></a><p><strong>Android加载.so的原则</strong><br>同一目录下要么所有使用jni的项目都给加上.so文件,<br>要么你就别给这个目录,也就是只要不齐全就都干掉<br>比如你的lib结构是这样的</p><pre><code>libs  -armeabi      -aaa.so      -bbb.so  -arm64-v8a      -aaa.so</code></pre><p>其实这种情况就是属于同一目录下,提供的.so文件不全…然而很容易出现,毕竟有些三方啊什么的,提供的.so文件并不齐全,这样的话同一个架构目录下会缺少一个或多个.so文件.</p><p>Android在加载某个使用jni的功能时,你并没有提供x86的.so文件,但是你有x86这个目录,那就会去x86目录下去找,<strong>没有啊</strong>然后就异常了.</p><p><strong>Android加载.so的目录</strong><br>1.我自己用的是</p><p><img src="http://upload-images.jianshu.io/upload_images/2520304-4f36025e8667df85.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" srcset="/img/loading.gif" alt="Snip20170309_1.png"></p><p>也就是自己在app -&gt; src -&gt; main 下自己建立一个目录: jniLibs<br>然后放进去即可.</p><p>2.就是通常放在libs目录下了<br>别忘了在build.gradle文件中设置   jniLibs.srcDir </p><p><strong>Android排除某架构的.so</strong></p><pre><code>android {    ...    defaultConfig {            ...        ndk {            // 设置支持的 SO 库构架            abiFilters &#39;armeabi&#39;, &#39;armeabi-v7a&#39;     // &#39;arm64-v8a&#39;, &#39;x86&#39;, &#39;x86_64&#39;, &#39;mips&#39;, &#39;mips64&#39;        }    }   }</code></pre><p>如果编译报</p><pre><code>NDK integration is deprecated in the current plugin.</code></pre><p> gradle.properties 文件中添加：</p><pre><code>android.useDeprecatedNdk=true</code></pre><p>应该还有其他方法排除,我也就知道这一种,如果有知道其他方法的,请告知一下,谢谢</p>]]></content>
    
    
    
    <tags>
      
      <tag>JNI，Android</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>EditText的输入属性InputType以及imeOptions</title>
    <link href="undefined2017/12/25/EditText-InputType-imeOptions/"/>
    <url>2017/12/25/EditText-InputType-imeOptions/</url>
    
    <content type="html"><![CDATA[<p><strong>EditText的输入属性</strong></p><pre><code>android:imeOptions=&quot;flagNoExtractUi&quot;  //使软键盘不全屏显示，只占用部分屏幕android:imeOptions=&quot;actionNone&quot;  //输入框右侧不带任何提示android:imeOptions=&quot;actionGo&quot;    //右下角按键内容为&#39;开始&#39;android:imeOptions=&quot;actionSearch&quot;  //右下角按键为搜索android:imeOptions=&quot;actionSend&quot;    //右下角按键内容为&#39;发送&#39;android:imeOptions=&quot;actionNext&quot;   //右下角按键内容为&#39;下一步&#39;android:imeOptions=&quot;actionDone&quot;  //右下角按键内容为&#39;完成&#39;</code></pre><a id="more"></a><p><strong>EditText的inputType属性</strong></p><pre><code>&lt;EditText    android:inputType=&quot;phone&quot; //电话号码    android:inputType=&quot;none&quot;     android:inputType=&quot;text&quot;  //文本类型    android:inputType=&quot;textCapCharacters&quot; //字母大写     android:inputType=&quot;textCapWords&quot; //首字母大写     android:inputType=&quot;textCapSentences&quot; //仅第一个字母大写     android:inputType=&quot;textAutoCorrect&quot; //自动完成     android:inputType=&quot;textAutoComplete&quot; //自动完成     android:inputType=&quot;textMultiLine&quot; //多行输入     android:inputType=&quot;textImeMultiLine&quot; //输入法多行    android:inputType=&quot;textNoSuggestions&quot; //不提示     android:inputType=&quot;textUri&quot; //网址     android:inputType=&quot;textEmailAddress&quot; //电子邮件地址     android:inputType=&quot;textEmailSubject&quot; //邮件主题     android:inputType=&quot;textShortMessage&quot; //短讯     android:inputType=&quot;textLongMessage&quot; //长信息     android:inputType=&quot;textPersonName&quot; //人名     android:inputType=&quot;textPostalAddress&quot; //地址    android:inputType=&quot;textPassword&quot; //密码     android:inputType=&quot;textVisiblePassword&quot; //可见密码    android:inputType=&quot;textWebEditText&quot; //作为网页表单的文本     android:inputType=&quot;textFilter&quot; //文本筛选过滤     android:inputType=&quot;textPhonetic&quot; //拼音输入     android:inputType=&quot;number&quot; //数字     android:inputType=&quot;numberSigned&quot; //带符号数字格式     android:inputType=&quot;numberDecimal&quot; //带小数点的浮点格式     android:inputType=&quot;datetime&quot; //时间日期     android:inputType=&quot;date&quot; //日期键盘     android:inputType=&quot;time&quot; //时间键盘    /&gt;</code></pre>]]></content>
    
    
    <categories>
      
      <category>Android</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Android</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>TextView中的文字颜色,点击,斜体等实现--SpannableString</title>
    <link href="undefined2017/12/25/textview-span/"/>
    <url>2017/12/25/textview-span/</url>
    
    <content type="html"><![CDATA[<p><strong>一般实现方式如下</strong>:</p><pre><code>String html = &quot;文字&lt;font color=\&quot;red\&quot;&gt;变色&lt;/font&gt;的效果&quot;;tvMainShow.setText(Html.fromHtml(html));</code></pre><p>使用Html的方式来实现,简单的还好,复杂一点的真的很不方便</p><p>Google显然早就已经想到了这样的问题,所以  </p><blockquote><p><a href="https://developer.android.com/reference/android/text/SpannedString.html" target="_blank" rel="noopener">SpannedString</a> &amp; <a href="https://developer.android.com/reference/android/text/SpannableStringBuilder.html" target="_blank" rel="noopener">SpannableStringBuilder</a> 就是干这个的</p></blockquote><p>他们都实现了 <a href="https://developer.android.com/reference/java/lang/CharSequence.html" target="_blank" rel="noopener">CharSequence</a>,眼熟么?  <code>setText(CharSequence text)</code>.也就是说,你可以直接赋值给TextView</p><a id="more"></a><p>他们两个的区别就是<br>This is the class for text whose content is immutable but to which markup objects can be attached and detached. For mutable text, see SpannableStringBuilder<br>文档说的很清楚了,就是CharSequence是固定长度的,一旦通过 new SpannableString(“设置文字”);则不可以更改文字内容,而SpannableStringBuilder是可以的,个人理解比较像String 和 StringBuilder 的关系</p><p>###不多说了,开搞:<br><strong>1.设置文字</strong></p><p><code>SpannableString spannableString = new SpannableString(&quot;文字的前景色与背景色&quot;);</code></p><p><strong>2.通过setSpan来修改文字的样式</strong><br><code>setSpan [Object what, int start, int end, int flags)</code></p><p><img src="http://upload-images.jianshu.io/upload_images/2520304-e821febbebd4f8dc.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" srcset="/img/loading.gif" alt="入参.png"></p><p>flags:<br>Spannable.SPAN_EXCLUSIVE_EXCLUSIVE：前后都不包括<br>Spannable.SPAN_EXCLUSIVE_INCLUSIVE    ：前面不包括<br>Spannable.SPAN_INCLUSIVE_EXCLUSIVE    ：前面包括<br>Spannable.SPAN_INCLUSIVE_INCLUSIVE    ：前后都包括</p><p>为了说明这四个参数,有例子如下:</p><p><img src="http://upload-images.jianshu.io/upload_images/2520304-3784e1b0d6a15d73.gif?imageMogr2/auto-orient/strip" srcset="/img/loading.gif" alt="flags.gif"><br>代码如下:</p><pre><code>/* * * @author 王诛魔 2017/1/21 上午11:31 * @e-mail  phyooos@163.com */public class MainActivity extends AppCompatActivity {    @BindView(R.id.edit_show)    EditText etMainShow;    @BindView(R.id.tab_view)    TabLayout tabLayout;    @Override    public void onCreate(@Nullable Bundle savedInstanceState) {        super.onCreate(savedInstanceState);        setContentView(R.layout.activity_main);        ButterKnife.bind(this);        showText(Spannable.SPAN_EXCLUSIVE_EXCLUSIVE);        tabLayout.setOnTabSelectedListener(new TabLayout.OnTabSelectedListener() {            @Override            public void onTabSelected(TabLayout.Tab tab) {                switch (tab.getPosition()) {                    case 0:                        showText(Spannable.SPAN_EXCLUSIVE_EXCLUSIVE);                        break;                    case 1:                        showText(Spannable.SPAN_EXCLUSIVE_INCLUSIVE);                        break;                    case 2:                        showText(Spannable.SPAN_INCLUSIVE_EXCLUSIVE);                        break;                    case 3:                        showText(Spannable.SPAN_INCLUSIVE_INCLUSIVE);                        break;                }            }            @Override            public void onTabUnselected(TabLayout.Tab tab) {            }            @Override            public void onTabReselected(TabLayout.Tab tab) {            }        });    }    /**     * 展示文字     */    private void showText(int type) {        //构造SpannableString        SpannableString spanString = new SpannableString(&quot;这里是王诛魔的简书文章&quot;);        //字体颜色的Span        ForegroundColorSpan span = new ForegroundColorSpan(Color.RED);        //指定范围        spanString.setSpan(span, 3, 6, type);        //设置给EditText显示出来        etMainShow.setText(spanString);    }}</code></pre><p>上面的代码中:</p><pre><code>//字体颜色的SpanForegroundColorSpan span = new ForegroundColorSpan(Color.RED);ForegroundColorSpan就是设置的文字样式,,这个是前景色,,也就是字体的颜色//指定范围spanString.setSpan(span, 3, 6, type);这里的三个参数已经在上面说过了,通过上面的代码也会发现,其实3,6  其中下标3是包含的,而下标6就不会改变</code></pre><hr><p><strong>3.至于Span的这些个样式在哪里找,请看文档:</strong><br><strong>关键词:<a href="https://developer.android.com/reference/android/text/style/CharacterStyle.html" target="_blank" rel="noopener">CharacterStyle</a></strong></p><blockquote><p><a href="https://developer.android.com/reference/android/text/style/CharacterStyle.html" target="_blank" rel="noopener">https://developer.android.com/reference/android/text/style/CharacterStyle.html</a></p></blockquote><p><img src="http://upload-images.jianshu.io/upload_images/2520304-50978874ad4c3a7f.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" srcset="/img/loading.gif" alt="Span的一些类型.png"></p><p>说几个常用的吧:</p><ul><li>ForegroundColorSpan  字体颜色</li><li>BackgroundColorSpan 字体背景色设置</li><li>AbsoluteSizeSpan 字体大小</li><li><p>StyleSpan 粗体等</p><pre><code>//字体由Typeface来控制StyleSpan span = new StyleSpan(Typeface.BOLD_ITALIC);</code></pre></li><li><p>UnderlineSpan 下划线</p></li><li>ImageSpan 图片置换</li></ul><p><a href="https://developer.android.com/reference/android/text/style/ImageSpan.html" target="_blank" rel="noopener">ImageSpan https://developer.android.com/reference/android/text/style/ImageSpan.html</a></p><p>这个有一点不同,它是将文字中的指定部分替换为一个图片,至于如何构造请参考文档<br>让我想起来了那个EmojiEditText的库,其实可以用这个ImageSpan实现一个简单的可以显示表情的TextView</p><ul><li>ClickableSpan 点击</li></ul><pre><code>//这个有些不同,需要class CustomClickable extends ClickableSpan {    @Override    public void updateDrawState(TextPaint ds) {        //这里其实还可以对可点击部分设置一些东西    }    @Override    public void onClick(View widget) {          ...do something    }}//对了,加上这行代码TextView.setMovementMethod(LinkMovementMethod.getInstance());//要不点不动哦</code></pre><p><img src="http://upload-images.jianshu.io/upload_images/2520304-7ccd2161c4d5f5e7.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" srcset="/img/loading.gif" alt="2017-04-05_23-36-38.png"></p><ul><li>URLSpan 这个完全可以用ClickableSpan实现</li></ul><p><strong>SpannableStringBuilder</strong></p><p>SpannableString都说的这么明白了,SpannableStringBuilder就省了</p><p>####End</p>]]></content>
    
    
    <categories>
      
      <category>Android</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Android</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Flutter 安装</title>
    <link href="undefined2017/12/25/Flutter-install-net-error/"/>
    <url>2017/12/25/Flutter-install-net-error/</url>
    
    <content type="html"><![CDATA[<blockquote><p>使用系统Mac OS</p></blockquote><p>已经没办法给大家看问题了,我在github上提了问题.</p><p><a href="https://github.com/flutter/flutter/issues/11674" target="_blank" rel="noopener">github issue</a></p><pre><code>使用命令 command`flutter doctor`异常:exceptionSocketException: SocketException: Connection failed (OS Error: No route to host, errno = 65), address = android.googlesource.com, port = 443</code></pre><p>总的来说就是下载 Downloading Gradle Wrapper…的时候连接不到外网,以至于失败</p><a id="more"></a><p>github上的这位小哥提醒了我<a href="https://github.com/lishuhao" target="_blank" rel="noopener">@lishuhao</a></p><blockquote><p><a href="https://github.com/eseidelgoogle" target="_blank" rel="noopener">@eseidelGoogle</a>it’s reachable via https from Chrome<br>Maybe his chrome use proxy but terminal not use proxy.</p></blockquote><p>我确实开了ss,但是终端确实连接不到代理的,不走代理,那当然无解</p><p>##解决:</p><p>####1.Mac下使用Homebrew安装</p><pre><code>brew install polipo</code></pre><p>####2.修改配置</p><pre><code>ln -sfv /usr/local/opt/polipo/*.plist ~/Library/LaunchAgents</code></pre><p><img src="http://upload-images.jianshu.io/upload_images/2520304-bfa92bf302955c0d.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" srcset="/img/loading.gif" alt="image.png"></p><pre><code>vim /usr/local/opt/polipo/homebrew.mxcl.polipo.plist</code></pre><p><img src="http://upload-images.jianshu.io/upload_images/2520304-b14154bf99746494.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" srcset="/img/loading.gif" alt="image.png"></p><p>在配置文件中添加<br><code>&lt;string&gt;socksParentProxy=localhost:1086&lt;/string&gt;</code></p><p>其中1086这个端口号,自己去看</p><p><img src="http://upload-images.jianshu.io/upload_images/2520304-40564c01c67e3f13.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" srcset="/img/loading.gif" alt="image.png"></p><p>####3.启动</p><pre><code>launchctl load ~/Library/LaunchAgents/homebrew.mxcl.polipo.plist</code></pre><p>####4.使用</p><pre><code>$ http_proxy=http://localhost:8123 curl ip.gsCurrent IP / 当前 IP: 47.90.88.133ISP / 运营商:  ALIYUNCity / 城市:  Hong KongCountry / 国家: ChinaIP.GS is now IP.SB, please visit https://ip.sb/ for more IP information, ip.gs will only use for curl purpose. / IP.GS 已更新至 IP.SB 请访问 https://ip.sb/ 获取更多信息, ip.gs 域名仅作 curl 使用Please join Telegram group https://t.me/sbfans if you have any issues. / 如有问题，请加入 Telegram 群 https://t.me/sbfans</code></pre><p>可以看到,现在我是香港的IP了,http_proxy=<a href="http://localhost:8123这个是提供默认的,至于怎么修改我没有看,也不知道" target="_blank" rel="noopener">http://localhost:8123这个是提供默认的,至于怎么修改我没有看,也不知道</a></p><p><strong>把代理设置为全局的</strong></p><pre><code>~ ⌚ 11:42:51$ export http_proxy=http://localhost:8123~ ⌚ 11:43:02$ export https_proxy=http://localhost:8123~ ⌚ 11:43:09$ curl https://www.google.com&lt;HTML&gt;&lt;HEAD&gt;&lt;meta http-equiv=&quot;content-type&quot; content=&quot;text/html;charset=utf-8&quot;&gt;&lt;TITLE&gt;302 Moved&lt;/TITLE&gt;&lt;/HEAD&gt;&lt;BODY&gt;&lt;H1&gt;302 Moved&lt;/H1&gt;The document has moved&lt;A HREF=&quot;https://www.google.com.hk/?gfe_rd=cr&amp;ei=5FaaWZDNOMLU8Af_nriwDw&quot;&gt;here&lt;/A&gt;.&lt;/BODY&gt;&lt;/HTML&gt;~ ⌚ 11:43:33$ curl www.google.com&lt;HTML&gt;&lt;HEAD&gt;&lt;meta http-equiv=&quot;content-type&quot; content=&quot;text/html;charset=utf-8&quot;&gt;&lt;TITLE&gt;302 Moved&lt;/TITLE&gt;&lt;/HEAD&gt;&lt;BODY&gt;&lt;H1&gt;302 Moved&lt;/H1&gt;The document has moved&lt;A HREF=&quot;http://www.google.com.hk/?gfe_rd=cr&amp;ei=6laaWZqEO8_U8AeLlID4CA&quot;&gt;here&lt;/A&gt;.&lt;/BODY&gt;&lt;/HTML&gt;</code></pre><p>####5.End</p><p>##见证奇迹的时刻到了</p><pre><code>~/develop/flutter on  alpha! ⌚ 11:44:11$ flutter doctorDownloading Gradle Wrapper...                         1.3s[✓] Flutter (on Mac OS X 10.12.6 16G29, locale zh-Hans-CN, channel alpha)    • Flutter at /Users/phyooos/develop/flutter    • Framework revision b156a0f054 (9 days ago), 2017-08-11 22:01:40 -0700    • Engine revision fef7d827d6    • Tools Dart version 1.25.0-dev.9.0[✓] Android toolchain - develop for Android devices (Android SDK 26.0.1)    • Android SDK at /Users/phyooos/Library/Android/sdk    • Platform android-26, build-tools 26.0.1    • ANDROID_HOME = /Users/phyooos/Library/Android/sdk    • Java binary at: /Applications/Android Studio.app/Contents/jre/jdk/Contents/Home/bin/java    • Java version OpenJDK Runtime Environment (build 1.8.0_112-release-b06)[-] iOS toolchain - develop for iOS devices    ✗ Xcode installation is incomplete; a full installation is necessary for iOS development.      Download at: https://developer.apple.com/xcode/download/      Or install Xcode via the App Store.      Once installed, run:        sudo xcode-select --switch /Applications/Xcode.app/Contents/Developer    ✗ libimobiledevice and ideviceinstaller are not installed or require updating. To update, run:        brew uninstall --ignore-dependencies libimobiledevice        brew install --HEAD libimobiledevice        brew install ideviceinstaller    ✗ ios-deploy not installed. To install:        brew install ios-deploy    ✗ CocoaPods not installed.        CocoaPods is used to retrieve the iOS platform side&#39;s plugin code that responds to your plugin usage on the Dart side.        Without resolving iOS dependencies with CocoaPods, plugins will not work on iOS.        For more info, see https://flutter.io/platform-plugins      To install:        brew install cocoapods        pod setup[✓] Android Studio (version 2.3)    • Android Studio at /Applications/Android Studio.app/Contents    • Java version OpenJDK Runtime Environment (build 1.8.0_112-release-b06)[✓] IntelliJ IDEA Ultimate Edition (version 2017.1.3)    • Flutter plugin version 16.0    • Dart plugin version 171.4424.63[✓] Connected devices    • None</code></pre><p>我的Flutter就ok了</p>]]></content>
    
    
    <categories>
      
      <category>Flutter</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Flutter</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>BottomNavigationView使用指南</title>
    <link href="undefined2017/12/25/BottomNavigationView/"/>
    <url>2017/12/25/BottomNavigationView/</url>
    
    <content type="html"><![CDATA[<p><strong>最终效果:</strong></p><p><img src="http://upload-images.jianshu.io/upload_images/2520304-f952921225e06fb8.gif?imageMogr2/auto-orient/strip" srcset="/img/loading.gif" alt="最后效果.gif"></p><p>Android Support Library 25 以上的support包中增加了 BottomNavigationView<br>所以你必须使用<code>com.android.support:design:25.0.0</code>以上的版本才能玩</p><a id="more"></a><p>1.在 build.gradle 文件中增加依赖：</p><blockquote><p><code>compile &#39;com.android.support:design:25.0.0&#39;</code></p></blockquote><p>2.在main_activity.xml中添加:</p><pre><code>&lt;android.support.design.widget.BottomNavigationView        android:id=&quot;@+id/bottom_nav&quot;        android:layout_width=&quot;match_parent&quot;        android:layout_height=&quot;@dimen/title_height&quot;        android:layout_alignParentBottom=&quot;true&quot;        app:menu=&quot;@menu/menu_tab_button&quot;        app:itemIconTint=&quot;@color/nav_color_select&quot;        app:itemTextColor=&quot;@color/nav_color_select&quot;        app:itemBackground=&quot;@color/text_white_color&quot;&gt;    &lt;/android.support.design.widget.BottomNavigationView&gt;</code></pre><ul><li>其中<code>app:menu=&quot;@menu/menu_tab_button&quot;</code>决定了展示几个item,都长什么样</li><li>其中,分别决定<strong>图标和文字</strong>选中和未选中item的状态,颜色</li></ul><pre><code>app:itemIconTint=&quot;@color/nav_color_select&quot;app:itemTextColor=&quot;@color/nav_color_select&quot;</code></pre><ul><li>其中<code>app:itemBackground=&quot;@color/text_white_color&quot;</code>则是整个view的背景颜色</li></ul><p>3.menu_tab_button.xml的代码如下:</p><pre><code>&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;&lt;menu xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;    xmlns:app=&quot;http://schemas.android.com/apk/res-auto&quot;&gt;    &lt;item        android:id=&quot;@+id/mian_tab_statistics&quot;        android:enabled=&quot;true&quot;        android:checked=&quot;true&quot;     //默认选中        android:title=&quot;@string/nav_tongji&quot;        android:icon=&quot;@drawable/tongji&quot;/&gt;    &lt;item android:id=&quot;@+id/mian_tab_paidui&quot;        android:enabled=&quot;true&quot;        android:title=&quot;@string/nav_paidui&quot;   //文字内容        android:icon=&quot;@drawable/paidui&quot;/&gt;   //icon图标    &lt;item android:id=&quot;@+id/mian_tab_find&quot;        android:enabled=&quot;true&quot;        android:title=&quot;@string/nav_faxiang&quot;        android:icon=&quot;@drawable/faxian&quot;/&gt;    &lt;item android:id=&quot;@+id/mian_tab_more&quot;        android:enabled=&quot;true&quot;        android:title=&quot;@string/nav_more&quot;        android:icon=&quot;@drawable/more&quot;/&gt;&lt;/menu&gt;</code></pre><p>###然而,你以为会这么简单?? shiftingMode教你做人()</p><p>###这个只会在item个数超过3个才会出现.</p><p><img src="http://upload-images.jianshu.io/upload_images/2520304-464b090fa4c8919c.gif?imageMogr2/auto-orient/strip" srcset="/img/loading.gif" alt="牛逼的特效(shiftingMode).gif"></p><p>4.这让我如何是好?看了半天,在网上找到一个方法.</p><pre><code>/** * 一个关于BottomNavigationView的帮助类,用来关闭shiftingMode * @author 王诛魔 2017/2/10 下午6:35 * @e-mail phyooos@163.com */public class BNVHelper {    public static void disableShiftMode(BottomNavigationView navigationView) {        BottomNavigationMenuView menuView = (BottomNavigationMenuView) navigationView.getChildAt(0);        try {            Field shiftingMode = menuView.getClass().getDeclaredField(&quot;mShiftingMode&quot;);            shiftingMode.setAccessible(true);            shiftingMode.setBoolean(menuView, false);            shiftingMode.setAccessible(false);            for (int i = 0; i &lt; menuView.getChildCount(); i++) {                BottomNavigationItemView itemView = (BottomNavigationItemView) menuView.getChildAt(i);                itemView.setShiftingMode(false);                itemView.setChecked(itemView.getItemData().isChecked());            }        } catch (NoSuchFieldException e) {            // Log        } catch (IllegalAccessException e) {            // Log        }    }}</code></pre><p>原作者@<a href="http://www.jianshu.com/u/4d132a94e6e8" target="_blank" rel="noopener">ChristmasJason</a>:<a href="http://www.jianshu.com/p/e2a8791e80d6" target="_blank" rel="noopener">http://www.jianshu.com/p/e2a8791e80d6</a></p><p>然后我看了一下源码<strong>mShiftingMode</strong> 这个布尔值决定了是否启用shiftingMode,所以上面的方法就是shiftingMode.setBoolean(menuView, false);</p><p>然后就好了……</p><p>提示:<br>google说选中图标的颜色是这么改的,然而都是骗人的,这个应该是默认的设置,我也偷懒没有验证</p><p><img src="http://upload-images.jianshu.io/upload_images/2520304-c6c71ad14a9e0106.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" srcset="/img/loading.gif" alt="2017-02-21_17-59-10.png"></p><pre><code>app:itemIconTint=&quot;@color/nav_color_select&quot;app:itemTextColor=&quot;@color/nav_color_select&quot;</code></pre><p>其实你配置了之后,就是这个东西来决定的,而不是app’s primary color<br>nav_color_select.xml这就是个选择器,代码如下:</p><pre><code>&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;&lt;selector xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;&gt;    &lt;item android:state_checked=&quot;true&quot;  android:color=&quot;@color/colorPrimary&quot; /&gt;    &lt;item android:state_pressed=&quot;true&quot;  android:color=&quot;@color/colorPrimary&quot; /&gt;    &lt;item android:color=&quot;@color/gray_light&quot; /&gt;&lt;/selector&gt;</code></pre><p>####End,到这里你的导航条也应该ok了</p>]]></content>
    
    
    <categories>
      
      <category>Android</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Android</tag>
      
      <tag>View</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Android Studio 使用正式签名debug调试</title>
    <link href="undefined2017/12/25/Android-Studio-signature-debug/"/>
    <url>2017/12/25/Android-Studio-signature-debug/</url>
    
    <content type="html"><![CDATA[<p>###解决问题:</p><blockquote><p>很多时候我们使用第三方登录什么的东西,需要我们提供正式签名,但是我们总是需要调试的.<br>一般情况,我们不可能一次性OK,那么每一次调试都需要正式签名打包,并安装,然后再调试,这也太麻烦了,.</p></blockquote><p>所以,直接上代码:</p><pre><code>signingConfigs {        release {            keyAlias &#39;phyooos&#39;            keyPassword &#39;phyooos&#39;            storeFile file(&#39;phyooos.jks&#39;)            storePassword &#39;phyooos&#39;        }    }    buildTypes {        release {            minifyEnabled false            signingConfig signingConfigs.release            proguardFiles getDefaultProguardFile(&#39;proguard-android.txt&#39;), &#39;proguard-rules.pro&#39;        }        debug{            minifyEnabled false            signingConfig signingConfigs.release            proguardFiles getDefaultProguardFile(&#39;proguard-android.txt&#39;), &#39;proguard-rules.pro&#39;        }    }</code></pre><p><strong>解释一下:</strong></p><pre><code>signingConfigs {        release {            keyAlias &#39;phyooos&#39;            keyPassword &#39;phyooos&#39;            storeFile file(&#39;phyooos.jks&#39;)            storePassword &#39;phyooos&#39;        }    }</code></pre><p>这一段代码写在项目app目录下&gt;gradle配置文件中&gt;android节点下,<br>是我们自定义的一个配置</p><ul><li>keyAlias ‘phyooos’  这是签名文件的Alias</li><li>keyPassword ‘phyooos’   这是签名文件的密码</li><li>storeFile file(‘phyooos.jks’)  这个就是签名文件的地址,我放在app目录下了</li><li>storePassword ‘phyooos’  这是store密码</li></ul><hr><pre><code>buildTypes {        release {            minifyEnabled false            signingConfig signingConfigs.release            proguardFiles getDefaultProguardFile(&#39;proguard-android.txt&#39;), &#39;proguard-rules.pro&#39;        }        debug{            minifyEnabled false            signingConfig signingConfigs.release            proguardFiles getDefaultProguardFile(&#39;proguard-android.txt&#39;), &#39;proguard-rules.pro&#39;        }    }</code></pre><p>这一段的意思就是debug调试以及正式打包都使用上面自定义的配置</p><h4 id="The-End-好了-愉快的玩耍吧"><a href="#The-End-好了-愉快的玩耍吧" class="headerlink" title="The End   好了,愉快的玩耍吧"></a>The End   好了,愉快的玩耍吧</h4>]]></content>
    
    
    <categories>
      
      <category>Android Studio</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Android</tag>
      
      <tag>Android Studio</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>低功耗蓝牙iBeacon的开发笔记</title>
    <link href="undefined2017/12/25/Bluetooth-iBeacon/"/>
    <url>2017/12/25/Bluetooth-iBeacon/</url>
    
    <content type="html"><![CDATA[<p>###1.挣扎的开始<br>各种百度,google,发现国内资料很少,有的也是商业公司提供的sdk,这并不符合我需要,<br>google倒是不少,然而以我的英语水平,望洋兴叹罢了@</p><blockquote><p>首先你需要了解这些资料<br>1、profile<br> rofile可以理解为一种规范，一个标准的通信协议，它存在于从机中。蓝牙组织规定了一些标准的profile，例如 HID OVER GATT ，防丢器 ，心率计等。每个profile中会包含多个service，每个service代表从机的一种能力。</p><p>2、service<br>service可以理解为一个服务，在ble从机中，通过有多个服务，例如电量信息服务、系统信息服务等，每个service中又包含多个characteristic特征值。每个具体的characteristic特征值才是ble通信的主题。比如当前的电量是80%，所以会通过电量的characteristic特征值存在从机的profile里，这样主机就可以通过这个characteristic来读取80%这个数据</p><p>3、characteristic<br>characteristic特征值，ble主从机的通信均是通过characteristic来实现，可以理解为一个标签，通过这个标签可以获取或者写入想要的内容。</p><p>4、UUID<br>UUID，统一识别码，我们刚才提到的service和characteristic，都需要一个唯一的uuid来标识<br>S: 百度到的,我以一个过来人的身份保证这个很重要</p></blockquote><a id="more"></a><p>###2.资料,准备<br>资料看这里:</p><ul><li>这也是最重要的资料来源,谷歌SDK的例子里面有的项目<br><img src="http://img.blog.csdn.net/20160710190336812" srcset="/img/loading.gif" alt="Android SDK 中的doc文档"></li></ul><ul><li>接上文,说完资料,<blockquote><p>这是一个很好的demo<br>sdk\samples\android-22\connectivity\BluetoothLeGatt</p></blockquote></li></ul><p>该目录下为谷歌提供的demo,我的应用也是在它的基础上改进而成的.<br>由以下部分组成:</p><ol><li><p>一个服务 BluetoothLeService,主负责与蓝牙设备进行数据交换</p></li><li><p>两个activity:DeviceControlActivity,DeviceScanActivity</p><pre><code>见名知意,一个负责扫描设备,而两外一个与设备进行交互</code></pre></li><li><p>一个SampleGattAttributes<br>   主要是存储了一些UUID,我对它进行了加强</p></li></ol><p>###3.BLE设备的使用步骤概况</p><ol><li>首先要说明的一点是,要求Android版本为4.3及其以上<br>  接着确认设备支持</li></ol><pre><code>/** * 支持BLE *  check to determine whether BLE is supported on the device */public void isSupported(){     if (!getPackageManager().hasSystemFeature(PackageManager.FEATURE_BLUETOOTH_LE)) {            Toast.makeText(this, &quot;设备不支持BLE功能&quot;, Toast.LENGTH_SHORT).show();        }    }</code></pre><ol><li>确认手机支持并打开蓝牙的状态下,你就可以进行设备的搜索了<br>   有两种模式</li></ol><pre><code>//第一种//serviceUuids   指定设备的UUID//callback       搜索的回调startLeScan(final UUID[] serviceUuids, final LeScanCallback callback)//第二种//其实就是不传入serviceUuids的,就是说搜索范围内所有蓝牙设备public boolean startLeScan(LeScanCallback callback) {     return startLeScan(null, callback);}</code></pre><ol><li>同时记得停止搜索,当然你也可以一直搜<br>PS：其实我见到的app大部分是不停的搜索，这样的话会有一个广播数据持续刷新的效果,那么很多的距离判断什么的都是通过这种不停搜索的形式来工作的</li></ol><pre><code>//mBluetoothAdapter   请自行查看谷歌文档//mLeScanCallback     这就是上面提过的LeScanCallback的实例mBluetoothAdapter.stopLeScan(mLeScanCallback);</code></pre><p>接着就是在回调中拿到各个设备数据了</p><pre><code>/** * 搜索设备回调  */private BluetoothAdapter.LeScanCallback mLeScanCallback =            new BluetoothAdapter.LeScanCallback() {    @Override    public void onLeScan(final BluetoothDevice device, int rssi,             byte[] scanRecord) {    }};</code></pre><p>这里有几个值得说一下的东西</p><ul><li><strong>BluetoothDevice device</strong><br><img src="http://img.blog.csdn.net/20160712000123059" srcset="/img/loading.gif" alt="这里写图片描述"><br>  该可以看的很清楚,    device中包含了设备的基本信息               </li></ul><ul><li><strong>rssi信号质量,也有人告诉我是质量</strong><br>不过我这次并没有使用到</li></ul><ul><li><strong>byte[] scanRecord (重头戏)</strong><br>广播响应包数据<br>一般包括两个部分,我使用的主要是ServiceData域<br><strong>在这里需要注意的是，这两个部分都存在于广播数据，而且并不是两部分都有，有可能是只有一个部分，所以一定要看情设备的硬件规范，因为这涉及到后面解析广播数据</strong></li></ul><p>要知道，我们都是拿byte[]数组中的某些部分对应特定值,一旦对应关系打乱，那么数据解析就没什么正确性可言了<br>这些广播数据都是依据一定的规则指定 的,所以这时候你需要设备厂商的文档来查看对应的数据,以及其结构<br>PS:需要注意的一点是,这些数据都是byte[],你需要将它们转化(一般常用的做法是,先转化为16进制的字符串,而后再进行读取解析)</p><p>###4.读取蓝牙设备内部数据<br>这里涉及到两个重要部分<br>service  以及 characteristic</p><p>一般来说<br> 一个Service  eg: FF01-XXXXXXXXXXX-XXXXX<br> 下面可能有很多的characteristic<br>Marjor : FF16 -XXXXXX<br>Power : FF17 - XXX<br>….一堆的characteristic </p><ul><li><strong>如果需要给指定的项目写入一个数据</strong><br> 条件：<pre><code>          1.此特征在哪个Service下，即该service的UUID          2.该特征的UUID          3.该特征的写入格式，16进制还是其他的东西</code></pre></li></ul><pre><code>//代码片段1//此方法获取对应特征值的对象BluetoothGattCharacteristic的实体    public BluetoothGattCharacteristic getCharacteristic(String service,String charact) {        if (mBluetoothGatt == null) return null;        if(mBluetoothGatt.getService(UUID.fromString(service))==null){return null ;}        return mBluetoothGatt.getService(UUID.fromString(service)).getCharacteristic(UUID.fromString(charact));    }</code></pre><pre><code>//代码片段2if(!TextUtils.isEmpty(value)){//输入非空      byte[] arrayOfByte= new byte[2];//传入数据规定为2个byte      arrayOfByte[0] = ((byte)Integer.parseInt((value).substring(0, 2), 16));      arrayOfByte[1] = ((byte)Integer.parseInt((value).substring(2, 4), 16));      //上面操作，先切，再转为16进制      characteristic.setValue(arrayOfByte);      //characteristic实体就是片段1代码获取到的      gattServer.writeCharacteristic(characteristic);      //所有的操作都封装在一个service中，gattServer为其实体对象}</code></pre><pre><code>  //片段3就是服务中的写入方法  /**     * 写入一个数据     * @param characteristic     */    public void writeCharacteristic(BluetoothGattCharacteristic characteristic) {        mBluetoothGatt.setCharacteristicNotification(characteristic, true);        mBluetoothGatt.writeCharacteristic(characteristic);    }</code></pre><pre><code>//代码片段4   这是回调，//在连接时就作为参数传入了 mBluetoothGatt = device.connectGatt(this, false, mGattCallback);private final BluetoothGattCallback mGattCallback = new BluetoothGattCallback() {        @Override        public void onConnectionStateChange(BluetoothGatt gatt, int status, int newState) {            if (newState == BluetoothProfile.STATE_CONNECTED) {                            Log.e(TAG, &quot;连接至 GATT server.&quot;);            } else if (newState == BluetoothProfile.STATE_DISCONNECTED) {                Log.e(TAG, &quot;断开 GATT server.&quot;);                         }        }        @Override        public void onServicesDiscovered(BluetoothGatt gatt, int status) {            if (status == BluetoothGatt.GATT_SUCCESS) {                Log.e(TAG, &quot;建立连接成功&quot;);                          } else {                Log.e(TAG, &quot;连接状态异常: &quot; + status);            }        }        @Override        public void onCharacteristicWrite(BluetoothGatt gatt, BluetoothGattCharacteristic characteristic, int status) {            if (status == BluetoothGatt.GATT_SUCCESS) {                  Log.e(TAG, &quot;写入数据成功&quot;);               }         }        @Override        public void onCharacteristicRead(BluetoothGatt gatt, BluetoothGattCharacteristic                characteristic, int status) {            if (status == BluetoothGatt.GATT_SUCCESS) {               Log.e(TAG, &quot;读取数据成功&quot;);               }        }        @Override        public void onCharacteristicChanged(BluetoothGatt gatt,                                            BluetoothGattCharacteristic characteristic) {            Log.e(TAG, &quot;连接状态发生改变&quot;);              };}</code></pre><blockquote><p>PS:<strong>这里的例子是写入，其实读取的操作与此类似，操作完成后在回调里面判断状态以及读取数据即可</strong></p></blockquote>]]></content>
    
    
    <categories>
      
      <category>Android</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Android</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Android Studio 基本设置</title>
    <link href="undefined2017/12/25/Android-Studio-Config/"/>
    <url>2017/12/25/Android-Studio-Config/</url>
    
    <content type="html"><![CDATA[<p>####1.常用的快捷键</p><ul><li>ALT + Enter 自动提示</li><li><p>ALT + Ins<br><img src="http://img.blog.csdn.net/20160503215809984" srcset="/img/loading.gif" alt="这里写图片描述"></p><blockquote><p>get set 构造方法  重写方法<br>以及一些插件如这里的 GsonFormat 以及 Butterknife</p></blockquote></li><li><p>Ctrl + Alt + F  全局变量</p></li><li><p>Ctrl +Shift + Enter   加; 以及if 的(){}</p></li><li><p>Ctrl + P  以及  Ctrl + Q  方法参数以及文档</p></li><li><p>Ctrl +O 继承重写的方法</p></li><li><p>Ctrl + /   Ctrl +Shift + /    注释</p></li><li><p>Ctrl + Alt + L 格式化</p></li><li><p>Ctrl + D  Ctrl + Y   复制 删除行</p></li><li><p>Ctrl + Shift + U 大小写</p></li><li><p>Shift Shift     Ctrl + F  全局  当前 搜索 </p></li><li><p>Ctrl + U 到父类</p></li><li><p>Ctrl + Alt + B 找到子类</p></li><li><p>Ctrl + H     类结构</p></li><li><p>Ctrl+Shift + H   方法层次</p></li><li><p>Ctrl + Alt + H   调用层次</p></li><li><p>Alt + F7  find use  非常好用的功能</p></li><li><p>Shift + F6  重命名</p></li><li><p>logt + Enter    Tag </p></li><li><p>loge logd …    打印log</p></li></ul><hr><p>####2.自动生成代码 </p><blockquote><p>Ctrl  + J   </p></blockquote><p><img src="http://img.blog.csdn.net/20160503222913571" srcset="/img/loading.gif" alt="这里写图片描述"></p><p>里面相当多的模版代码</p><pre><code>if 判空     ifnfor 循环     for foreach     foreachsetVisibility     gonefindViewById   fbcinstanceof    inst</code></pre><p>这些比较常用</p><p>####3.自动导入包<br>Settings&gt;Editor&gt;General&gt;Auto import<br><img src="http://img.blog.csdn.net/20160503215409545" srcset="/img/loading.gif" alt="这里写图片描述"></p><p>####4.其他设置已经导出</p><blockquote><p>ps : 在百度云里有<br><img src="http://img.blog.csdn.net/20160503223900468" srcset="/img/loading.gif" alt="这里写图片描述"></p></blockquote>]]></content>
    
    
    <categories>
      
      <category>Android Studio</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Android Studio</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Android Studio 导入 Vitamio及横竖屏切换</title>
    <link href="undefined2017/12/25/Android-Studio-Vitamio/"/>
    <url>2017/12/25/Android-Studio-Vitamio/</url>
    
    <content type="html"><![CDATA[<p>##建议不要使用Vitamio,各种深坑</p><blockquote><p><a href="https://github.com/Bilibili/ijkplayer看看bilibili的开源播放器" target="_blank" rel="noopener">https://github.com/Bilibili/ijkplayer看看bilibili的开源播放器</a></p></blockquote><p>##Vitamio<br>官方:<a href="https://www.vitamio.org/" target="_blank" rel="noopener">https://www.vitamio.org/</a><br>GitHub:<a href="https://github.com/yixia/VitamioBundle" target="_blank" rel="noopener">https://github.com/yixia/VitamioBundle</a></p><blockquote><p><a href="https://www.vitamio.org/" target="_blank" rel="noopener">Vitamio</a> 能够流畅播放720P甚至1080P高清MKV，FLV，MP4，MOV，TS，RMVB等常见格式的视频，支持 MMS, RTSP, RTMP, HLS(m3u8) 等常见的多种视频流媒体协议，包括点播与直播。</p></blockquote><a id="more"></a><p>###下载Vitamio<br>  <img src="http://img.blog.csdn.net/20160408235109325" srcset="/img/loading.gif" alt="去官网下载即可"></p><ul><li>地址<a href="https://www.vitamio.org/Download/" target="_blank" rel="noopener">https://www.vitamio.org/Download/</a></li></ul><hr><p>###解压并导入Android</p><ul><li><p>找到到文件夹VitamioBundle</p><p><img src="http://img.blog.csdn.net/20160408235743265" srcset="/img/loading.gif" alt="VitamioBundle"></p></li><li><p>File &gt; New &gt; New Module<br><img src="http://img.blog.csdn.net/20160409000630784" srcset="/img/loading.gif" alt="这里写图片描述"></p></li><li><p>导入完成后是这样的</p><p><img src="http://img.blog.csdn.net/20160409001321974" srcset="/img/loading.gif" alt="这里写图片描述"></p></li></ul><p>###导入到自己的项目</p><p>(即不使用Vitamio的libiary,强迫症专属)</p><p><img src="http://img.blog.csdn.net/20160908231510455" srcset="/img/loading.gif" alt="这里写图片描述"></p><p>####A.在自己的目录下建立io.vov.vitamio<br>    并导入所有的类,以及将jniLibs目录拷贝到main目录下,还有相关的资源文件</p><p>####B.在AndroidManifest.xml文件中写入</p><pre><code>&lt;activity android:name=&quot;io.vov.vitamio.activity.InitActivity&quot;             android:configChanges=&quot;orientation|screenSize|smallestScreenSize|keyboard|keyboardHidden|navigation&quot;android:launchMode=&quot;singleTop&quot;android:theme=&quot;@android:style/Theme.NoTitleBar&quot;android:windowSoftInputMode=&quot;stateAlwaysHidden&quot;/&gt;</code></pre><blockquote><p>并加入相应的权限</p></blockquote><p>####C.在你喜欢的地方初始化Vitamio<br> 开玩笑的,放在activity或者是Application的onCreate中</p><blockquote><p>Vitamio.isInitialized(application.getApplicationContext()); </p></blockquote><hr><p>###Vatimio的使用</p><p>####A.界面的搭建<br><img src="http://img.blog.csdn.net/20160908232554310" srcset="/img/loading.gif" alt="这里写图片描述"></p><p>可以看到<br>    整个页面主要分上下两层,主要是为了视屏全屏的时候能方便的隐藏整个下面的布局</p><p>####B.使用<br>在此之前为了方便的使用视屏全屏播放,对MediaController(package io.vov.vitamio.widget)做一个小小的改造:<br>添加一个构造:主要用于把视屏,进度条等放到一个View中,便于全屏展示</p><pre><code>//这个全屏的操作可把我难坏了,看到这个真的是为原作者的机智点赞  public MediaController(Context context,boolean fromXml,View container) {    super(context);    initController(context);    mFromXml = fromXml;    mRoot = makeControllerView();    //这个地方的FrameLayout.LayoutpParams是因为布局文件中要把MediaController的视图作为childView加到一个FrameLayout中去    LayoutParams p = new LayoutParams(LayoutParams.FILL_PARENT, LayoutParams.WRAP_CONTENT);    //想怎样布局MediaController就尽情的发挥这个LayoutParams吧    p.gravity = Gravity.BOTTOM;    mRoot.setLayoutParams(p);    ((FrameLayout)container).addView(mRoot);  }</code></pre><p>接着你就可以愉快的玩耍了:<br>在oncreate中调用</p><pre><code>  initVitamioView();</code></pre><pre><code>//初始化控件private void initVitamioView() {//VideoViewmVideoView = (VideoView) findViewById(R.id.buffer);//这个就是包裹整个视屏模块的FrameLayoutfl_controller = (FrameLayout) findViewById(R.id.fl_controller);//缓冲时出现的进度条pb = (ProgressBar) findViewById(R.id.probar);//播放进度,并可以拖动调节视屏播放位置downloadRateView = (TextView) findViewById(R.id.download_rate);loadRateView = (TextView) findViewById(R.id.load_rate);//设置视屏setVideoURI可以缓冲并播放//setVideoPath()缓冲完再播放mVideoView.setVideoURI(Uri.parse(TextUtils.isEmpty(path)?defaultPath:path));//这里使用自定义的那个MediaController构造mMediaController= new MediaController(this, true, fl_controller);//这里的监听其实是在MediaController中自己定义的,主要就是全屏的切换按钮mMediaController.setOnControllerClick(new MediaController.OnControllerClick() {     @Override     public void OnClick(int type) {         if (type == 0) {  //表示点击切换全屏按钮              if (isPortrait) {                  //不是全屏,切换为全屏                 //代码块1               } else {                  //是全屏,近来就切为原来的大小                 //代码块2               }          }          }        });//类似绑定 mVideoView.setMediaController(mMediaController);//隐藏控制模块mMediaController.setVisibility(View.GONE);mVideoView.requestFocus();//设置对视屏信息的监听mVideoView.setOnInfoListener(this);//视屏缓冲的监听mVideoView.setOnBufferingUpdateListener(this);//视屏OKmVideoView.setOnPreparedListener(new MediaPlayer.OnPreparedListener() {     @Override     public void onPrepared(MediaPlayer mediaPlayer) {         //设置播放速度         mediaPlayer.setPlaybackSpeed(1.0f);            }        });    }</code></pre><blockquote><p>补充代码块1</p><pre><code>RelativeLayout.LayoutParams fl_lp = new RelativeLayout.LayoutParams(displayheight, displayWidth);                        fl_controller.setLayoutParams(fl_lp);//设置横屏                        setRequestedOrientation(ActivityInfo.SCREEN_ORIENTATION_LANDSCAPE);  //这样mVideoView会自己充满全屏                        mVideoView.setVideoLayout(VideoView.VIDEO_LAYOUT_SCALE, 0);                        isPortrait = false;</code></pre><p>代码块2</p><pre><code>RelativeLayout.LayoutParams fl_lp = new RelativeLayout.LayoutParams(                                LinearLayout.LayoutParams.MATCH_PARENT,                                DensityUtils.dip2px(ClassRoomActivity.this,200)                        );                        fl_controller.setLayoutParams(fl_lp);                        setRequestedOrientation(ActivityInfo.SCREEN_ORIENTATION_PORTRAIT);                        isPortrait = true;</code></pre></blockquote><pre><code>/* * 横竖屏切换的时候回走这个回调 * */@Overridepublic void onConfigurationChanged(Configuration newConfig) {        //屏幕切换时，设置全屏        if (this.getResources().getConfiguration().orientation == Configuration.ORIENTATION_LANDSCAPE) {            //隐藏下面的布局和标题            tLBelow.setVisibility(View.GONE);            mTitlebar.setVisibility(View.GONE);        }        if (this.getResources().getConfiguration().orientation == Configuration.ORIENTATION_PORTRAIT) {             //显示下面的布局和标题            tLBelow.setVisibility(View.VISIBLE);            mTitlebar.setVisibility(View.VISIBLE);        }        super.onConfigurationChanged(newConfig);    }</code></pre><p>####C.两个重要的监听(上面已经注册过了)</p><pre><code>//缓冲的监听@Override    public void onBufferingUpdate(MediaPlayer mp, int percent) {    //显示缓冲进度        loadRateView.setText(percent + &quot;%&quot;);    }</code></pre><pre><code>//视屏信息监听@Override    public boolean onInfo(MediaPlayer mp, int what, int extra) {        switch (what) {        //开始缓冲            case MediaPlayer.MEDIA_INFO_BUFFERING_START:                if (mVideoView.isPlaying()) {                    mVideoView.pause();                    pb.setVisibility(View.VISIBLE);                    downloadRateView.setText(&quot;&quot;);                    loadRateView.setText(&quot;&quot;);                    downloadRateView.setVisibility(View.VISIBLE);                    loadRateView.setVisibility(View.VISIBLE);                }                break;                //停止缓冲,这里自动开始播放            case MediaPlayer.MEDIA_INFO_BUFFERING_END:                mVideoView.start();                pb.setVisibility(View.GONE);                downloadRateView.setVisibility(View.GONE);                loadRateView.setVisibility(View.GONE);                break;            case MediaPlayer.MEDIA_INFO_DOWNLOAD_RATE_CHANGED:                //缓冲的...那个啥    change                downloadRateView.setText(&quot;&quot; + extra + &quot;kb/s&quot; + &quot;  &quot;);                break;        }        return true;    }</code></pre><p>###4.就这样<br>   对了,完事记得</p><pre><code>@Override    protected void onDestroy() {            mVideoView.stopPlayback();           super.onDestroy();    }</code></pre><p>基本就是这样了,其他的问题自己解决一下就好了…</p>]]></content>
    
    
    <categories>
      
      <category>Android Studio</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Android</tag>
      
      <tag>Android Studio</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Linux 学习笔记</title>
    <link href="undefined2017/12/24/Linux-learn/"/>
    <url>2017/12/24/Linux-learn/</url>
    
    <content type="html"><![CDATA[<ul><li>netstat -an</li></ul><pre><code>查看所有网络连接</code></pre><ul><li>more命令</li></ul><pre><code>选项-num    指定屏幕的行数（以整数表示）+num    从行号num开始显示-d    让more给用户显示信息[Press space to continue, &#39;q&#39; to quit.]-f    使more计数逻辑行，而不是屏幕行（长行不会断到下一行）-s   把重复的空行压缩成一个空行-u    防止下划线交互基于VIM</code></pre><a id="more"></a><ul><li>字符界面</li></ul><p>1.字符界面占用资源少</p><p>2.减少了出错,被攻击的可能</p><ul><li>一切皆文件</li></ul><p>用户  硬件 文件….</p><ul><li>分区</li><li>swap 内存的两倍</li></ul><p>/ 根分区</p><p>/boot    boot分区  200m即可  (作为启动盘使用,启动需要空间)</p><p>/home  </p><p>/etc</p><p>…</p><ul><li>安装日志</li></ul><p>/root/install.log     记录了安装在系统中的软件包和版本信息</p><p>/root/install.log.syslog    安装过程的记录</p><p>/root/anaconda-ks.cfg    记录安装过程中的配置信息(用于网络批量安装)</p><ul><li>linux起始符</li></ul><pre><code class="shell">[root@hadoop ~]#root 用户名hadoop  当前用户的主机名&quot;~&quot; 当前的目录, &quot;~&quot;表示家目录&quot;#&quot; 超级用户的提示符&quot;$&quot; 普通用户的提示符</code></pre><pre><code></code></pre><ul><li>-rw-r–r–</li></ul><pre><code class="shell">drwxr-xr-x. 2 wzm wzm 4096 6月  21 16:19 Desktop#一共10位  drwxr-xr-x#d第一位 文件类型( -文件  d目录 |软链接文件   c  b )#rwx r-x r-x后面的每三位是一组第一个三位   所属者u第二个三位   所属组g第三个三位   其他人o#acf权限r读w写x执行</code></pre><ul><li>目录</li></ul><pre><code class="shell">/        根目录/etc     配置文件目录/bin     系统命令的目录 (普通用户即可读取)/sbin    系统命令的目录 (超级用户即可读取)/usr/bin 系统命令的目录 (普通用户即可读取)/usr/sbin系统命令的目录 (超级用户即可读取)/home    普通用户的家目录/root    超级用户的家目录/usr     系统软件资源目录/boot    启动目录/var     系统相关文档/sys     直接写入内存/proc    直接写入内存/dev     设备文件目录/lib     系统库 保存目录/mnt     系统挂载目录/media   挂载目录</code></pre><ul><li><p>linux 常用命令     control + L  清屏</p></li><li><p>文件命令</p><ul><li>基本命令格式</li></ul><pre><code class="shell">命令 [选项] [参数]#lsls    -a  显示所有文件   -l  显示详细信息,目录下所有内容   -d  查看目录属性,目录本身   -h  人性化显示文件大小   -i  显示inode  文件的id号ll ll -l#</code></pre></li></ul><ul><li><p>目录文件处理</p><pre><code class="shell">#mkdir  创建目录mkdir -p  递归创建,创建多级目录#cd  切换目录cd ~  当前用户的家目录-  进入上次进入的目录.. 进入上级目录.  进入当前目录#pwdpwd  显示当前目录全路径#rm -rf [文件或目录]rm -f 强制删除-r 删除目录#cpcp-r 复制目录-p 连带文件的属性一起复制-d 如果文件为链接文件,则复制链接属性-a 相当于-pdr#mvmv [源地址] [目标地址]</code></pre></li></ul><ul><li><p>软链接命令(源文件一定写巨绝对路径)</p><pre><code class="shell">#ln [源] [目标]ln不能跨分区,不能是一个目录相当于一个文件   文件id号相同-s    软链接   类似windows里面的快捷方式有自己的id号   其实是去查看自己的存储点,存储点里面是源文件的id号,然后又用源文件id号去找源文件的存储点</code></pre></li></ul><ul><li><p>搜索命令</p><pre><code>locate 文件搜索命令whereis 与 whichfind 文件搜索命令grep 字符串搜索命令</code></pre><ul><li><p>locate </p><pre><code class="shell">#locatelocate [文件名]在后台数据库中按文件名搜索位置在:/var/lib/mlocate#updatedbupdatedb 更新数据库</code></pre></li><li><p>whereis </p><pre><code class="shell">#whereiswhereis [命令名] -b 之查找可执行文件 -m 只查找帮助文件</code></pre></li><li><p>which</p><pre><code class="shell">查看#whichwhich [文件名]搜索命令所在目录路径已经别名</code></pre></li><li><p>find</p><pre><code class="shell">#find#避大范围搜索,会非常消耗系统资源#如果不用通配符,则会搜索与文件名完全一致的文件find [搜素范围] [搜索条件]find [搜素范围]   -name [名字]  -iname [名字]  不区分大小写  -user [所有者]  按所有者搜索  -nouser   查找没有所有者的文件   -mtime  [] 修改文件内容的时间   -atime  [] 文件访问时间  -ctime  [] 改变文件属性的时间    [-10 10 +10  10天内  10天当天  +10天前]  -size [大小]  当前目录下查找大小是 25k的文件    [-25k 25k +25k]    [-2M 2M +2M]  -inum [id号]    -a   and 逻辑与,同时满足两个条件   eg find /etc -size +25k -a -size -50k  -o   or  逻辑或,两个条件满足一个条件即可  -exec [一个命令] {} \;   搜索出来的结果再执行一次命令   eg find /etc -size +25k -a -size -50k -exec ls -lh {} \;#通配符*    匹配任何内容?    匹配任意一个字符[]   匹配任意一个中口号内的字符         eg:  abc  abd     find /home -name ab[cd]</code></pre></li></ul></li></ul><ul><li><p>grep</p><pre><code class="shell">#grepgrep &quot;size&quot; system.loggrep是包含匹配   在  system.log  中查找&quot;size&quot;</code></pre></li></ul><ul><li><p>帮助命令</p><pre><code class="shell">man [命令]whatis [命令] man -f [命令]   命令的帮助级别man -k [命令]   模糊匹配apropos [命令]   模糊匹配[命令] --help内核的命令查看帮助help [命令]</code></pre></li></ul><ul><li><p>压缩与解压缩</p><pre><code class="shell">常用压缩格式   .zip  .gz  .bz2   .tar.gz   .tar.bz2</code></pre><ul><li><p>zip</p><pre><code class="shell">zip [压缩文件名字] [源文件]zip -r [压缩文件名字] [源目录]#解压缩unzip [zip文件]</code></pre></li><li><p>gz</p><pre><code class="shell">gzip [源文件]   #压缩为.gz格式的压缩文件,源文件会消失gzip -c [源文件] &gt; 压缩文件#压缩为.gz格式 ,源文件保留gzip -r [源目录] #压缩目录下所有的子文件,但是不能压缩目录#解压缩gzip -d [压缩文件]gunzip [压缩文件]gzp -d -r [目录]   解压目录下所有的文件</code></pre></li><li><p>tar </p><pre><code>#tartar -cvf [打包文件名] [源文件]  -c 打包  -v 显示过程  -f 指定打包后的文件名     eg tar -cvf jp.tar jp#解压缩tar -xvf [压缩文件]</code></pre><ul><li>.tar.gz</li></ul><pre><code>tar -zcvf [压缩文件名] [源文件]#解压缩tar -zxvf [压缩包名.tar.gz]</code></pre></li></ul></li><li><p>关机和重启</p></li></ul><pre><code>shutdown [选项] 时间 -c   取消前一个关机命令 -h   关机 -r   重启logout 退出登录</code></pre><ul><li>其他的命令</li></ul><pre><code>w  显示所有的登录用户last  所有登录信息lastlog   所有用户登录信息</code></pre><ul><li>其他快捷键</li></ul><pre><code>control + c   强制终止当前命令control + l   清屏control + a   光标移动到行首control + e   光标移动到行尾control + u   从光标位置删除到行首control + z   把命令放入到后台control + r   在历史记录中搜索</code></pre><ul><li>输出重定向</li></ul><pre><code>#标准的输出重定向命令 &gt; 文件    覆盖的方式写入命令 &gt;&gt; 文件   追加的方式写入#错误输出重定向错误命令 2&gt; 文件  覆盖的方式写入错误提示错误命令 2&gt;&gt; 文件  追加的方式写入错误提示#正确和错误的同时输出命令  &gt;&gt; 文件 2&gt;&amp;1命令  &amp;&gt;&gt; 文件#正确错误分开输出命令 &gt;&gt; 文件 2&gt;&gt; 文件</code></pre><p>-输入重定向</p><pre><code>wc [选项] [文件名]    -c 统计字节数    -w 统计单词数    -l 统计行数wc在终端输入文字    control + D 统计结果wc [文件名]   文件内容输入到终端</code></pre><ul><li><p>管道符</p><ul><li><p>多命令执行(前一条命令的结果不会传入)</p><pre><code>[命令1] ; [命令2]    顺序执行[命令1] &amp;&amp; [命令2]        命令1执行正确   命令2执行    命令1执行错误   命令2不会执行[命令1] || [命令2]      当命令1执行不正确   命令2执行    命令1执行正确   命令2就不会执行</code></pre><ul><li>管道符(前一条命令的结果传入下一个命令)</li></ul><pre><code># |  [命令1] | [命令2]  命令2会去操作命令1执行的结果</code></pre></li></ul></li><li><p>通配符</p></li></ul><pre><code>?       任意一个字符*       任意内容[]      匹配括号中的某一个字符[-]     匹配括号中的任意一个字符 - 代表一个范围 [a-z] [1-3][^]     表示匹配不是括号中的字符 比如[^0-9] 指匹配不是数字的字符&#39;&#39;      单引号   在单引号中所有字符都没有特殊含义&quot;&quot;      双引号 除了&quot;$&quot; 和 &quot;`&quot; &quot;\&quot; 其他字符都没有特殊意义``      反引号 是系统命令内容$()     用来引用系统命令#       shell中表示注释$       调用变量的值\       转义符</code></pre>]]></content>
    
    
    <categories>
      
      <category>Server</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Server，Linux</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Facebook/Stetho——Android开发调试神器</title>
    <link href="undefined2017/12/24/Facebook-Stetho/"/>
    <url>2017/12/24/Facebook-Stetho/</url>
    
    <content type="html"><![CDATA[<p>####一、简介</p><p>Stetho是一个Android应用调试工具。集成后，开发人员可以通过Chrome的开发工具查看App相关的信息和调试；可视化操作，不需要自己使用adb也不需要root权限。</p><a id="more"></a><p>####二、APP集成</p><p>1.下载最新的jar，或者通过Gradle引入stetho的libraay</p><pre><code>compile &#39;com.facebook.stetho:stetho:1.3.1&#39;</code></pre><p>2.只需要在 Application的 onCreate 方法中调用</p><pre><code>public class MyApplication extends Application {   public void onCreate() {     super.onCreate();     Stetho.initializeWithDefaults(this);   } }</code></pre><p>3.如果还想查看网络请求的话，需要引入另外的Library</p><pre><code> compile &#39;com.facebook.stetho:stetho-okhttp3:1.3.1&#39;</code></pre><p>4.使用okhttp 还需要添加 StethoInterceptor</p><pre><code>OkHttpClient client = new OkHttpClient.Builder()             .addNetworkInterceptor(new StethoInterceptor())             .build();</code></pre><p>####三、使用<br>配置完成之后，在Chrome地址栏输入<code>chrome://inspect</code></p><blockquote><p>chrome://inspect/#devices</p></blockquote><p>chrome会检测到我们的app，点击 <em>inspect</em> 进入查看页面</p>]]></content>
    
    
    <categories>
      
      <category>Android</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Android</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>String.format的参数表</title>
    <link href="undefined2017/12/23/string-format/"/>
    <url>2017/12/23/string-format/</url>
    
    <content type="html"><![CDATA[<p>####String.format()</p><pre><code>%s  字符串类型 &quot;mingrisoft&quot;%c  字符类型    &#39;m&#39;%b  布尔类型    true%d  整数类型（十进制）   99%x  整数类型（十六进制）  FF%o  整数类型（八进制）   77%f  浮点类型    99.99%a  十六进制浮点类型    FF.35AE%e  指数类型    9.38e+5%g  通用浮点类型（f和e类型中较短的）%h  散列码 %%  百分比类型   ％%n  换行符%tx 日期与时间类型（x代表不同的日期与时间转换符</code></pre>]]></content>
    
    
    <categories>
      
      <category>Java</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Java</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>透明度对照表</title>
    <link href="undefined2017/12/23/transparency-table/"/>
    <url>2017/12/23/transparency-table/</url>
    
    <content type="html"><![CDATA[<p>####透明度对照表</p><pre><code>100% — FF95% — F290% — E685% — D980% — CC75% — BF70% — B365% — A660% — 9955% — 8C50% — 8045% — 7340% — 6635% — 5930% — 4D25% — 4020% — 3315% — 2610% — 1A5% — 0D0% — 00</code></pre>]]></content>
    
    
    <categories>
      
      <category>Tools</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Android</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>常用正则表达式记录</title>
    <link href="undefined2017/07/31/Regular-Expression/"/>
    <url>2017/07/31/Regular-Expression/</url>
    
    <content type="html"><![CDATA[<h3 id="常用正则"><a href="#常用正则" class="headerlink" title="常用正则"></a>常用正则</h3><table><thead><tr><th>说明</th><th>正则表达式</th></tr></thead><tbody><tr><td>网址（URL）</td><td><code>[a-zA-z]+://[^\s]*</code></td></tr><tr><td>IP地址(IP Address)</td><td>`((2[0-4]\d</td><td>25[0-5]</td><td>[01]?\d\d?).){3}(2[0-4]\d</td><td>25[0-5]</td><td>[01]?\d\d?)`</td></tr><tr><td>电子邮件(Email)</td><td><code>\w+([-+.]\w+)*@\w+([-.]\w+)*\.\w+([-.]\w+)*</code></td></tr><tr><td>QQ号码</td><td><code>[1-9]\d{4,}</code></td></tr><tr><td>HTML标记(包含内容或自闭合)</td><td>`&lt;(.<em>)(.</em>)&gt;.*&lt;\/\1&gt;</td><td>&lt;(.*) \/&gt;`</td></tr><tr><td>密码(由数字/大写字母/小写字母/标点符号组成，四种都必有，8位以上)</td><td><code>(?=^.{8,}$)(?=.*\d)(?=.*\W+)(?=.*[A-Z])(?=.*[a-z])(?!.*\n).*$</code></td></tr><tr><td>日期(年-月-日)</td><td>`(\d{4}</td><td>\d{2})-((1[0-2])</td><td>(0?[1-9]))-(([12][0-9])</td><td>(3[01])</td><td>(0?[1-9]))`</td></tr><tr><td>日期(月/日/年)</td><td>`((1[0-2])</td><td>(0?[1-9]))/(([12][0-9])</td><td>(3[01])</td><td>(0?[1-9]))/(\d{4}</td><td>\d{2})`</td></tr><tr><td>时间(小时:分钟, 24小时制)</td><td>`((1</td><td>0?)[0-9]</td><td>2[0-3]):([0-5][0-9])`</td></tr><tr><td>汉字(字符)</td><td><code>[\u4e00-\u9fa5]</code></td></tr><tr><td>中文及全角标点符号(字符)</td><td><code>[\u3000-\u301e\ufe10-\ufe19\ufe30-\ufe44\ufe50-\ufe6b\uff01-\uffee]</code></td></tr><tr><td>中国大陆固定电话号码</td><td>`(\d{4}-</td><td>\d{3}-)?(\d{8}</td><td>\d{7})`</td></tr><tr><td>中国大陆手机号码</td><td><code>1\d{10}</code></td></tr><tr><td>中国大陆邮政编码</td><td><code>[1-9]\d{5}</code></td></tr><tr><td>中国大陆身份证号(15位或18位)</td><td><code>\d{15}(\d\d[0-9xX])?</code></td></tr><tr><td>非负整数(正整数或零)</td><td><code>\d+</code></td></tr><tr><td>正整数</td><td><code>[0-9]*[1-9][0-9]*</code></td></tr><tr><td>负整数</td><td><code>-[0-9]*[1-9][0-9]*</code></td></tr><tr><td>整数</td><td><code>-?\d+</code></td></tr><tr><td>小数</td><td><code>(-?\d+)(\.\d+)?</code></td></tr><tr><td>不包含abc的单词</td><td><code>\b((?!abc)\w)+\b</code></td></tr></tbody></table><a id="more"></a><h3 id="字符转义"><a href="#字符转义" class="headerlink" title="字符转义"></a>字符转义</h3><p>正则表达式中的反斜杠字符 () 指示其后跟的字符是特殊字符（如下表所示），或应按原义解释该字符。</p><table><thead><tr><th>转义字符</th><th>描述</th><th>模式</th><th>匹配</th></tr></thead><tbody><tr><td>转义字符\a</td><td>描述与报警 (bell) 符 \u0007 匹配。</td><td>模式\a</td><td>匹配“Error!”+“\u0007”中的 “\u0007”</td></tr><tr><td>转义字符\b</td><td>描述在字符类中，与退格键 \u0008 匹配。</td><td>模式[\b]{3,}</td><td>匹配“\b\b\b\b”中的“\b\b\b\b”</td></tr><tr><td>转义字符\t</td><td>描述与制表符 \u0009 匹配。</td><td>模式(\w+)\t</td><td>匹配“item1\titem2\t”中的“item1\t”和“item2\t”</td></tr><tr><td>转义字符\r</td><td>描述与回车符 \u000D 匹配。 （\r 与换行符 \n 不是等效的。）</td><td>模式\r\n(\w+)</td><td>匹配“\r\nThese are\ntwo lines.”中的“\r\nThese”</td></tr><tr><td>转义字符\v</td><td>描述与垂直制表符 \u000B 匹配。</td><td>模式[\v]{2,}</td><td>匹配“\v\v\v”中的“\v\v\v”</td></tr><tr><td>转义字符\f</td><td>描述与换页符 \u000C 匹配。</td><td>模式[\f]{2,}</td><td>匹配“\f\f\f”中的“\f\f\f”</td></tr><tr><td>转义字符\n</td><td>描述与换行符 \u000A 匹配。</td><td>模式\r\n(\w+)</td><td>匹配“\r\nThese are\ntwo lines.”中的“\r\nThese”</td></tr><tr><td>转义字符\e</td><td>描述与转义符 \u001B 匹配。</td><td>模式\e</td><td>匹配“\x001B”中的“\x001B”</td></tr><tr><td>转义字符\nnn</td><td>描述使用八进制表示形式指定字符（nnn 由二位或三位数字组成）。</td><td>模式\w\040\w</td><td>匹配“a bc d”中的“a b”和“c d”</td></tr><tr><td>转义字符\xnn</td><td>描述使用十六进制表示形式指定字符（nn 恰好由两位数字组成）。</td><td>模式\w\x20\w</td><td>匹配“a bc d”中的“a b”和“c d”</td></tr><tr><td>转义字符\cX\cx</td><td>描述匹配 X 或 x 指定的 ASCII 控件字符，其中 X 或 x 是控件字符的字母。</td><td>模式\cC</td><td>匹配“\x0003”中的“\x0003”(Ctrl-C)</td></tr><tr><td>转义字符\unnnn</td><td>描述使用十六进制表示形式匹配 Unicode 字符（由 nnnn 正确表示的四位数）。</td><td>模式\w\u0020\w</td><td>匹配“a bc d”中的“a b”和“c d”</td></tr><tr><td>转义字符\</td><td>描述在后面带有不识别为本主题的此表和其他表中的转义符的字符时，与该字符匹配。 例如，* 与 \x2A 相同，而 . 与 \x2E 相同。 这允许正则表达式引擎区分语言元素（如 <em> 或 ?） 和字符文本（用 \</em> 或 \? 表示）。</td><td>模式\d+[+-x*]\d+</td><td>匹配“(2+2) <em> 3</em>9”中的“2+2”和“3*9”</td></tr></tbody></table><h3 id="字符类"><a href="#字符类" class="headerlink" title="字符类"></a>字符类</h3><p>字符类与一组字符中的任何一个字符匹配。 </p><table><thead><tr><th>字符类</th><th>描述</th><th>模式</th><th>匹配</th></tr></thead><tbody><tr><td>字符类[character_group]</td><td>描述匹配 character_group 中的任何单个字符。 默认情况下，匹配区分大小写。</td><td>模式[ae]</td><td>匹配“gray”中的“a”“lane”中的“a”和“e”</td></tr><tr><td><code>字符类[^character_group]</code></td><td>描述求反：与不在 character_group 中的任何单个字符匹配。 默认情况下，character_group 中的字符区分大小写。</td><td>模式[^aei]</td><td>匹配“reign”中的“r”、“g”和“n”</td></tr><tr><td>字符类[第一个-last]</td><td>描述字符范围：与从第一个到最后一个的范围中的任何单个字符匹配。</td><td>模式[A-Z]</td><td>匹配“AB123”中的“A”和“B”</td></tr><tr><td>字符类.</td><td>描述通配符：与除 \n 之外的任何单个字符匹配。若要匹配文本句点字符（. 或 \u002E），你必须在该字符前面加上转义符 (.)。</td><td>模式a.e</td><td>匹配“nave”中的“ave”“water”中的“ate”</td></tr><tr><td>字符类\p{name}</td><td>描述与 name 指定的 Unicode 通用类别或命名块中的任何单个字符匹配。</td><td>模式\p{Lu}\p{IsCyrillic}</td><td>匹配“City Lights”中的“C”和“L”“ДЖem”中的“Д”和“Ж”</td></tr><tr><td>字符类\P{name}</td><td>描述与不在 name 指定的 Unicode 通用类别或命名块中的任何单个字符匹配。</td><td>模式\P{Lu}\P{IsCyrillic}</td><td>匹配“City”中的“i”、“t”和“y”“ДЖem”中的“e”和“m”</td></tr><tr><td>字符类\w</td><td>描述与任何单词字符匹配。</td><td>模式\w</td><td>匹配“ID A1.3”中的“I”、“D”、“A”、“1”和“3”</td></tr><tr><td>字符类\W</td><td>描述与任何非单词字符匹配。</td><td>模式\W</td><td>匹配“ID A1.3”中的“ ”、“.”</td></tr><tr><td>字符类\s</td><td>描述与任何空白字符匹配。</td><td>模式\w\s</td><td>匹配“ID A1.3”中的“D”</td></tr><tr><td>字符类\S</td><td>描述与任何非空白字符匹配。</td><td>模式\s\S</td><td>匹配” _” in “int __ctr”</td></tr><tr><td>字符类\d</td><td>描述与任何十进制数字匹配。</td><td>模式\d</td><td>匹配“4 = IV”中的“4”</td></tr><tr><td>字符类\D</td><td>描述匹配不是十进制数的任意字符。</td><td>模式\D</td><td>匹配“4 = IV”中的“ ”、“=”、“ ”、“I”和“V”</td></tr></tbody></table><h3 id="定位点"><a href="#定位点" class="headerlink" title="定位点"></a>定位点</h3><p>定位点或原子零宽度断言会使匹配成功或失败，具体取决于字符串中的当前位置，但它们不会使引擎在字符串中前进或使用字符</p><table><thead><tr><th>断言</th><th>描述</th><th>模式</th><th>匹配</th></tr></thead><tbody><tr><td>断言^</td><td>描述匹配必须从字符串或一行的开头开始。</td><td>模式^\d{3}</td><td>匹配“901”“901-”</td></tr><tr><td>断言$</td><td>描述匹配必须出现在字符串的末尾或出现在行或字符串末尾的 \n 之前。</td><td>模式-\d{3}$</td><td>匹配“-333”“-333”</td></tr><tr><td>断言\A</td><td>描述匹配必须出现在字符串的开头。</td><td>模式\A\d{3}</td><td>匹配“901”“901-”</td></tr><tr><td>断言\Z</td><td>描述匹配必须出现在字符串的末尾或出现在字符串末尾的 \n 之前。</td><td>模式-\d{3}\Z</td><td>匹配“-333”“-333”</td></tr><tr><td>断言\z</td><td>描述匹配必须出现在字符串的末尾。</td><td>模式-\d{3}\z</td><td>匹配“-333”“-333”</td></tr><tr><td>断言\G</td><td>描述匹配必须出现在上一个匹配结束的地方。</td><td>模式\G(\d)</td><td>匹配“(1)(3)(5)<a href="9">7</a>”中的“(1)”、“(3)”、“(5)”</td></tr><tr><td>断言\b</td><td>描述匹配必须出现在 \w（字母数字）和 \W（非字母数字）字符之间的边界上。</td><td>模式\b\w+\s\w+\b</td><td>匹配“them theme them them”中的“them theme”、“them them”</td></tr><tr><td>断言\B</td><td>描述匹配不得出现在 \b 边界上。</td><td>模式\Bend\w*\b</td><td>匹配“end sends endure lender”中的“ends”和“ender”</td></tr></tbody></table><h3 id="分组构造"><a href="#分组构造" class="headerlink" title="分组构造"></a>分组构造</h3><p>分组构造描述了正则表达式的子表达式，通常用于捕获输入字符串的子字符串。 分组构造包括下表中列出的语言元素。 </p><table><thead><tr><th>分组构造</th><th>描述</th><th>模式</th><th>匹配</th></tr></thead><tbody><tr><td>分组构造(子表达式)</td><td>描述捕获匹配的子表达式并将其分配到一个从 1 开始的序号中。</td><td>模式(\w)\1</td><td>匹配“deep”中的“ee”</td></tr><tr><td>分组构造(?&lt; 名称 &gt; 子表达式)</td><td>描述将匹配的子表达式捕获到一个命名组中。</td><td>模式(?<double>\w)\k<double></double></double></td><td>匹配“deep”中的“ee”</td></tr><tr><td>分组构造(?&lt; 名称 1 - 名称 2 &gt; 子表达式)</td><td>描述定义平衡组定义。 有关详细信息，请参阅<a href="https://msdn.microsoft.com/zh-cn/library/bs2twtah.aspx" target="_blank" rel="noopener">正则表达式中的分组构造</a>中的“平衡组定义”部分。</td><td>模式(((?’Open’()[^()]<em>)+((?’Close-Open’))[^()]</em>)+)*(?(Open)(?!))$</td><td>匹配“3+2^((1-3)<em>(3-1))”中的“((1-3)</em>(3-1))”</td></tr><tr><td>分组构造(?: 子表达式)</td><td>描述定义非捕获组。</td><td>模式Write(?:Line)?</td><td>匹配“Console.WriteLine()”中的“WriteLine”“Console.Write(value)”中的“Write”</td></tr><tr><td>分组构造(?imnsx-imnsx: 子表达式)</td><td>描述应用或禁用子表达式中指定的选项。 有关详细信息，请参阅<a href="https://msdn.microsoft.com/zh-cn/library/yd1hzczs.aspx" target="_blank" rel="noopener">正则表达式选项</a>。</td><td>模式A\d{2}(?i:\w+)\b</td><td>匹配“A12xl A12XL a12xl”中的“A12xl”和“A12XL”</td></tr><tr><td>分组构造(?= 子表达式)</td><td>描述零宽度正预测先行断言。</td><td>模式\w+(?=.)</td><td>匹配“He is. The dog ran. The sun is out.”中的“is”、“ran”和“out”</td></tr><tr><td>分组构造(?! 子表达式)</td><td>描述零宽度负预测先行断言。</td><td>模式\b(?!un)\w+\b</td><td>匹配“unsure sure unity used”中的“sure”和“used”</td></tr><tr><td>分组构造(?&lt;= 子表达式)</td><td>描述零宽度正回顾后发断言。</td><td>模式(?&lt;=19)\d{2}\b</td><td>匹配“1851 1999 1950 1905 2003”中的“99”、“50”和“05”</td></tr><tr><td>分组构造(?&lt;! 子表达式)</td><td>描述零宽度负回顾后发断言。</td><td>模式(?&lt;!19)\d{2}\b</td><td>匹配“1851 1999 1950 1905 2003”中的“51”和“03”</td></tr><tr><td>分组构造(?&gt; 子表达式)</td><td>描述非回溯（也称为“贪婪”）子表达式。</td><td>模式<a href="?&gt;A+B+">13579</a></td><td>匹配“1ABB 3ABBC 5AB 5AC”中的“1ABB”、“3ABB”和“5AB”</td></tr></tbody></table><h3 id="数量词"><a href="#数量词" class="headerlink" title="数量词"></a>数量词</h3><table><thead><tr><th>限定符</th><th>描述</th><th>模式</th><th>匹配</th></tr></thead><tbody><tr><td>限定符*</td><td>描述匹配上一个元素零次或多次。</td><td>模式\d*.\d</td><td>匹配“.0”，“19.9”和“219.9”</td></tr><tr><td>限定符+</td><td>描述匹配上一个元素一次或多次。</td><td>模式”be+”</td><td>匹配“been”中的“bee”，“bent”中的“be”</td></tr><tr><td>限定符?</td><td>描述匹配上一个元素零次或一次。</td><td>模式”rai?n”</td><td>匹配“ran”和“rain”</td></tr><tr><td>限定符{n}</td><td>描述匹配上一个元素恰好 n 次。</td><td>模式”,\d{3}”</td><td>匹配“1,043.6”中的“,043”，“9,876,543,210”中的“,876”、“,543”和“,210”</td></tr><tr><td>限定符{n,}</td><td>描述匹配上一个元素至少 n 次。</td><td>模式”\d{2,}”</td><td>匹配“166”，“29”和“1930”</td></tr><tr><td>限定符{n,m}</td><td>描述匹配上一个元素至少 n 次，但不多于 m 次。</td><td>模式”\d{3,5}”</td><td>匹配“166”、“17668”“193024”中的“19302”</td></tr><tr><td>限定符*?</td><td>描述匹配上一个元素零次或多次，但次数尽可能少。</td><td>模式\d*?.\d</td><td>匹配“.0”，“19.9”和“219.9”</td></tr><tr><td>限定符+?</td><td>描述匹配上一个元素一次或多次，但次数尽可能少。</td><td>模式”be+?”</td><td>匹配“been”中的“be”，“bent”中的“be”</td></tr><tr><td>限定符??</td><td>描述匹配上一个元素零次或一次，但次数尽可能少。</td><td>模式”rai??n”</td><td>匹配“ran”和“rain”</td></tr><tr><td>限定符{n}?</td><td>描述匹配前面的元素恰好 n 次。</td><td>模式”,\d{3}?”</td><td>匹配“1,043.6”中的“,043”，“9,876,543,210”中的“,876”、“,543”和“,210”</td></tr><tr><td>限定符{n,}?</td><td>描述匹配上一个元素至少 n 次，但次数尽可能少。</td><td>模式”\d{2,}?”</td><td>匹配“166”，“29”和“1930”</td></tr><tr><td>限定符{n,m}?</td><td>描述匹配上一个元素的次数介于 n 和 m 之间，但次数尽可能少。</td><td>模式”\d{3,5}?”</td><td>匹配“166”、“17668”“193024”中的“193”、“024”</td></tr></tbody></table>]]></content>
    
    
    <categories>
      
      <category>Other</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Regular</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>