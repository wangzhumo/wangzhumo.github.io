{"meta":{"title":"王诛魔","subtitle":"WangZhuMo's Blog.","description":"王诛魔","author":"wangzhumo","url":"https://www.wangzhumo.com"},"pages":[{"title":"","date":"2019-10-12T04:01:29.574Z","updated":"2018-01-10T16:04:17.000Z","comments":true,"path":"404.html","permalink":"https://www.wangzhumo.com/404.html","excerpt":"","text":""},{"title":"","date":"2019-10-12T04:01:28.697Z","updated":"2018-07-11T07:41:23.000Z","comments":true,"path":"config/package.json","permalink":"https://www.wangzhumo.com/config/package.json","excerpt":"","text":"{\"name\":\"hexo-site\",\"version\":\"0.0.0\",\"private\":true,\"hexo\":{\"version\":\"3.4.4\"},\"dependencies\":{\"hexo\":\"^3.2.0\",\"hexo-deployer-git\":\"^0.3.1\",\"hexo-generator-archive\":\"^0.1.4\",\"hexo-generator-category\":\"^0.1.3\",\"hexo-generator-index\":\"^0.2.0\",\"hexo-generator-json-content\":\"^3.0.1\",\"hexo-generator-search\":\"^2.1.1\",\"hexo-generator-searchdb\":\"^1.0.8\",\"hexo-generator-seo-friendly-sitemap\":\"0.0.21\",\"hexo-generator-tag\":\"^0.2.0\",\"hexo-renderer-ejs\":\"^0.3.0\",\"hexo-renderer-marked\":\"^0.3.0\",\"hexo-renderer-stylus\":\"^0.3.1\",\"hexo-server\":\"^0.2.0\"},\"devDependencies\":{\"hexo-generator-baidu-sitemap\":\"^0.1.2\",\"hexo-generator-sitemap\":\"^1.2.0\"}}"}],"posts":[{"title":"Flutter稳定版安装","slug":"release-flutter-setup","date":"2019-12-02T11:35:17.000Z","updated":"2019-12-22T11:40:17.554Z","comments":true,"path":"2019/12/02/release-flutter-setup/","link":"","permalink":"https://www.wangzhumo.com/2019/12/02/release-flutter-setup/","excerpt":"安装1.下载稳定版包 https://flutter.dev/docs/development/tools/sdk/releases?tab=macos 选择系统，并选择了v1.9.1+hotfix.6 版本","text":"安装1.下载稳定版包 https://flutter.dev/docs/development/tools/sdk/releases?tab=macos 选择系统，并选择了v1.9.1+hotfix.6 版本 2.解压并配置环境变量flutter on 🌱 stable ➜ pwd /Users/wangzhumo/Develop/flutter flutter on 🌱 stable vim ~/.bash_profile 把路径写入.bash_profile ulimit -S -n 1024 export FLUTTER=/Users/wangzhumo/Develop/flutter #PUB_HOSTED_URL FLUTTER_STORAGE_BASE_URL 是Flutter的国内镜像 export PUB_HOSTED_URL=https://pub.flutter-io.cn export FLUTTER_STORAGE_BASE_URL=https://storage.flutter-io.cn export PATH=$PATH:$FLUTTER/bin //退出到flutter目录 flutter on 🌱 stable ➜ source ~/.base_profile 写完之后wq记得保存，然后source一下 ####3.预先下载（可选） flutter on 🌱 stable ➜ flutter precache 配置Run flutter doctorRun the following command to see if there are any dependencies you need to install to complete the setup (for verbose output, add the -v flag): flutter on 🌱 stable ➜ flutter doctor 运行的结果是： flutter on 🌱 stable took 6s ➜ flutter doctor Doctor summary (to see all details, run flutter doctor -v): [✓] Flutter (Channel stable, v1.9.1+hotfix.6, on Mac OS X 10.15 19A583, locale zh-Hans-CN) [!] Android toolchain - develop for Android devices (Android SDK version 29.0.2) ! Some Android licenses not accepted. To resolve this, run: flutter doctor --android-licenses [✓] Xcode - develop for iOS and macOS (Xcode 11.1) [✓] Android Studio (version 3.5) [!] IntelliJ IDEA Ultimate Edition (version 2019.2.3) ✗ Flutter plugin not installed; this adds Flutter specific functionality. ✗ Dart plugin not installed; this adds Dart specific functionality. [✓] VS Code [✓] Connected device (2 available) ! Doctor found issues in 2 categories. 可以看到我这边Android toolchain有点问题，按照提示的 ➜ flutter doctor --android-licenses Warning: File /Users/wangzhumo/.android/repositories.cfg could not be loaded. 1 of 7 SDK package license not accepted.] 100% Computing updates... //一路 y 下去即可 这一步，可能会耗费大量的时间，再加上网络的问题，比较麻烦，请参考 【使用镜像】 使用镜像【转】 https://flutterchina.club/setup-macos/ 由于在国内访问Flutter有时可能会受到限制，Flutter官方为中国开发者搭建了临时镜像，大家可以将如下环境变量加入到用户环境变量中： export PUB_HOSTED_URL=https://pub.flutter-io.cn export FLUTTER_STORAGE_BASE_URL=https://storage.flutter-io.cn 注意： 此镜像为临时镜像，并不能保证一直可用，读者可以参考详情请参考 Using Flutter in China 以获得有关镜像服务器的最新动态。 运行Demo","categories":[{"name":"Flutter","slug":"Flutter","permalink":"https://www.wangzhumo.com/categories/Flutter/"}],"tags":[{"name":"Flutter","slug":"Flutter","permalink":"https://www.wangzhumo.com/tags/Flutter/"}]},{"title":"OpenGL绘制一个三角形","slug":"learn-opengl-triangle","date":"2019-11-28T09:25:39.000Z","updated":"2019-11-29T09:33:54.939Z","comments":true,"path":"2019/11/28/learn-opengl-triangle/","link":"","permalink":"https://www.wangzhumo.com/2019/11/28/learn-opengl-triangle/","excerpt":"前言这里我会使用刚刚学习到的知识点，尝试绘制一个三角形。使用Android提供的GLSurfaceView配合OpenGL ES完成这个任务。","text":"前言这里我会使用刚刚学习到的知识点，尝试绘制一个三角形。使用Android提供的GLSurfaceView配合OpenGL ES完成这个任务。 GLSurfaceView 实现GLSurfaceView.Renderer glFrustumf，glViewport，glVertexPointer glDrawArrays 编码1.创建TriangleActivity&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt; &lt;androidx.constraintlayout.widget.ConstraintLayout xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot; xmlns:app=&quot;http://schemas.android.com/apk/res-auto&quot; xmlns:tools=&quot;http://schemas.android.com/tools&quot; android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;match_parent&quot; tools:context=&quot;.opengl.triangle.TriangleActivity&quot;&gt; &lt;android.opengl.GLSurfaceView android:id=&quot;@+id/gl_surface_view&quot; android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;match_parent&quot; app:layout_constraintBottom_toBottomOf=&quot;parent&quot; app:layout_constraintEnd_toEndOf=&quot;parent&quot; app:layout_constraintStart_toStartOf=&quot;parent&quot; app:layout_constraintTop_toTopOf=&quot;parent&quot; /&gt; &lt;/androidx.constraintlayout.widget.ConstraintLayout&gt; 加载布局,设置TriangleRenderer @Route(path = IRoute.MEDIA_OPENGL_TRIANGLE) class TriangleActivity : BaseActivity() { override fun getLayoutId(): Int = R.layout.activity_triangle override fun initViews(savedInstanceState: Bundle?) { gl_surface_view.setRenderer(TriangleRenderer()) } } 2.实现TriangleRenderer这里的注释写的很完善了，不做其他的补充 /** * If you have any questions, you can contact by email {wangzhumoo@gmail.com} * * @author 王诛魔 2019-11-29 10:49 * * 三角形的renderer */ class TriangleRenderer : GLSurfaceView.Renderer { private var ratio = 0F override fun onDrawFrame(gl: GL10?) { //切换到模型矩阵 gl?.apply { //清屏,清除颜色缓冲区 glClear(GL10.GL_COLOR_BUFFER_BIT) //gluLookAt 需要操作的是模型矩阵 glMatrixMode(GL10.GL_MODELVIEW) //加载单位矩阵 - 初始化 glLoadIdentity() } /* * @param gl a GL10 interface gl对象 * * @param eyeX eye point X * @param eyeY eye point Y 观察者的位置，最好是与平截头体在一个原点上 * @param eyeZ eye point Z * * @param centerX center of view X * @param centerY center of view Y 观察者的观察方向（朝向0，0，0 原点） * @param centerZ center of view Z * * @param upX up vector X * @param upY up vector Y 观察者向上的位置 * @param upZ up vector Z */ //确定观察的空间坐标 GLU.gluLookAt(gl, 0F, 0F, 5F, 0F, 0F, 0F, 0F, 1F, 0F) //顶点数组 val trianglePoint = floatArrayOf( 0F, ratio, 1F, -1F, -ratio, 1F, 1F, -ratio, 1F ) //创建顶点缓冲区 val pointBuffer = ByteBuffer.allocateDirect(trianglePoint.size * 4) val floatBuffer = TextureUtils.loadVertexBuffer(pointBuffer,trianglePoint) //设置绘图的颜色,使用红色 gl?.glColor4f(1F,0F,0F,1F) //指定3个值确定一个点 //Must use a native order direct Buffer gl?.glVertexPointer(3, GL10.GL_FLOAT, 0, floatBuffer) //画一个三角 gl?.glDrawArrays(GL10.GL_TRIANGLES,0,3) } override fun onSurfaceChanged(gl: GL10?, width: Int, height: Int) { gl?.apply { //viewport视口 也就是opengl可以显示的区域大小 glViewport(0, 0, width, height) //投影矩阵 - 矩阵模式 glMatrixMode(GL10.GL_PROJECTION) //加载单位矩阵 - 初始化 glLoadIdentity() //计算比例，避免缩放后显示变形 ratio = width.toFloat() / height //设置平截头体，为了投射到viewport上时，不超出viewport，top/bottom 按照我们viewport的比例设置 //此处, bottom = -left * ratio top = left * ratio //zNear 近平面距离 //zFar 远平面距离 glFrustumf(-1F, 1F, -ratio, ratio, 3F, 7F) } } override fun onSurfaceCreated(gl: GL10?, config: EGLConfig?) { gl?.apply { //清屏颜色设置 glClearColor(0F, 0F, 0F, 1F) //开启顶点缓冲区 glEnableClientState(GL10.GL_VERTEX_ARRAY) } } } TextureUtils是在渲染Camera时就已经写好的工具了，不重复写了。 小结顶点坐标val trianglePoint = floatArrayOf( 0F, ratio, 1F, -1F, -ratio, 1F, 1F, -ratio, 1F ) x [-1,1] 我们在平截头体中的比例，最大也就是[-1,1] y [-ratio,ratio] 这里我们计算了屏幕的比例，得出的ratio z 这个指定了，我们在平截头体中的z位置，在这个例子中，我们的glFrustumf(-1F, 1F, -ratio, ratio, 3F, 7F)中，用远平面减去近平面， 7 -3 = 4 [0,4] 平截头体glFrustumf(-1F, 1F, -ratio, ratio, 3F, 7F) Left / right 分别为 -1 1 bottom = -left * ratio top = left * ratio zNear 近平面距离 zFar 远平面距离 效果val trianglePoint = floatArrayOf( 0F, ratio, 1F, -1F, -ratio, 1F, 1F, -ratio, 1F ) val trianglePoint = floatArrayOf( 0F, ratio, 2F, -1F, -ratio, 2F, 1F, -ratio, 2F )","categories":[{"name":"Media","slug":"Media","permalink":"https://www.wangzhumo.com/categories/Media/"}],"tags":[{"name":"Media","slug":"Media","permalink":"https://www.wangzhumo.com/tags/Media/"},{"name":"OpenGL","slug":"OpenGL","permalink":"https://www.wangzhumo.com/tags/OpenGL/"}]},{"title":"OpenGL的模型以及渲染管线Pipeline","slug":"learn-opengl-pipeline","date":"2019-11-27T07:14:33.000Z","updated":"2019-11-29T09:34:24.863Z","comments":true,"path":"2019/11/27/learn-opengl-pipeline/","link":"","permalink":"https://www.wangzhumo.com/2019/11/27/learn-opengl-pipeline/","excerpt":"前言OpenGL的学习难度还是很大的。 这里一一记录学习的整个过程，首先我想要先简单了解OpenGL的大概工作流程OpenGL Pipeline，后面会慢慢的完善这个笔记。","text":"前言OpenGL的学习难度还是很大的。 这里一一记录学习的整个过程，首先我想要先简单了解OpenGL的大概工作流程OpenGL Pipeline，后面会慢慢的完善这个笔记。 找到一张比较老的图，这里是以opengl1.1的标准来画的，看起来更容易一些，所以不妨先看看。 Pipeline https://www.khronos.org/opengl/wiki/Rendering_Pipeline_Overview 这张管线图来自官方的wiki,可以说是比较权威的。 顶点数据 VAO(Vertex Array Objects)每个顶点包含的信息 VBO(Vertex Buffer Objects)顶点数据的Buffer 顶点处理 —OpenGL将调用vertex shader来处理顶点 顶点的变换，比如投影矩阵变化 光照，有时还会有光照的处理 顶点着色器 可能会有多个vertex shader，但每次只能执行一个 Tesselation Shading [可选] Geometry Shading [可选] 图元组装 图元组装阶段会把顶点组装成一组相关联的几何图元 裁剪 有的时候，我们的顶点会跑到可显示范围之外去，OpenGL会帮我们把这些不可显示的部分裁切掉，以提高效果，节省资源 栅格化 裁切后的图元经过栅格化，生成fragment,并且会存放在frameBuffer中，这些数据还可以被下面的两部进行加工处理 Fragment Shading fragment shading用前面的信息来决定fragment的颜色，是否需要停止，以及可以处理texture mapping. Per-Fragment Operations 现在对它们的具体含义并不非常清楚，然而我们知道了整个框架，后面的学习过程就是慢慢填充，修改这个框架的过程。 ModelOpenGl的架构，也是很经典的C-S架构。 https://cloud.tencent.com/developer/news/223343 END","categories":[{"name":"Media","slug":"Media","permalink":"https://www.wangzhumo.com/categories/Media/"}],"tags":[{"name":"Media","slug":"Media","permalink":"https://www.wangzhumo.com/tags/Media/"},{"name":"OpenGL","slug":"OpenGL","permalink":"https://www.wangzhumo.com/tags/OpenGL/"}]},{"title":"MediaExtractor与MediaMuxer的简单使用","slug":"mediaextractor-and-mediamuxer-sample","date":"2019-11-26T11:50:39.000Z","updated":"2019-11-28T09:24:49.416Z","comments":true,"path":"2019/11/26/mediaextractor-and-mediamuxer-sample/","link":"","permalink":"https://www.wangzhumo.com/2019/11/26/mediaextractor-and-mediamuxer-sample/","excerpt":"MediaExtractor可以说是一个非常好用的封装了，支持很多输入格式，可以对我们的多媒体文件进行分解，可以用来分离容器中的视频track和音频track。 MediaMuxer用于封装编码后的视频流和音频流。虽然有一些限制条件，但是对于一般的使用还是可以胜任的。","text":"MediaExtractor可以说是一个非常好用的封装了，支持很多输入格式，可以对我们的多媒体文件进行分解，可以用来分离容器中的视频track和音频track。 MediaMuxer用于封装编码后的视频流和音频流。虽然有一些限制条件，但是对于一般的使用还是可以胜任的。 初步认识MediaExtractor https://developer.android.google.cn/reference/android/media/MediaExtractor?hl=en MediaExtractor facilitates extraction of demuxed, typically encoded, media data from a data source. 简单的描述它，就是一个解封装的工具。 MediaExtractor extractor = new MediaExtractor(); //设置来源 extractor.setDataSource(...); //获取媒体文件的track数量 int numTracks = extractor.getTrackCount(); for (int i = 0; i &lt; numTracks; ++i) { MediaFormat format = extractor.getTrackFormat(i); String mime = format.getString(MediaFormat.KEY_MIME); //获取到你想要使用的Track if (weAreInterestedInThisTrack) { //标记这个Track extractor.selectTrack(i); } } ByteBuffer inputBuffer = ByteBuffer.allocate(...) while (extractor.readSampleData(inputBuffer, ...) &gt;= 0) { int trackIndex = extractor.getSampleTrackIndex(); long presentationTimeUs = extractor.getSampleTime(); ... //下一帧 extractor.advance(); } //释放 extractor.release(); extractor = null; doc上提供了一段比较简单的使用方式 几个比较常用的setDataSource,MediaFormat,selectTrack,release MediaMuxer https://developer.android.google.cn/reference/android/media/MediaMuxer?hl=en MediaMuxer facilitates muxing elementary streams. Currently MediaMuxer supports MP4, Webm and 3GP file as the output. It also supports muxing B-frames in MP4 since Android Nougat. 支持的格式有MP4，而我们经常使用的封装也就是MP4啦，比较遗憾的是只能支持单个的Video Track 和 Audio Track。 分离MP4的Video/Audio Track /** * @param path 媒体文件地址 * */ fun extractorMedia(path: String) { val extractor = MediaExtractor() //设置来源 extractor.setDataSource(path) //获取媒体文件的track数量 val numTracks = extractor.trackCount for (index in 0 until numTracks){ val format = extractor.getTrackFormat(index) //获取到你想要使用的Track appendLogs(format.toString()) } } 明确的看到，这个MP4中有一条音频轨，一条视频轨道。 { track-id=2, max-bitrate=129051, //码率、比特率 sample-rate=44100, //采样率 file-format=video/mp4, mime=audio/mp4a-latm, //类型是 audio bitrate=129051, language=, aac-profile=2, durationUs=95087233, aac-format-adif=0, channel-count=2, //声道 max-input-size=65541, csd-0=java.nio.HeapByteBuffer[pos=0 lim=5 cap=5] } { track-id=1, file-format=video/mp4, level=2048, mime=video/avc, //类型是 audio profile=2, language=, display-width=1920, csd-1=java.nio.HeapByteBuffer[pos=0 lim=8 cap=8], durationUs=95041666, display-height=1080, width=1920, rotation-degrees=0, max-input-size=1555201, frame-rate=24, height=1080, csd-0=java.nio.HeapByteBuffer[pos=0 lim=41 cap=41] } 我们继续，下面的操作把这个MP4分离为一个 ouput_video_mp4 , 一个 ouput_audio_mp4 /** * @param path 媒体文件地址 * */ fun extractorMedia(path: String) { val extractor = MediaExtractor() //设置来源 extractor.setDataSource(path) //视频文件 val videoStream = File(OUTPUT_DIR, &quot;output_video_mp4.mp4&quot;).outputStream() //音频文件 val audioStream = File(OUTPUT_DIR, &quot;output_audio_mp4&quot;).outputStream() //记录音频/视屏轨道的index var videoTrackIndex = -1 var audioTrackIndex = -1 //获取媒体文件的track数量 val numTracks = extractor.trackCount for (index in 0 until numTracks) { val format = extractor.getTrackFormat(index) val mimeType = format.getString(MediaFormat.KEY_MIME) //标记视频轨道 if (mimeType.startsWith(&quot;video/&quot;)) { videoTrackIndex = index } //标记音频轨道 if (mimeType.startsWith(&quot;audio/&quot;)) { audioTrackIndex = index } appendLogs(&quot;视频分离 - 任务开始&quot;) // 切换到视频 extractor.selectTrack(videoTrackIndex) readTrackStream(videoStream,extractor) videoStream.close() appendLogs(&quot;视频分离 - 任务结束&quot;) appendLogs(&quot;音频分离 - 任务开始&quot;) // 切换到音频 extractor.selectTrack(audioTrackIndex) readTrackStream(audioStream,extractor) audioStream.close() appendLogs(&quot;音频分离 - 任务结束&quot;) } appendLogs(&quot;任务结束&quot;) extractor.release() } /** * 读取数据，写入到文件中 */ private fun readTrackStream(fileInput: FileOutputStream, extractor: MediaExtractor) { //Buffer val byteBuffer = ByteBuffer.allocate(1024 * 500) var readCount = 0 do { //读取数据 readCount = extractor.readSampleData(byteBuffer,0) if (readCount &lt; 0){ break } //写入文件 val buffer = ByteArray(readCount) byteBuffer.get(buffer) fileInput.write(buffer) byteBuffer.clear() //移动到下一帧 extractor.advance() }while (readCount &gt; 0) byteBuffer.clear() } 将音频/视频合并为MP4 /** * 合并音视频 */ fun muxerMediaStream(path: String){ appendLogs(&quot;任务开始&quot;) val mOutputVideoPath = File(OUTPUT_DIR, &quot;output_mp4_file.mp4&quot;).absolutePath //指定输出目录，指定Format格式 appendLogs(&quot;输出目录：$mOutputVideoPath&quot; ) val mMediaMuxer = MediaMuxer( mOutputVideoPath, MediaMuxer.OutputFormat.MUXER_OUTPUT_MPEG_4 ) //获取两个轨道，并且添加到mMediaMuxer val extractor = MediaExtractor() //设置来源 extractor.setDataSource(path) //记录音频/视屏轨道的index var videoTrackIndex = -1 var audioTrackIndex = -1 //获取媒体文件的track数量 val numTracks = extractor.trackCount for (index in 0 until numTracks) { val format = extractor.getTrackFormat(index) val mimeType = format.getString(MediaFormat.KEY_MIME) //标记视频轨道 if (mimeType.startsWith(&quot;video/&quot;)) { videoTrackIndex = index appendLogs(&quot;videoTrackIndex ：$videoTrackIndex&quot; ) } //标记音频轨道 if (mimeType.startsWith(&quot;audio/&quot;)) { audioTrackIndex = index appendLogs(&quot;audioTrackIndex ：$audioTrackIndex&quot; ) } } //添加Track mMediaMuxer.addTrack(extractor.getTrackFormat(videoTrackIndex)) mMediaMuxer.addTrack(extractor.getTrackFormat(audioTrackIndex)) //添加完毕开始 mMediaMuxer.start() //读取数据，并且写入MediaMuxer //写入视频文件 readTrackAndMuxer(videoTrackIndex,mMediaMuxer,extractor) //写入音频文件 readTrackAndMuxer(audioTrackIndex,mMediaMuxer,extractor) //释放MediaExtractor extractor.release() //释放MediaMuxer mMediaMuxer.stop(); mMediaMuxer.release(); } /** * 读取文件，并且写入mMediaMuxer. */ private fun readTrackAndMuxer(trackIndex: Int,mMediaMuxer: MediaMuxer, extractor: MediaExtractor) { appendLogs(&quot;readTrackAndMuxer 开始写入&quot; ) //读取数据 extractor.selectTrack(trackIndex) val byteBuffer = ByteBuffer.allocate(1024 * 500) val info: MediaCodec.BufferInfo = MediaCodec.BufferInfo() info.presentationTimeUs = 0 var readCount = 0 do { //读取数据 readCount = extractor.readSampleData(byteBuffer,0) if (readCount &lt; 0){ break } //写入文件 info.offset = 0 info.size = readCount info.flags = MediaCodec.BUFFER_FLAG_KEY_FRAME info.presentationTimeUs = extractor.sampleTime mMediaMuxer.writeSampleData(trackIndex,byteBuffer,info) byteBuffer.clear() //移动到下一帧 extractor.advance() }while (readCount &gt; 0) appendLogs(&quot;readTrackAndMuxer 结束写入&quot; ) } 代码的逻辑已经很清晰。 END.","categories":[{"name":"Media","slug":"Media","permalink":"https://www.wangzhumo.com/categories/Media/"}],"tags":[{"name":"Android","slug":"Android","permalink":"https://www.wangzhumo.com/tags/Android/"},{"name":"Media","slug":"Media","permalink":"https://www.wangzhumo.com/tags/Media/"}]},{"title":"使用Textureview预览相机","slug":"camera-with-textureview","date":"2019-11-19T08:03:41.000Z","updated":"2019-11-26T11:52:47.085Z","comments":true,"path":"2019/11/19/camera-with-textureview/","link":"","permalink":"https://www.wangzhumo.com/2019/11/19/camera-with-textureview/","excerpt":"流程分析实现思路使用TextureView显示相机的预览，渲染使用opengl实现，仿照GLSurfaceView的方式来预览这个相机。","text":"流程分析实现思路使用TextureView显示相机的预览，渲染使用opengl实现，仿照GLSurfaceView的方式来预览这个相机。 相机 —-生产—&gt; SurfaceTexture (OpenGL + GLThread 处理) —&gt; TextureView(SurfaceTextView)关联的GL环境 onSurfaceTextureAvailable(surface)—显示–&gt; TextureView(SurfaceTextView)关联的GL环境 大概流程 Activity 提供一个 TextureView 初始化相机硬件（权限/Camera1/2），准备开始预览 添加TextureView setSurfaceTextureListener setSurfaceTextureListener 加载loadOESTexture 创建Renderer Thread initEGLContext 使用TextureView中的surfaceTexture 创建一个TextureEGLRenderer用于预览 完成GL环境的建立 创建一个SurfaceTexture(mOESTextureId) ,用于相机的预览 开启预览 setPreviewTexture(surfaceTexture) -&gt; 创建的surfaceTexture -&gt; setOnFrameAvailableListener TextureView几个常用的SurfaceView，SurfaceTexture ,GlSurfaceView中 TextureView是唯一一个可以当做View使用，支持动画效果，在5.0前在主线程渲染，在5.0后在单独线程渲染 但是它的性能没有其他几个好，耗费的内存也比较大，常用在List中，而且必须要在硬件 TextureView SurfaceView 绘制 1-3帧延迟 低 内存 高 低 动画和截图 支持 不支持 耗电 高 低 以上是网络上的资料图表 编码分析CameraActivity用于承载这个Demo,其中根布局只有一个TextureView CameraOpenHelper相机的帮助类，用于打开Camera以及处理Camera与TextureView的关联 ITextureRendererTextureEGLRendererfun onSurfaceCreated() //加载GL的一些东西，opengl的程序，着色器 fun onSurfaceChanged(width: Int, height: Int) fun onDrawFrame(surfaceTexture: SurfaceTexture?) //渲染 TextureEGLHelperclass TextureEGLHelper : SurfaceTexture.OnFrameAvailableListener 提供 SurfaceTexture 给Camera initEGLContext HandlerThread 初始化/渲染 源码CameraActivitycom.wangzhumo.app.module.media.opengl.camera.CameraActivity @SuppressLint(&quot;RestrictedApi&quot;) override fun initViews(savedInstanceState: Bundle?) { super.initViews(savedInstanceState) val cameraOpenHelper = CameraOpenHelper(this) cameraOpenHelper.bindCameraUseCases(viewFinder) } 这个CameraActivity很简单，只有xml里也只有一个TextureView CameraOpenHelpercom.wangzhumo.app.module.media.opengl.camera.CameraOpenHelper class CameraOpenHelper constructor(private val lifeOwner: FragmentActivity) : TextureView.SurfaceTextureListener{ private var textureEGLHelper: TextureEGLHelper? = null private var viewFinder : TextureView? = null private var mCamera: ICamera? = null private var mCameraId = 0 fun bindCameraUseCases(textureView: TextureView) { this.viewFinder = textureView this.textureEGLHelper = TextureEGLHelper() textureView.surfaceTextureListener = this } override fun onSurfaceTextureSizeChanged(surface: SurfaceTexture?, width: Int, height: Int) { textureEGLHelper?.onSurfaceChanged(width, height) } override fun onSurfaceTextureUpdated(surface: SurfaceTexture?) {} override fun onSurfaceTextureDestroyed(surface: SurfaceTexture?): Boolean { onDestroy() return false } override fun onSurfaceTextureAvailable(surface: SurfaceTexture?, width: Int, height: Int) { //当外部的TextureView可用之后，开启摄像头，打开渲染线程 val textureId = TextureUtils.loadOESTexture() textureEGLHelper?.initEGL(viewFinder,textureId) //通过传递的textureId,构建一个SurfaceTexture，用于相机的预览 val surfaceTexture = textureEGLHelper?.loadOESTexture() //不使用自己的SurfaceView，另外构建一个SurfaceView来接收Camera的预览数据 //前置摄像头 mCameraId = Camera.CameraInfo.CAMERA_FACING_FRONT mCamera = CameraV1(lifeOwner) mCamera?.apply { openCamera(mCameraId) setPreviewTexture(surfaceTexture) enablePreview(true) } } ITextureRendererTextureEGLRenderer/** * If you have any questions, you can contact by email {wangzhumoo@gmail.com} * * @author 王诛魔 2019-11-22 21:31 * * 渲染实现 */ class TextureEGLRenderer constructor(val textureId: Int) : ITextureRenderer { /** * 程序 */ private var mShaderProgram = -1 private var mOESTextureId = -1 private var mVertexBuffer: FloatBuffer /** * 变换矩阵 */ private val transformMatrix = FloatArray(16) private var aPositionLocation = -1 private var aTextureCoordLocation = -1 private var uTextureMatrixLocation = -1 private var uTextureSamplerLocation = -1 init { mVertexBuffer = TextureUtils.loadVertexBuffer(VERTEX_DATA) mOESTextureId = textureId } override fun onSurfaceCreated() { //加载GL的一些东西 val vertexShader = ShaderUtils.compileVertexShader(RawUtils.readResource(R.raw.vertex_texture_shader)) val fragmentShader = ShaderUtils.compileFragmentShader(RawUtils.readResource(R.raw.fragment_texture_shader)) Log.d(TAG,&quot;com.wangzhumo.app.module.media.opengl.camera.TextureEGLRenderer&quot;,&quot;onSurfaceCreated&quot;,56,&quot;vertexShader = $vertexShader , fragmentShader = $fragmentShader&quot;) mShaderProgram = ShaderUtils.linkProgram(vertexShader, fragmentShader) aPositionLocation = GLES30.glGetAttribLocation(mShaderProgram, POSITION_ATTRIBUTE) aTextureCoordLocation = GLES30.glGetAttribLocation(mShaderProgram, TEXTURE_COORD_ATTRIBUTE) uTextureMatrixLocation = GLES30.glGetUniformLocation(mShaderProgram, TEXTURE_MATRIX_UNIFORM) uTextureSamplerLocation = GLES30.glGetUniformLocation(mShaderProgram, TEXTURE_SAMPLER_UNIFORM) Log.d(TAG,&quot;com.wangzhumo.app.module.media.opengl.camera.TextureEGLRenderer&quot;,&quot;onSurfaceCreated&quot;,63, &quot;mShaderProgram = $mShaderProgram , aPositionLocation = $aPositionLocation , aTextureCoordLocation = $aTextureCoordLocation , uTextureMatrixLocation = $uTextureSamplerLocation , uTextureSamplerLocation = $uTextureSamplerLocation&quot;) } override fun onSurfaceChanged(width: Int, height: Int) { GLES30.glViewport(0, 0, width, height) } override fun onDrawFrame(surfaceTexture: SurfaceTexture?) { GLES20.glClear(GLES20.GL_COLOR_BUFFER_BIT) GLES30.glUseProgram(mShaderProgram) //开始使用程序 surfaceTexture?.updateTexImage() surfaceTexture?.getTransformMatrix(transformMatrix) GLES30.glActiveTexture(GLES30.GL_TEXTURE0) GLES30.glBindTexture(GLES11Ext.GL_TEXTURE_EXTERNAL_OES, mOESTextureId) GLES30.glUniform1i(uTextureSamplerLocation, 0) GLES30.glUniformMatrix4fv( uTextureMatrixLocation, 1, false, transformMatrix, 0 ) mVertexBuffer.position(0) GLES30.glEnableVertexAttribArray(aPositionLocation) GLES30.glVertexAttribPointer( aPositionLocation, 2, GLES30.GL_FLOAT, false, STRIDE, mVertexBuffer ) mVertexBuffer.position(2) GLES30.glEnableVertexAttribArray(aTextureCoordLocation) GLES30.glVertexAttribPointer( aTextureCoordLocation, 2, GLES30.GL_FLOAT, false, STRIDE, mVertexBuffer ) GLES30.glDrawArrays(GLES30.GL_TRIANGLES, 0, 6) } companion object { private const val TAG = &quot;TextureEGLRenderer&quot; private const val POSITION_ATTRIBUTE = &quot;aPosition&quot; private const val TEXTURE_COORD_ATTRIBUTE = &quot;aTextureCoord&quot; private const val TEXTURE_MATRIX_UNIFORM = &quot;uTextureMatrix&quot; private const val TEXTURE_SAMPLER_UNIFORM = &quot;uTextureSampler&quot; private const val POSITION_SIZE = 2 private const val TEXTURE_SIZE = 2 private const val STRIDE = (POSITION_SIZE + TEXTURE_SIZE) * 4 /** * 顶点数组 */ private val VERTEX_DATA = floatArrayOf( 1.0f, 1.0f, 1.0f, 1.0f, -1.0f, 1.0f, 0.0f, 1.0f, -1.0f, -1f, 0.0f, 0.0f, 1.0f, 1.0f, 1.0f, 1.0f, -1.0f, -1.0f, 0f, 0.0f, 1.0f, -1.0f, 1.0f, 0.0f ) } } 这个TextureEGLRenderer中的GL渲染，大部分内容不是很熟，所以不做太多的解读，当姑且先当做固定的用法，先开始使用 TextureEGLHelpercom.wangzhumo.app.module.media.opengl.camera.TextureEGLHelper class TextureEGLHelper : SurfaceTexture.OnFrameAvailableListener { /** * 渲染/初始化 线程 */ private var mHandlerThread: HandlerThread? = null /** * 渲染器 */ private var mRenderer: ITextureRenderer? = null /** * mHandlerThread 内部的Handler */ private var mHandler: Handler? = null /** * 最终显示的TextureView */ private var mTextureView: TextureView? = null /** * 纹理ID */ private var mOESTextureId = 0 /** * 显示设备 */ private var mEGLDisplay = EGL14.EGL_NO_DISPLAY /** * EGL上下文 */ private var mEGLContext = EGL14.EGL_NO_CONTEXT /** * EGL绘图surface */ private var mEglSurface: EGLSurface? = null /** * 自定义的SurfaceTexture - 实际上接收Camera上的数据 */ private var mOESSurfaceTexture: SurfaceTexture? = null /** * @param textureView 外部的TextureView * @param textureId 提供的TextureID */ fun initEGL(textureView: TextureView?, textureId: Int) { mTextureView = textureView mOESTextureId = textureId Log.d(TAG,&quot;com.wangzhumo.app.module.media.opengl.camera.TextureEGLHelper&quot;,&quot;initEGL&quot;,84,&quot;initEGL HandlerThread 创建&quot;) mHandlerThread = HandlerThread(&quot;Renderer Thread&quot;) Log.d(TAG,&quot;com.wangzhumo.app.module.media.opengl.camera.TextureEGLHelper&quot;,&quot;initEGL&quot;,85,&quot;initEGL HandlerThread 开始运行&quot;) mHandlerThread?.start() //此处的Handler，用于处理各种发送过来的命令 mHandler = object : Handler(mHandlerThread?.looper) { override fun handleMessage(msg: Message) { when (msg.what) { MSG_INIT -&gt; { //initEGLContext initEGLContext() //初始化EGL环境 initEGLRenderer() //初始化渲染器 //初始化 Renderer. } MSG_RENDER -&gt; { //开始渲染，onFrameAvailable中发送，由mHandlerThread负责渲染的调用。 drawFrame() } MSG_DESTROY -&gt; { //mHandlerThread 关闭 //停止mHandler //销毁资源 } else -&gt; return } } } Log.d(TAG,&quot;com.wangzhumo.app.module.media.opengl.camera.TextureEGLHelper&quot;,&quot;initEGL&quot;,113,&quot;initEGL HandlerThread 开始运行 -- sendEmptyMessage(MSG_INIT)&quot;) mHandler?.sendEmptyMessage(MSG_INIT) } /** * 初始化EGLContext */ private fun initEGLContext() { Log.d(TAG,&quot;com.wangzhumo.app.module.media.opengl.camera.TextureEGLHelper&quot;,&quot;initEGLContext&quot;,122,&quot;initEGL initEGLContext start&quot;) mEGLDisplay = EGL14.eglGetDisplay(EGL14.EGL_DEFAULT_DISPLAY) //需判断是否成功获取EGLDisplay if (mEGLDisplay == EGL14.EGL_NO_DISPLAY) { throw RuntimeException(&quot;Unable to get EGL14 display&quot;) } val versions = IntArray(2) versions[0] = 3 if (!EGL14.eglInitialize(mEGLDisplay, versions, 0, versions, 1)) { throw RuntimeException(&quot;eglInitialize failed! &quot; + EGL14.eglGetError()) } //egl的一些配置 val eglConfigAttribute = intArrayOf( EGL14.EGL_BUFFER_SIZE, 32, EGL14.EGL_RED_SIZE, 8, EGL14.EGL_GREEN_SIZE, 8, EGL14.EGL_BLUE_SIZE, 8, EGL14.EGL_ALPHA_SIZE, 8, EGL14.EGL_RENDERABLE_TYPE, 4, EGL14.EGL_SURFACE_TYPE, EGL14.EGL_WINDOW_BIT, EGL14.EGL_NONE ) val numConfig = IntArray(1) val eglConfig = arrayOfNulls&lt;EGLConfig&gt;(1) //EGL配置 val eglChooseFlag = EGL14.eglChooseConfig( mEGLDisplay, eglConfigAttribute, 0, eglConfig, 0, eglConfig.size, numConfig, 0 ) if (!eglChooseFlag) { throw RuntimeException(&quot;eglChooseConfig failed! &quot; + EGL14.eglGetError()) } //创建EGL显示的窗口 val surfaceAttribute = intArrayOf( EGL14.EGL_NONE ) val surfaceTexture = mTextureView?.surfaceTexture if (surfaceTexture == null) { throw RuntimeException(&quot;surfaceTexture is null&quot;) } mEglSurface = EGL14.eglCreateWindowSurface( mEGLDisplay, eglConfig[0], mTextureView?.surfaceTexture, surfaceAttribute, 0 ) //创建上下文 val ctxAttribute = intArrayOf( EGL14.EGL_CONTEXT_CLIENT_VERSION, 3, EGL14.EGL_NONE ) mEGLContext = EGL14.eglCreateContext( mEGLDisplay, eglConfig[0], EGL14.EGL_NO_CONTEXT, ctxAttribute, 0 ) //校验1 if (mEGLDisplay === EGL14.EGL_NO_DISPLAY || mEGLContext === EGL14.EGL_NO_CONTEXT) { throw RuntimeException(&quot;eglCreateContext fail failed! &quot; + EGL14.eglGetError()) } //校验2 val makeFlag = EGL14.eglMakeCurrent(mEGLDisplay, mEglSurface, mEglSurface, mEGLContext) if (!makeFlag) { throw RuntimeException(&quot;eglMakeCurrent failed! &quot; + EGL14.eglGetError()) } Log.d(TAG,&quot;com.wangzhumo.app.module.media.opengl.camera.TextureEGLHelper&quot;,&quot;initEGLContext&quot;,191,&quot;initEGL initEGLContext end&quot;) } /** * 初始化Renderer */ private fun initEGLRenderer() { Log.d(TAG,&quot;com.wangzhumo.app.module.media.opengl.camera.TextureEGLHelper&quot;,&quot;initEGLRenderer&quot;,220,&quot;initEGLRenderer 创建 TextureEGLRenderer&quot;) mRenderer = TextureEGLRenderer(mOESTextureId) mRenderer?.onSurfaceCreated() } /** * 创建可以放在外部，但是为了加入监听方便，就放在这里初始化 */ fun loadOESTexture(): SurfaceTexture? { Log.d(TAG,&quot;com.wangzhumo.app.module.media.opengl.camera.TextureEGLHelper&quot;,&quot;loadOESTexture&quot;,198,&quot;loadOESTexture 提供SurfaceTexture&quot;) mOESSurfaceTexture = SurfaceTexture(mOESTextureId) mOESSurfaceTexture?.setOnFrameAvailableListener(this) Log.d(TAG,&quot;com.wangzhumo.app.module.media.opengl.camera.TextureEGLHelper&quot;,&quot;loadOESTexture&quot;,200,&quot;loadOESTexture 添加setOnFrameAvailableListener&quot;) return mOESSurfaceTexture } /* * setOnFrameAvailableListener 给 loadOESTexture 提供的SurfaceTexture使用 */ override fun onFrameAvailable(surfaceTexture: SurfaceTexture?) { //frame可用之后，开始渲染 if (mHandler != null) { //不能直接调用，需要在mHandlerThread中去渲染 mHandler?.sendEmptyMessage(MSG_RENDER) } } /** * 实际上渲染画面的方法 */ private fun drawFrame() { if (mRenderer != null) { EGL14.eglMakeCurrent(mEGLDisplay, mEglSurface, mEglSurface, mEGLContext) mRenderer?.onDrawFrame(mOESSurfaceTexture) EGL14.eglSwapBuffers(mEGLDisplay, mEglSurface) } } /** * onSurfaceChanged 回调 */ fun onSurfaceChanged(width: Int, height: Int) { mRenderer?.onSurfaceChanged(width, height) } /** * 释放资源 */ fun onDestroy() { mHandler?.removeCallbacksAndMessages(null) mHandlerThread?.quitSafely() } companion object { var MSG_INIT = 100 var MSG_RENDER = 200 var MSG_DESTROY = 300 const val TAG = &quot;TextureEGLHelper&quot; } } 工具类TextureUtils/** * If you have any questions, you can contact by email {wangzhumoo@gmail.com} * * @author 王诛魔 2019-08-23$ 23:31$ */ object TextureUtils { /** * 加载OES Texture * * @return */ @JvmStatic fun loadOESTexture(): Int { val textureIds = IntArray(1) //textureIds 中存放一个textures中的可用值 GLES20.glGenTextures(1, textureIds, 0) //当调用glBindTexture //如果是第一次调用这个函数textureIds[0] ，会创建一个新的纹理对象 //如果textureIds[0]已经创建过了，把这个纹理置为 活动 //如果texture为0，就停止使用这个纹理对象，并返回无名称的默认纹理 GLES20.glBindTexture(GLES11Ext.GL_TEXTURE_EXTERNAL_OES, textureIds[0]) //设置参数 GLES20.glTexParameterf( GLES11Ext.GL_TEXTURE_EXTERNAL_OES, GLES20.GL_TEXTURE_MIN_FILTER, GLES20.GL_NEAREST.toFloat() ) GLES20.glTexParameterf( GLES11Ext.GL_TEXTURE_EXTERNAL_OES, GLES20.GL_TEXTURE_MAG_FILTER, GLES20.GL_LINEAR.toFloat() ) GLES20.glTexParameterf( GLES11Ext.GL_TEXTURE_EXTERNAL_OES, GLES20.GL_TEXTURE_WRAP_S, GLES20.GL_CLAMP_TO_EDGE.toFloat() ) GLES20.glTexParameterf( GLES11Ext.GL_TEXTURE_EXTERNAL_OES, GLES20.GL_TEXTURE_WRAP_T, GLES20.GL_CLAMP_TO_EDGE.toFloat() ) //取消绑定纹理，并且返回一个默认的纹理 GLES20.glBindTexture(GLES11Ext.GL_TEXTURE_EXTERNAL_OES, 0) return textureIds[0] } /** * 创建一个顶点Buffer */ fun loadVertexBuffer(vertexData: FloatArray): FloatBuffer { val buffer = ByteBuffer.allocateDirect(vertexData.size * 4) .order(ByteOrder.nativeOrder()) .asFloatBuffer() buffer.put(vertexData, 0, vertexData.size).position(0) return buffer } /** * 创建一个新的SurfaceTexture */ fun loadOESTexture(mOESTextureId: Int): SurfaceTexture { return SurfaceTexture(mOESTextureId) } } ShaderUtils/** * If you have any questions, you can contact by email {wangzhumoo@gmail.com} * * @author 王诛魔 2019-09-28 16:16 */ object ShaderUtils { /** * 编译顶点着色器 * * @param shaderCode * @return */ @JvmStatic fun compileVertexShader(shaderCode: String): Int { return compileShader(GLES30.GL_VERTEX_SHADER, shaderCode) } /** * 编译片段着色器 * * @param shaderCode * @return */ @JvmStatic fun compileFragmentShader(shaderCode: String): Int { return compileShader(GLES30.GL_FRAGMENT_SHADER, shaderCode) } /** * 编译 * * @param type 顶点着色器:GLES30.GL_VERTEX_SHADER * 片段着色器:GLES30.GL_FRAGMENT_SHADER * @param shaderCode * @return */ @JvmStatic private fun compileShader(type: Int, shaderCode: String): Int { //创建一个着色器 val shaderId = GLES30.glCreateShader(type) if (shaderId != 0) { GLES30.glShaderSource(shaderId, shaderCode) GLES30.glCompileShader(shaderId) //检测状态 val compileStatus = IntArray(1) GLES30.glGetShaderiv(shaderId, GLES30.GL_COMPILE_STATUS, compileStatus, 0) if (compileStatus[0] == 0) { val logInfo = GLES30.glGetShaderInfoLog(shaderId) System.err.println(logInfo) //创建失败 GLES30.glDeleteShader(shaderId) return 0 } return shaderId } else { //创建失败 return 0 } } /** * 链接小程序 * * @param vertexShaderId 顶点着色器 * @param fragmentShaderId 片段着色器 * @return */ @JvmStatic fun linkProgram(vertexShaderId: Int, fragmentShaderId: Int): Int { val programId = GLES30.glCreateProgram() if (programId != 0) { //将顶点着色器加入到程序 GLES30.glAttachShader(programId, vertexShaderId) //将片元着色器加入到程序中 GLES30.glAttachShader(programId, fragmentShaderId) //链接着色器程序 GLES30.glLinkProgram(programId) val linkStatus = IntArray(1) GLES30.glGetProgramiv(programId, GLES30.GL_LINK_STATUS, linkStatus, 0) if (linkStatus[0] == 0) { val logInfo = GLES30.glGetProgramInfoLog(programId) System.err.println(logInfo) GLES30.glDeleteProgram(programId) return 0 } return programId } else { //创建失败 return 0 } } /** * 验证程序片段是否有效 * * @param programObjectId * @return */ @JvmStatic fun validProgram(programObjectId: Int): Boolean { GLES30.glValidateProgram(programObjectId) val programStatus = IntArray(1) GLES30.glGetProgramiv(programObjectId, GLES30.GL_VALIDATE_STATUS, programStatus, 0) return programStatus[0] != 0 } } 输出日志CameraActivity onCreated &lt;&lt;&lt; CameraActivity, createTextureView, 69]:创建帮助类 CameraOpenHelper() CameraActivity, createTextureView, 71]:绑定TextureView bindCameraUseCases（textureView） CameraOpenHelper, bindCameraUseCases, 39]:创建EGLHelper TextureEGLHelper（） CameraOpenHelper, bindCameraUseCases, 36]:添加 surfaceTextureListener CameraActivity onResumed &lt;&lt;&lt; CameraOpenHelper, onSurfaceTextureAvailable, 85]:onSurfaceTextureAvailable loadOESTexture = 0 TextureEGLHelper, initEGL, 84]:initEGL HandlerThread 创建 TextureEGLHelper, initEGL, 85]:initEGL HandlerThread 开始运行 TextureEGLHelper, initEGL, 113]:initEGL HandlerThread 开始运行 – sendEmptyMessage(MSG_INIT) TextureEGLHelper, loadOESTexture, 198]:loadOESTexture 提供SurfaceTexture TextureEGLHelper, loadOESTexture, 200]:loadOESTexture 添加setOnFrameAvailableListener TextureEGLHelper, initEGLContext, 122]:initEGL initEGLContext start TextureEGLHelper, initEGLContext, 191]:initEGL initEGLContext end TextureEGLHelper, initEGLRenderer, 220]:initEGLRenderer 创建 TextureEGLRenderer TextureEGLRenderer, init, 49]:mOESTextureId = 0 , mVertexBuffer = 24 TextureEGLRenderer, onSurfaceCreated, 63]:mShaderProgram = 3 , aPositionLocation = 0 , aTextureCoordLocation = 1 , uTextureMatrixLocation = 1 , uTextureSamplerLocation = 1 CameraOpenHelper, onSurfaceTextureAvailable, 95]:onSurfaceTextureAvailable enablePreview 开启摄像头","categories":[{"name":"Media","slug":"Media","permalink":"https://www.wangzhumo.com/categories/Media/"}],"tags":[{"name":"Media","slug":"Media","permalink":"https://www.wangzhumo.com/tags/Media/"}]},{"title":"Ubuntu安装coturn服务","slug":"coturn-install-ubuntu","date":"2019-11-06T03:59:03.000Z","updated":"2019-12-22T11:40:27.806Z","comments":true,"path":"2019/11/06/coturn-install-ubuntu/","link":"","permalink":"https://www.wangzhumo.com/2019/11/06/coturn-install-ubuntu/","excerpt":"coturn projectThis project evolved from rfc5766-turn-server project (https://code.google.com/p/rfc5766-turn-server/). 这是一个穿透服务，为webrtc的链接做服务,按照rfc5766-turn-server实现。","text":"coturn projectThis project evolved from rfc5766-turn-server project (https://code.google.com/p/rfc5766-turn-server/). 这是一个穿透服务，为webrtc的链接做服务,按照rfc5766-turn-server实现。 项目地址：https://github.com/coturn/coturn 安装Wiki: https://github.com/coturn/coturn/wiki/CoturnConfig 依赖库Third-party librarieslibevent$ wget https://github.com/downloads/libevent/libevent/libevent-2.0.21-stable.tar.gz # 需要sodu权限 $ tar xvfz libevent-2.0.21-stable.tar.gz $ cd libevent-2.0.21-stable $ ./configure $ make $ make install 安装完毕 /usr/local/lib coturn install下载地址：https://github.com/coturn/coturn/wiki/Downloads 下载方式一：我选择了最新的版本，4.5.0.8 $ wget https://coturn.net/turnserver/v4.5.0.8/turnserver-4.5.0.8.tar.gz 一直下载失败..所以我在本地下载了，上传到服务器 home/wangzhumo/source 方式二：$ cd /home/wangzhumo/source $ git clone https://github.com/coturn/coturn 编译# 解压 $ tar -xvf turnserver-4.5.0.8.tar $ cd turnserver-4.5.0.8 $ ./configure $ make $ sudo make install # 记录安装位置 install -d /usr/local install -d /usr/local/bin install -d /usr/local/var/db install -d /usr/local/man/man1 install -d /usr/local/etc install -d /usr/local/lib install -d /usr/local/share/examples/turnserver install -d /usr/local/share/doc/turnserver install -d /usr/local/share/turnserver install -d /usr/local/include/turn 1) If your system supports automatic start-up system daemon services, then to enable the turnserver as a system service that is automatically started, you have to: a) Create and edit /etc/turnserver.conf or /usr/local/etc/turnserver.conf . Use /usr/local/etc/turnserver.conf.default as an example. b) For user accounts settings: set up SQLite or PostgreSQL or MySQL or MongoDB or Redis database for user accounts. Use /usr/local/share/turnserver/schema.sql as SQL database schema, or use /usr/local/share/turnserver/schema.userdb.redis as Redis database schema description and/or /usr/local/share/turnserver/schema.stats.redis as Redis status &amp; statistics database schema description. If you are using SQLite, the default database location is in /var/db/turndb or in /usr/local/var/db/turndb or in /var/lib/turn/turndb. c) add whatever is necessary to enable start-up daemon for the /usr/local/bin/turnserver. 2) If you do not want the turnserver to be a system service, then you can start/stop it &quot;manually&quot;, using the &quot;turnserver&quot; executable with appropriate options (see the documentation). 3) To create database schema, use schema in file /usr/local/share/turnserver/schema.sql. 4) For additional information, run: $ man turnserver $ man turnadmin $ man turnutils coturn 配置turnserver.conf$ sudo vim /usr/local/etc/turnserver.conf.default 要修改的地方只有5处： listening-port=3478 external-ip=[服务器的ip] min-port=50001 max-port=65535 user=wangzhumo:webrtcpwd realm=stun.wangzhumo.com $ sudo mv /usr/local/etc/turnserver.conf.default /usr/local/etc/turnserver.conf 防火墙1.打开云服务器的 安全组 ，加入 3478 ，50001—65535 2.本机的防火墙 coturn 开启$ turnserver -o -c /usr/local/etc/turnserver.conf 测试测试地址：https://webrtc.github.io/samples/src/content/peerconnection/trickle-ice/ 1.输入： STUN or TURN URI: turn:stun.wangzhumo.com TURN username: wangzhumo TURN password: webrtcpwd 2.Add Server 3.Gather candidates 测试结果： Time Component Type Foundation Protocol Address Port Priority 0.003 rtp host 2749607730 udp 172.30.21.85 60720 126 | 30 | 255 7.794 rtp srflx 842163049 udp 221.221.255.18 33338 100 | 30 | 255 7.825 rtp relay 1676812102 udp 171.51.157.190 65032 2 | 30 | 255 7.825 Done 7.827 看到relay类型的就说明成功了 END","categories":[{"name":"Media","slug":"Media","permalink":"https://www.wangzhumo.com/categories/Media/"}],"tags":[{"name":"Server","slug":"Server","permalink":"https://www.wangzhumo.com/tags/Server/"},{"name":"Media","slug":"Media","permalink":"https://www.wangzhumo.com/tags/Media/"}]},{"title":"WireShark与tcpdump的入门使用记录","slug":"wireshark-dump-learn","date":"2019-10-23T11:46:35.000Z","updated":"2019-12-22T11:59:28.998Z","comments":true,"path":"2019/10/23/wireshark-dump-learn/","link":"","permalink":"https://www.wangzhumo.com/2019/10/23/wireshark-dump-learn/","excerpt":"在我们开发的过程中,有些时候需要查看网络传输过程的信息 在我平时的开发中,移动端仅仅使用Charles就已经能满足我所有需要了.","text":"在我们开发的过程中,有些时候需要查看网络传输过程的信息 在我平时的开发中,移动端仅仅使用Charles就已经能满足我所有需要了. 在音视频的开发过程中,RTC,RTCP,Offer,Answer中的sdp以及信令服务中的socket 都不能简单的使用Charles,需要更加底层的工具. 这时候就是WireShark大显身手的时候,tcpdump的输出文件也是可以用WireShark来查看的,这里我仅仅简单的记录一些使用方式,等到我慢慢的深入使用以后,再进行更深层的记录. tcpdumptcpdump -i eth0 src port 80 -xx -Xs 0 -w test.cap -i 指定网卡 src 指定包的来源 port 指定端口号 -xx 抓取到的包使用16进制显示 -X 以ASCII码显示 -s 0 抓取的包无限制,也就是抓取所有包 -w 写入到文件中 wireshark逻辑运算 与 : and 或者 &amp;&amp; 或 : or 或者 || 非 : not 或者 ! 判断 等于 : eq 或 == 大于 : gt 或 &gt; 小于 : lt 或 &lt; 小于等于 : le 或者 &lt;= 大于等于 : ge 或者 &gt;= 不等于 : ne 或 != 协议过滤 stun udp tcp arp icmp http smtp ftp dns msnms ssl oicq 按照http过滤 http.request.method == “GET” http.request.method == “POST” http.request.uri == “/img/logo.png” http contains “GET” http contains “HTTP/1.” 按IP过滤 ip.dst == 192.168.1.1 发送到的目的IP ip.src == 192.168.2.13 源IP Ip.addr == 192.168.2.23 所有该IP的通信, 源IP + 目的IP 按Port过滤 tcp.port == 8080 udp.port == 8080 udp.dstport == 8080 udp.srcport == 8080 按长度过滤 udp.length &lt; 20 tcp.length &lt; 30 http.content_length &lt; 100","categories":[{"name":"Tools","slug":"Tools","permalink":"https://www.wangzhumo.com/categories/Tools/"}],"tags":[{"name":"Server","slug":"Server","permalink":"https://www.wangzhumo.com/tags/Server/"},{"name":"Http","slug":"Http","permalink":"https://www.wangzhumo.com/tags/Http/"}]},{"title":"TURN协议简单认识","slug":"turn-protocol-start","date":"2019-10-22T11:42:25.000Z","updated":"2019-12-22T11:44:56.077Z","comments":true,"path":"2019/10/22/turn-protocol-start/","link":"","permalink":"https://www.wangzhumo.com/2019/10/22/turn-protocol-start/","excerpt":"TURN简介Traversal Using Relays around NAT（TURN）：Relay Extensions to Session Traversal Utilities for NAT（STUN）使用中继穿透NAT：STUN的中继扩展","text":"TURN简介Traversal Using Relays around NAT（TURN）：Relay Extensions to Session Traversal Utilities for NAT（STUN）使用中继穿透NAT：STUN的中继扩展 解决STUN不能穿越NAT的情况,通过TURN中转 建立在STUN服务之上,消息格式使用STUN的规范 TURN Client需要TURN服务提供一个公网IP以及Port用于接收/发送数据 TURN中转https://tools.ietf.org/html/rfc5766#page-15 Peer A Server-Reflexive +---------+ Transport Address | | 192.0.2.150:32102 | | | /| | TURN | / ^| Peer A | Client&#39;s Server | / || | Host Transport Transport | // || | Address Address | // |+---------+ 10.1.1.2:49721 192.0.2.15:3478 |+-+ // Peer A | | ||N| / Host Transport | +-+ | ||A|/ Address | | | | v|T| 192.168.100.2:49582 | | | | /+-+ +---------+| | | |+---------+ / +---------+ | || |N| || | // | | | TURN |v | | v| TURN |/ | | | Client |----|A|----------| Server |------------------| Peer B | | | | |^ | |^ ^| | | | |T|| | || || | +---------+ | || +---------+| |+---------+ | || | | | || | | +-+| | | | | | | | | Client&#39;s | Peer B Server-Reflexive Relayed Transport Transport Address Transport Address Address 192.0.2.1:7000 192.0.2.15:50000 192.0.2.210:49191 Figure 1 TURN传输协议 +----------------------------+---------------------+ | TURN client to TURN server | TURN server to peer | +----------------------------+---------------------+ | UDP | UDP | | TCP | UDP | | TLS over TCP | UDP | +----------------------------+---------------------+ TURN, as defined in this specification, always uses UDP between the server and the peer. However, this specification allows the use of any one of UDP, TCP, or Transport Layer Security (TLS) over TCP to carry the TURN messages between the client and the server. TURN的Allocate TURN TURN Peer Peer client server A B |-- Allocate request ---------------&gt;| | | | | | | |&lt;--------------- Allocate failure --| | | | (401 Unauthorized) | | | | | | | |-- Allocate request ---------------&gt;| | | | | | | |&lt;---------- Allocate success resp --| | | | (192.0.2.15:50000) | | | // // // // | | | | |-- Refresh request ----------------&gt;| | | | | | | |&lt;----------- Refresh success resp --| | | | | | | Figure 2 Client发送一个Allocate到TURN服务 -&gt; 权鉴 -&gt; 成功应答(携带分配的IP:port) Refresh request 就是保活 TURN中转 这两种方式是可以同时使用的. Send And Data TURN TURN Peer Peer client server A B | | | | |-- CreatePermission req (Peer A) --&gt;| | | |&lt;-- CreatePermission success resp --| | | | | | | |--- Send ind (Peer A)--------------&gt;| | | | |=== data ===&gt;| | | | | | | |&lt;== data ====| | |&lt;-------------- Data ind (Peer A) --| | | | | | | | | | | |--- Send ind (Peer B)--------------&gt;| | | | | dropped | | | | | | | |&lt;== data ==================| | dropped | | | | | | | Figure 3 Client Send 客户端通过Send(Peer A) 到TURN服务,此时拿到其中的data(原始的udp数据) 将data(原始的udp数据)直接转到Peer A Client Data TRUN中转需要发送到客户端的data,加入TURN头 客户端收到了TURN服务中转的数据 Data ChannelTURN TURN Peer Peer client server A B | | | | |-- ChannelBind req ----------------&gt;| | | | (Peer A to 0x4001) | | | | | | | |&lt;---------- ChannelBind succ resp --| | | | | | | |-- [0x4001] data ------------------&gt;| | | | |=== data ===&gt;| | | | | | | |&lt;== data ====| | |&lt;------------------ [0x4001] data --| | | | | | | |--- Send ind (Peer A)--------------&gt;| | | | |=== data ===&gt;| | | | | | | |&lt;== data ====| | |&lt;------------------ [0x4001] data --| | | | | | | Figure 4 我们使用Send / Data的方式,每次都需要传递一个30字节的数据头,耗费了我们的带宽 The client has already created an allocation and now wishes to bind a channel to Peer A 发送一个绑定Channel的请求(channel id 16进制的数字) 成功绑定 直接发送data -&gt; 中转 -&gt; Peer TURN流程 STUN binding 发绑定请求,进行NAT的打通,服务拿到映射的地址 Caller TURN allocation allocation,让TURN分配一个可用的中继地址 ip:port Caller send offer 呼叫者通过信令,把自己的媒体,网络信息以SDP协议发送给对端 Callee(被呼叫者) TURN allocation 被呼叫者也需要发送allocation,获取中继地址 Callee answer 被呼叫者通过信令,发送自己的信息 Exchange candidate IP address 交换双方的信息candidate,可用的候选者地址 ICE check for P2P connection 先检查效率最高的p2p连接 If P2P unsuccessful , make relay connection 如果P2P不可用,则使用中继服务","categories":[{"name":"WebRTC","slug":"WebRTC","permalink":"https://www.wangzhumo.com/categories/WebRTC/"}],"tags":[{"name":"Media","slug":"Media","permalink":"https://www.wangzhumo.com/tags/Media/"},{"name":"WebRTC","slug":"WebRTC","permalink":"https://www.wangzhumo.com/tags/WebRTC/"}]},{"title":"STUN协议简单认识","slug":"stun-protocol-start","date":"2019-10-22T11:18:25.000Z","updated":"2019-12-22T11:40:45.075Z","comments":true,"path":"2019/10/22/stun-protocol-start/","link":"","permalink":"https://www.wangzhumo.com/2019/10/22/stun-protocol-start/","excerpt":"STUN简介 STUN主要用于NAT的穿越 STUN也是一个c/s架构","text":"STUN简介 STUN主要用于NAT的穿越 STUN也是一个c/s架构 STUN的规范RFC3489/STUNSimple Traversal of UDP Through NAT 通过UDP对NAT进行穿越,但是现在对UDP的支持不好,因此效果不好 RFC5389/STUNSession Traversal Utilities for NAT 定义为一系列的穿越工具,已经和RFC3489完全不一致了. UDP/TCP都使用,达到穿越的目的. STUN协议STUN Header 20个字节的STUN Header RFC3489 RFC5389 Figure 2 0 1 2 3 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+ |0 0| STUN Message Type | Message Length | +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+ | Magic Cookie | +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+ | | | Transaction ID (96 bits) | | | +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+ Figure 2: Format of STUN Message Header 类型(2byte) 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 +--+--+-+-+-+-+-+-+-+-+-+-+-+-+ |M |M |M|M|M|C|M|M|M|C|M|M|M|M| |11|10|9|8|7|1|6|5|4|0|3|2|1|0| +--+--+-+-+-+-+-+-+-+-+-+-+-+-+ 0 0 0 0 0 0 0 0 0 0 0 0 0 1 0x0001 绑定消息 0 0 0 0 0 1 0 0 0 0 0 0 0 1 0x0101 响应消息 0 0 0 0 0 1 0 0 0 1 0 0 0 1 0x0111 错误消息 Figure 3: Format of STUN Message Type Field RFC5389 Figure 3 其中2个字节(16bit) 0-2共2位固定为00,如果复用同一个端口,00头表示这是STUN协议 2-4共2位用于分类 C0/C1 0b00 请求 0b01 指示 0b10 成功的响应 0b11 失败的响应 这里值得注意的是,c0,c1并不是仅仅挨着的,需要把16进制数字转为二进制,然后看对应的位数 图中展示的是响应消息,c0也就是第5位是0 4-16共12位用与定义请求/指示 消息长度(2byte)消息长度2个字节(16bit),注意它不包括消息头的长度 事务ID(16byte)事务ID用来表示某一个操作,请求与相应事务ID相同16个字节 (8bit * 16 = 128bit) 5389中,Transaction ID (96bit) + Magic Cookie(32bit) = 128bit Magic Cookie包含固定值0x2112A442 STUN Body 消息头后有0或多个属性 每个属性进行TLV编码 Type,Length,Value PS:32位对齐,不足的补0 TLV 0 1 2 3 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+ | Type | Length | +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+ | Value (variable) .... +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+ Figure 4: Format of STUN Attributes TYPE表示属性的类型,只有第一次出现的属性会被接收端解析，而其余的将被忽略 Type值在0x0000-0x7FFF之间的属性被指定为强制理解,STUN终端必须要理解此属性 Type值在0x8000-0xFFFF之间的属性为选择性理解,如果STUN终端不识别此属性则将其忽略 0x0001: MAPPED-ADDRESS 0x0002: RESPONSE-ADDRESS 0x0003: CHANGE-REQUEST 0x0004: SOURCE-ADDRESS 0x0005: CHANGED-ADDRESS 0x0006: USERNAME 0x0007: PASSWORD 0x0008: MESSAGE-INTEGRITY 0x0009: ERROR-CODE 0x000a: UNKNOWN-ATTRIBUTES 0x000b: REFLECTED-FROM MAPPED-ADDRESS：MAPPED-ADDRESS属性表示映射过的IP地址和端口。它包括8位的地址族，16位的端口号及长度固定的IP地址。 RESPONSE-ADDRESS：RESPONSE-ADDRESS属性表示响应的目的地址 CHASNGE-REQUEST：客户使用32位的CHANGE-REQUEST属性来请求服务器使用不同的地址或端口号来发送响应。 SOURCE-ADDRESS：SOURCE-ADDRESS属性出现在捆绑响应中，它表示服务器发送响应的源IP地址和端口。 CHANGED-ADDRESS：如果捆绑请求的CHANGE-REQUEST属性中的“改变IP”和“改变端口”标志设置了，则CHANGED-ADDRESS属性表示响应发出的IP地址和端口号。 USERNAME：USERNAME属性用于消息的完整性检查，用于消息完整性检查中标识共享私密。USERNAME通常出现在共享私密响应中，与PASSWORD一起。当使用消息完整性检查时，可有选择地出现在捆绑请求中。 PASSWORD：PASSWORD属性用在共享私密响应中，与USERNAME一起。PASSWORD的值是变长的，用作共享私密，它的长度必须是4字节的倍数，以保证属性与边界对齐。 MESSAGE-INTEGRITY：MESSAGE-INTEGRITY属性包含STUN消息的HMAC-SHA1，它可以出现在捆绑请求或捆绑响应中；MESSAGE-INTEGRITY属性必须是任何STUN消息的最后一个属性。它的内容决定了HMAC输入的Key值。 ERROR-CODE：ERROR-CODE属性出现在捆绑错误响应或共享私密错误响应中。它的响应号数值范围从100到699。 UNKNOWN-ATTRIBUTES：UNKNOWN-ATTRIBUTES属性只存在于其ERROR-CODE属性中的响应号为420的捆绑错误响应或共享私密错误响应中。 REFLECTED-FROM：REFLECTED-FROM属性只存在于其对应的捆绑请求包含RESPONSE-ADDRESS属性的捆绑响应中。属性包含请求发出的源IP地址，它的目的是提供跟踪能力，这样STUN就不能被用作DOS攻击的反射器。 Attributes的使用位置 Binding Shared Shared Shared Binding Binding Error Secret Secret Secret Att. Req. Resp. Resp. Req. Resp. Error Resp. _____________________________________________________________________ MAPPED-ADDRESS N/A M N/A N/A N/A N/A RESPONSE-ADDRESS O N/A N/A N/A N/A N/A CHANGE-REQUEST O N/A N/A N/A N/A N/A SOURCE-ADDRESS N/A M N/A N/A N/A N/A CHANGED-ADDRESS N/A M N/A N/A N/A N/A USERNAME O N/A N/A N/A M N/A PASSWORD N/A N/A N/A N/A M N/A MESSAGE-INTEGRITY O O N/A N/A N/A N/A ERROR-CODE N/A N/A M N/A N/A M UNKNOWN-ATTRIBUTES N/A N/A C N/A N/A C REFLECTED-FROM N/A C N/A N/A N/A N/A MAPPED-ADDRESSNAT客户端的反射地址,Family为IP类型，即IPV4(0x01)或IPV6(0x02)，Port为端口，Address为32位或128位的IP地址。注意高8位必须全部置零， 0 1 2 3 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+ |0 0 0 0 0 0 0 0| Family | Port | +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+ | | | Address (32 bits or 128 bits) | | | +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+ Figure 5: Format of MAPPED-ADDRESS Attribute","categories":[{"name":"WebRTC","slug":"WebRTC","permalink":"https://www.wangzhumo.com/categories/WebRTC/"}],"tags":[{"name":"Media","slug":"Media","permalink":"https://www.wangzhumo.com/tags/Media/"},{"name":"WebRTC","slug":"WebRTC","permalink":"https://www.wangzhumo.com/tags/WebRTC/"}]},{"title":"JNI 认识JNI的基本概念","slug":"jni-basic-conception","date":"2018-10-28T12:32:20.000Z","updated":"2019-11-26T11:53:47.436Z","comments":true,"path":"2018/10/28/jni-basic-conception/","link":"","permalink":"https://www.wangzhumo.com/2018/10/28/jni-basic-conception/","excerpt":"","text":"JNIEnv在Android的世界中,我们编写完成的源代码都被编译成class文件，而Android又为了避免一些问题，提供了Dalvik VM，Dalvik虚拟机负责把dex文件载入。 那么 .so 文件怎么运行那？ 肯定也是要在Dalvik VM中的,要不怎么互相调用那？总不能靠意念把","categories":[{"name":"JNI","slug":"JNI","permalink":"https://www.wangzhumo.com/categories/JNI/"}],"tags":[{"name":"JNI","slug":"JNI","permalink":"https://www.wangzhumo.com/tags/JNI/"}]},{"title":"JNI-从Android Studio默认工程认识JNI","slug":"taste-jni-default-project","date":"2018-10-28T12:12:17.000Z","updated":"2019-11-07T13:22:53.793Z","comments":true,"path":"2018/10/28/taste-jni-default-project/","link":"","permalink":"https://www.wangzhumo.com/2018/10/28/taste-jni-default-project/","excerpt":"前言对于JNI,Google为我们提供了一个入门文档 https://developer.android.com/ndk/guides/ 我们为什么要使用JNI那？Google已经很明确的为我们指明了： 在平台之间移植其应用。 重复使用现有库，或者提供其自己的库供重复使用。 在某些情况下提高性能，特别是像游戏这种计算密集型应用。","text":"前言对于JNI,Google为我们提供了一个入门文档 https://developer.android.com/ndk/guides/ 我们为什么要使用JNI那？Google已经很明确的为我们指明了： 在平台之间移植其应用。 重复使用现有库，或者提供其自己的库供重复使用。 在某些情况下提高性能，特别是像游戏这种计算密集型应用。 本来是打算学习NDK的老一套的，不过最近学习的课程刚好讲到这个部分，使用CMake的方式的，所以我就直接学习最新的JNI使用方式了。 工程结构. ├── CMakeLists.txt ├── build.gradle └── src ├── main ├── AndroidManifest.xml ├── cpp │ └── native-lib.cpp ├── java 当我们创建好一个支持C++的Android项目后，会得到这样的一个项目结构（不重要的省略掉了） CMakeLists.txt 是CMake的配置文件 build.gradle Android的构建工具 Src 是Java &amp; C 的源码文件目录 cpp 是C源码 java 是Java的源码 CMakeLists.txt# Sets the minimum version of CMake required to build the native library. cmake_minimum_required(VERSION 3.4.1) # 根据C文件生成库文件 # 可以添加其他的非系统库 add_library( # Sets the name of the library. native-lib # Sets the library as a shared(动态库) library. SHARED # Provides a relative path to your source(源文件) file(s). src/main/cpp/native-lib.cpp) # 添加你需要使用的系统库 find_library( # Sets the name of the path variable. log-lib # Specifies(指定一个名字) the name of the NDK library that # you want CMake to locate. log) # 将库链接起来 # 下面写你需要链接的库 target_link_libraries( # Specifies the target library. native-lib # Links the target library to the log library # included in the NDK. ${log-lib}) 当你编译成功后，可以在app/build/intermediates/cmake/的目录下看到你编译成功生成的.so文件 Android部分public class MainActivity extends AppCompatActivity { // Used to load the &#39;native-lib&#39; library on application startup. // 把库读取到java中来 libnative-lib.so ,注意要去掉lib这个前缀 static { System.loadLibrary(&quot;native-lib&quot;); } @Override protected void onCreate(Bundle savedInstanceState) { super.onCreate(savedInstanceState); setContentView(R.layout.activity_main); // Example of a call to a native method TextView tv = (TextView) findViewById(R.id.sample_text); // 可以看到这里直接调用了 ·native· 方法 tv.setText(stringFromJNI()); } /** * A native method that is implemented by the &#39;native-lib&#39; native library, * which is packaged with this application. */ public native String stringFromJNI(); } native部分#include &lt;jni.h&gt; #include &lt;string&gt; extern &quot;C&quot; JNIEXPORT jstring JNICALL Java_com_wangzhumo_jni_MainActivity_stringFromJNI( //注意这个,是制定的格式 // javah可以生成 or 手写 JNIEnv *env, jobject /* this */) { std::string hello = &quot;Hello from C++&quot;; return env-&gt;NewStringUTF(hello.c_str()); }","categories":[{"name":"JNI","slug":"JNI","permalink":"https://www.wangzhumo.com/categories/JNI/"}],"tags":[{"name":"JNI","slug":"JNI","permalink":"https://www.wangzhumo.com/tags/JNI/"}]},{"title":"认识时域与频域","slug":"time-and-frequency-domain","date":"2018-09-21T11:11:18.000Z","updated":"2019-12-22T12:06:02.778Z","comments":true,"path":"2018/09/21/time-and-frequency-domain/","link":"","permalink":"https://www.wangzhumo.com/2018/09/21/time-and-frequency-domain/","excerpt":"","text":"前言我也没想到我有一天会捡起这些东西，我一个数学弱鸡压力山大。 起因是最近在学习音视频开发，我发现一涉及到理论知识这块，总会有几个 时域，频域，傅里叶变化这样的名词出现，我能怎么办，学呗 链接： 信号频域和时域的关系？ https://www.zhihu.com/question/21040374 想学习一个东西，首先要搞明白是什么？然后才能继续去认识它。 而我始终认为，学习也是由浅入深的，由点及面的，不可能一上来就认识到了它的核心理论。 简单的认识 @航空航天迷 https://www.zhihu.com/people/jin-it/activities 这位大兄弟的图是我的启蒙。 这张图就是一个时域图，可以看到这个正弦波，x轴上是时间的变化，y轴就是振幅了 频率 ：6Hz 振幅 ：5V 这里就是图1中正弦波的频域图 我们可以看到x轴是频率了，y轴就是振幅了 其中绿色的线，其x轴的交点是指这个正弦波的频率是6,它的高度就是这个正弦波的波峰了5V 进一步认识来自： @一二 https://www.zhihu.com/people/yier-64/activities https://zh.wikipedia.org/wiki/%E5%82%85%E9%87%8C%E5%8F%B6%E5%8F%98%E6%8D%A2# 傅里叶变换将函数的时域（红色）与频域（蓝色）相关联 刚开始的时候我没看前面 @航空航天迷的答案，直接在CSDN上查的，然后就我懵逼了。 https://blog.csdn.net/jiujiaobusiniao/article/details/53321491 盯着这几张图看了很久，很久。。。 开始理解 @Heinrich https://www.zhihu.com/people/Erdnussoelbearbeiter/activities 傅里叶分析之掐死教程 https://zhuanlan.zhihu.com/p/19763358?refer=wille 真的是给大佬递烟。 大佬，火 下一步我们就看看傅里叶变换","categories":[{"name":"Other","slug":"Other","permalink":"https://www.wangzhumo.com/categories/Other/"}],"tags":[{"name":"frequency","slug":"frequency","permalink":"https://www.wangzhumo.com/tags/frequency/"}]},{"title":"音视频-FFmpeg的编译与安装","slug":"ffmpeg-build-install","date":"2018-09-20T02:31:07.000Z","updated":"2019-11-07T13:25:14.576Z","comments":true,"path":"2018/09/20/ffmpeg-build-install/","link":"","permalink":"https://www.wangzhumo.com/2018/09/20/ffmpeg-build-install/","excerpt":"前言正如FFmpeg的简介所说 FFmpeg is a collection of libraries and tools to process multimedia content such as audio, video, subtitles and related metadata. FFmpeg在音视频领域算得上是集大成者，功能丰富，并且可以自行替换添加编码标准等 可以做到录制，播放，解码，转码，滤镜等等，所以它被很多公司采用。","text":"前言正如FFmpeg的简介所说 FFmpeg is a collection of libraries and tools to process multimedia content such as audio, video, subtitles and related metadata. FFmpeg在音视频领域算得上是集大成者，功能丰富，并且可以自行替换添加编码标准等 可以做到录制，播放，解码，转码，滤镜等等，所以它被很多公司采用。 libavcodec 编解码. libavformat 音视频的解封装 libavutil 工具函数 libavfilter 音视频滤波器（滤镜） libavdevice 硬件的音视频采集、加速和显示 libswresample 重采样，采样格式转换和混合 libswscale 原始视频的缩放，色彩映射转换，图像颜色空间或格式转换 FFmpeg 官方网站 https://ffmpeg.org/ Github https://github.com/FFmpeg/FFmpeg Homebrew# phyooos @ wangzhumo in ~ [20:58:24] C:127 $ brew install ffmpeg --with-sdl2 --with-fdk-aac --with-freetype --with-libass --with-libvorbis --with-libvpx --with-opus --with-x265 #经过一段时间的下载 ==&gt; ./configure --prefix=/usr/local/Cellar/ffmpeg/4.0.2 --enable-shared --enable-pthreads --ena ==&gt; make install 🍺 /usr/local/Cellar/ffmpeg/4.0.2: 251 files, 53.2MB, built in 8 minutes 1 second #好了已经安装成功了 注意--with-sdl2 其实就是ffplay --with-ffplay已经过时被--with-sdl2替代了，所以一定要替换掉，要不然ffplay的安装会失败 如果你不想自己手动编译安装，那么这里已经够了，下文是手动的编译安装记录。 编译下载官方网站： http://ffmpeg.org/download.html 下载解压，目录ffmpeg Git: git clone https://git.ffmpeg.org/ffmpeg.git ffmpeg 准备其他库brew insatll brew install pkg-config brew install speex brew install x264 brew install x265 brew install libsoxr opencore https://sourceforge.net/projects/opencore-amr/ $ ./configure $ make $ make install fdk-acc https://sourceforge.net/projects/opencore-amr/files/fdk-aac/ ##### 编译开始编写build_mac_os.sh#进入ffmpeg目录 cd ~/ffmpeg #创建文件build_mac_os.sh vim ./build_mac_os.sh #文件写入 ./configure --cc=/usr/bin/clang \\ --prefix=/usr/local/ffmpeg \\ --enable-gpl \\ --enable-nonfree \\ --enable-libfdk-aac \\ --enable-libx264 \\ --enable-libmp3lame \\ --enable-libopencore-amrnb \\ --enable-libopencore-amrwb \\ --enable-libx265 \\ --enable-filter=delogo \\ --enable-debug \\ --disable-optimizations \\ --enable-libspeex \\ --enable-videotoolbox \\ --enable-shared \\ --enable-pthreads \\ --enable-version3 \\ --enable-hardcoded-tables \\ --host-cflags= \\ --host-ldflags= make clean #执行文件 sudo ./build_mac_os.sh 安装make &amp;&amp; make install等待上面的命令执行完毕，则 make &amp;&amp; make install 使用简单的录屏查找设备# phyooos @ wangzhumo in ~ [10:51:09] C:1 $ ffmpeg -f avfoundation -list_devices true -i &quot;&quot; # 注意上面命令-i 的参数就是 ”“ 别忘了 #输出： #... [AVFoundation input device @ 0x7fe495402280] AVFoundation video devices: [AVFoundation input device @ 0x7fe495402280] [0] FaceTime HD Camera [AVFoundation input device @ 0x7fe495402280] [1] Capture screen 0 [AVFoundation input device @ 0x7fe495402280] [2] Capture screen 1 [AVFoundation input device @ 0x7fe495402280] AVFoundation audio devices: [AVFoundation input device @ 0x7fe495402280] [0] Built-in Microphone : Input/output error 可以看到AVFoundation video devices的设备有3个 [0] 摄像头 [1] 屏幕1 [2] 屏幕2 录制ffmpeg -f avfoundation -i 1 -r 30 ~/Downloads/out.yuv 使用Ctrl + c终止录制 -f 使用 avfoundation来录制 -i 指定了当前用来录制的设备，这里的1 -r 帧率30 out.yuv 输出文件 简单的播放在录制过程中，有打印录制的参数 Metadata: encoder : Lavf58.12.100 Stream #0:0: Video: rawvideo (UYVY / 0x59565955), uyvy422, 2880x1800, q=2-31, 2488320 kb/s, 30 fps, 30 tbn, 30 tbc 我们使用ffplay进行播放 ffplay -s 2880x1800 -pixel_format uyvy422 ~/Downloads/out.yuv -s 指定分辨率 -pixel_format 编码格式 添加至环境变量","categories":[{"name":"Media","slug":"Media","permalink":"https://www.wangzhumo.com/categories/Media/"}],"tags":[{"name":"Media","slug":"Media","permalink":"https://www.wangzhumo.com/tags/Media/"},{"name":"FFmpeg","slug":"FFmpeg","permalink":"https://www.wangzhumo.com/tags/FFmpeg/"}]},{"title":"音视频-音频的基础理论","slug":"multimedia-learn-audio-base","date":"2018-09-08T05:19:29.000Z","updated":"2019-11-07T13:24:17.979Z","comments":true,"path":"2018/09/08/multimedia-learn-audio-base/","link":"","permalink":"https://www.wangzhumo.com/2018/09/08/multimedia-learn-audio-base/","excerpt":"前言声音学过物理的我们都知道,声音其实就是一种物体的震动 而声音有三要素: 频率,振幅,波形 频率,代表着声音的音阶高低 振幅,标志着音声的响度 波形,既是声色 那么音频信号要做的就是把这些震动转化为数字信号,对模拟信号进行采样,在时间轴上对模拟信号数字化,根据采样的频率,每一秒对模拟信号采样n次.","text":"前言声音学过物理的我们都知道,声音其实就是一种物体的震动 而声音有三要素: 频率,振幅,波形 频率,代表着声音的音阶高低 振幅,标志着音声的响度 波形,既是声色 那么音频信号要做的就是把这些震动转化为数字信号,对模拟信号进行采样,在时间轴上对模拟信号数字化,根据采样的频率,每一秒对模拟信号采样n次. 认识PCMPCM既然要把声音采集为数字信号,那么肯定就有一种编码的格式,而常用的就是PCM(Pulse Code Modulation)脉冲编码调制格式. PCM还有几个关键的概念,它们共同描述了一段PCM的数据. 量化格式(sampleFormat) 也有叫采样位数的,代表着描述数字信号所使用的位数,8bit(已经很少用了)、16bit(一般使用这个)和24bit 采样率(sampleRate) 我们知道人的耳朵能听到的范围是20Hz - 20kHz,我们的采样率如果高于这个值,则必定可以保证声音的还原, 比如我们使用44.1kHz采样率 声道数(channel) 声道数就是指,声音在录制或播放时不同空间位置 单声道 采样数据为8位的短整数(short) 双声道 采样数据为16位的整数(int) 高八位(左声道)和低八位(右声道) 还有一个概念,比特率需要我们注意:它指的是每一秒的比特数,用来衡量单位时间内音频数据的容量大小 举个例子: 一个44.1kHz 双声道 16bit量化格式 44100 * 2 * 16 = 1411.2kbps //把bps装换为MB 1411.2k / 8 / 1024 = 172Kb/s 172 * 60 = 10.08Mb PCM其实一般并不用来编码传输,他经常是作为一个裸数据来使用的,没有经过压缩的. 音频编码常见的比如PCM,ACC,MP3,WAV等等 WAV我们一般不会用这种格式来进行传输,经常是作为本地文件来使用的. 特点:支持广泛,音质好 用途:经常被用来做音乐素材,以及我们开发的中间文件 MP3MP3拥有不错的压缩比,这也是一种兼容非常广泛一种编码格式 特点: 音质在128Kbit/s以上表现的较为不错,压缩比高,兼容性好 用途:高比特率下的音乐. ACC新一代的音频压缩编码技术,使用了有损压缩,可以在128kbit/s的高码率","categories":[{"name":"Media","slug":"Media","permalink":"https://www.wangzhumo.com/categories/Media/"}],"tags":[{"name":"Media","slug":"Media","permalink":"https://www.wangzhumo.com/tags/Media/"},{"name":"Audio","slug":"Audio","permalink":"https://www.wangzhumo.com/tags/Audio/"}]},{"title":"音视频-入门路径","slug":"multimedia-learn","date":"2018-09-01T02:51:29.000Z","updated":"2019-12-22T12:08:19.657Z","comments":true,"path":"2018/09/01/multimedia-learn/","link":"","permalink":"https://www.wangzhumo.com/2018/09/01/multimedia-learn/","excerpt":"","text":"参考资料雷神： https://blog.csdn.net/column/details/ffmpeg-devel.html google提供的文档： https://source.android.com/devices/graphics/ https://source.android.com/devices/audio Jhuster的专栏 http://blog.51cto.com/ticktick/category15.html Android 音视频开发学习思路 https://www.cnblogs.com/renhui/p/7452572.html","categories":[{"name":"Media","slug":"Media","permalink":"https://www.wangzhumo.com/categories/Media/"}],"tags":[{"name":"Media","slug":"Media","permalink":"https://www.wangzhumo.com/tags/Media/"}]},{"title":"OkHttp源码分析-WebSocket","slug":"okhttp-source-code-websocket","date":"2018-08-20T02:05:55.000Z","updated":"2019-12-22T12:08:06.486Z","comments":true,"path":"2018/08/20/okhttp-source-code-websocket/","link":"","permalink":"https://www.wangzhumo.com/2018/08/20/okhttp-source-code-websocket/","excerpt":"前言OkHttp可以说是Android中一个非常重要的网络请求框架,最近的业务需要WebSocket的功能,看到有人说okhttp就可以做到了,于是我打开了源码,果然. Okhttp - internal - ws okhttp3.internal.ws.RealWebSocket okhttp3.internal.ws.WebSocketProtocol okhttp3.internal.ws.WebSocketReader okhttp3.internal.ws.WebSocketWriter okhttp3.WebSocket okhttp3.WebSocketListener 那么接下来,让我来一探究竟","text":"前言OkHttp可以说是Android中一个非常重要的网络请求框架,最近的业务需要WebSocket的功能,看到有人说okhttp就可以做到了,于是我打开了源码,果然. Okhttp - internal - ws okhttp3.internal.ws.RealWebSocket okhttp3.internal.ws.WebSocketProtocol okhttp3.internal.ws.WebSocketReader okhttp3.internal.ws.WebSocketWriter okhttp3.WebSocket okhttp3.WebSocketListener 那么接下来,让我来一探究竟 WebSocket创建okhttp3.WebSocket public interface WebSocket { /** Returns the original request that initiated this web socket. */ Request request(); /** * Returns the size in bytes of all messages enqueued to be transmitted to the server. */ long queueSize(); /** * Attempts to enqueue {@code text} to be UTF-8 encoded and sent as a the data of a text (type */ boolean send(String text); /** * Attempts to enqueue {@code bytes} to be sent as a the data of a binary (type {@code 0x2}) * message. * &lt;p&gt;This method returns immediately. */ boolean send(ByteString bytes); boolean close(int code, @Nullable String reason); /** * Immediately and violently release resources held by this web socket, discarding any enqueued * messages. This does nothing if the web socket has already been closed or canceled. */ void cancel(); interface Factory { /** * Creates a new web socket and immediately returns it. Creating a web socket initiates an asynchronous process to connect the socket */ WebSocket newWebSocket(Request request, WebSocketListener listener); } } 哎,,,这注释写的,都舍不得删了. 可以看到,接口中的方法基本上都是对WebSocket的操作,如发送,关闭,取消,大小 需要关注的是interface Factory 中的newWebSocket()方法,实现在OkHttpClient okhttp3.OkHttpClient /** * Uses {@code request} to connect a new web socket. */ @Override public WebSocket newWebSocket(Request request, WebSocketListener listener) { RealWebSocket webSocket = new RealWebSocket(request, listener, new Random(), pingInterval); webSocket.connect(this); return webSocket; } 发现是由RealWebSocket来创建WebSocket的连接的 它接收了一个Request,以及WebSocketListener 其中的pingInterval是发送ping消息的时间,是由OkhttpClient去设置的. 接下来关注connetc(this)这个方法,我们去看看RealWebSocket okhttp3.internal.ws.RealWebSocket public final class RealWebSocket implements WebSocket, WebSocketReader.FrameCallback { //public interface FrameCallback { // void onReadMessage(String text) throws IOException; // void onReadMessage(ByteString bytes) throws IOException; // void onReadPing(ByteString buffer); // void onReadPong(ByteString buffer); // void onReadClose(int code, String reason); //} } 实现接口: 实现了WebSocket接口中的方法 实现WebSocketReader.FrameCallback接口 可以看到,其中都是读取数据的回调 属性字段: private final Request originalRequest; 是我们应用中传过来的原始请求 final WebSocketListener listener; 这是我们使用的过程中,比较关注的一个类,他是一个抽象类,主要负责把WebSocket中的通信 onOpen(WebSocket webSocket, Response response) onMessage(WebSocket webSocket, String text) onMessage(WebSocket webSocket, ByteString bytes) onClosing(WebSocket webSocket, int code, String reason) onClosed(WebSocket webSocket, int code, String reason) onFailure(WebSocket webSocket, Throwable t, @Nullable Response response)","categories":[{"name":"Android","slug":"Android","permalink":"https://www.wangzhumo.com/categories/Android/"}],"tags":[{"name":"Android","slug":"Android","permalink":"https://www.wangzhumo.com/tags/Android/"}]},{"title":"WebSocket的使用笔记-理论基础","slug":"websocket-note","date":"2018-08-19T02:57:00.000Z","updated":"2019-12-22T12:05:52.905Z","comments":true,"path":"2018/08/19/websocket-note/","link":"","permalink":"https://www.wangzhumo.com/2018/08/19/websocket-note/","excerpt":"前言WebSocket 是HTML5一种新的web通信技术,实现了浏览器与服务器的全双工实时通信(full-duplex) 在WebSocket中,第一次还是采用Http的形式来通知服务器,准备使用WebSocket的协议,而如果服务器支持的话,会返回成功的通知101,而后就会长连接来进行全双工的通信,而不是Request &amp; Response,每一次请求完成都断开连接. 因此,WebSocket通常是使用在推送,即时通讯,等等需要即时性的通讯需求. Wiki WebSocket 是独立的、创建在 TCP 上的协议. WebSocket使得客户端和服务器之间的数据交换变得更加简单，允许服务端主动向客户端推送数据。在WebSocket API中，浏览器和服务器只需要完成一次握手，两者之间就直接可以创建持久性的连接，并进行双向数据传输。","text":"前言WebSocket 是HTML5一种新的web通信技术,实现了浏览器与服务器的全双工实时通信(full-duplex) 在WebSocket中,第一次还是采用Http的形式来通知服务器,准备使用WebSocket的协议,而如果服务器支持的话,会返回成功的通知101,而后就会长连接来进行全双工的通信,而不是Request &amp; Response,每一次请求完成都断开连接. 因此,WebSocket通常是使用在推送,即时通讯,等等需要即时性的通讯需求. Wiki WebSocket 是独立的、创建在 TCP 上的协议. WebSocket使得客户端和服务器之间的数据交换变得更加简单，允许服务端主动向客户端推送数据。在WebSocket API中，浏览器和服务器只需要完成一次握手，两者之间就直接可以创建持久性的连接，并进行双向数据传输。 WebSocket简介我们先来看一张图: 额,再来一张: 先说第二张图,说明了WebSocket与Http的关系,其实两者除了都是基于TCP之外联系并不大,只是WebSocket的第一次握手申请升级协议的时候使用了Http的连接,而后的各种连接都是使用WebSocket的. 再来说第一张图,主要揭示了WebSocket的工作流程,通过握手后双方启用了WebSocket通信,而之后的一系列操作都是WebSocket自己来操作的. WebSocket客户端第一次请求 GET ws://echo.websocket.org/?encoding=text HTTP/1.1 Origin: http://websocket.org Cookie: __utma=99as Connection: Upgrade Host: echo.websocket.org Sec-WebSocket-Key: uRovscZjNol/umbTt5uKmw== Upgrade: websocket Sec-WebSocket-Version: 13 这是WebSocket第一次发送的请求,只支持GET请求 Upgrade 主要表明我需要升级协议,其后标明了需要升级的协议类型 Sec-WebSocket-Key 则是WebSocket 客户端发送的一个 base64 编码的密文,需要服务器端返一个对应加密Sec-WebSocket-Accept应答,如果不合法则抛出Error during WebSocket handshake错误,并关闭连接 WebSocket服务器返回 HTTP/1.1 101 WebSocket Protocol Handshake Date: Fri, 10 Feb 2012 17:38:18 GMT Connection: Upgrade Server: Kaazing Gateway Upgrade: WebSocket Access-Control-Allow-Origin: http://websocket.org Access-Control-Allow-Credentials: true Sec-WebSocket-Accept: rLHCkw/SKsO9GAH/ZSFhBATDKrU= Access-Control-Allow-Headers: content-type Sec-WebSocket-Key的内容加上字符串258EAFA5-E914-47DA-95CA-C5AB0DC85B11 生成的字符串进行SHA1编码 再将生成的字符串进行Base64编码 WebSocket通信WebSocket中所有数据均使用帧的形式发送。 客户端发送的数据帧都要经过掩码处理,服务端发送的所有数据帧都不能经过掩码处理,否则对方需要发送关闭帧。 一个帧包含一个帧类型的标识码,一个负载长度,和负载(包括扩展内容和应用内容) WebSocket数据帧的统一格式 0 1 2 3 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 +-+-+-+-+-------+-+-------------+-------------------------------+ |F|R|R|R| opcode|M| Payload len | Extended payload length | |I|S|S|S| (4) |A| (7) | (16/64) | |N|V|V|V| |S| | (if payload len==126/127) | | |1|2|3| |K| | | +-+-+-+-+-------+-+-------------+ - - - - - - - - - - - - - - - + | Extended payload length continued, if payload len == 127 | + - - - - - - - - - - - - - - - +-------------------------------+ | |Masking-key, if MASK set to 1 | +-------------------------------+-------------------------------+ | Masking-key (continued) | Payload Data | +-------------------------------- - - - - - - - - - - - - - - - + : Payload Data continued ... : + - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - + | Payload Data continued ... | +---------------------------------------------------------------+ FIN 1个比特。 如果是1,表示这是消息的最后一个分片,若是0表示不是最后一个 RSV1, RSV2, RSV3各占1个比特 这三个都是留着扩展用的 Opcode 4个比特 0 表示此帧是一个继续帧,需要拼接在上一个收到的帧,组成一个完整的消息,所以非控制帧的发送和接收必须是相同的顺序 1 文本帧 2 二进制帧 3 - 7 保留 8 关闭连接控制帧 此帧可能会包含内容,以表示关闭连接的原因,注意必须是客户端与服务器端成对出现,而后关闭链接. 9 Ping类似于心跳,收到Ping之后应立即发送Pong响应 10 Pong 如果通信一方并没有发送Ping,但是收到了Pong,并不要求它返回任何信息 11 - 15 保留 Mask 1个比特 表示是否要对数据载荷进行掩码操作 Payload length 7bit 数据的长度, length == 126 时,后面的2 个字节也是表示数据长度 当它 length == 127 时,后面的 8 个字节表示数据长度 Masking-key 0或4字节 主要看Mask的值来决定 Payload data 扩展数据+应用数据 应用数据,在扩展数据之后,帧数据的剩余长度就是应用数据的长度. WebSocket保持心跳WebSocket保持客户端,服务端的实时双向通信,需要确保客户端,服务端之间的TCP连接没有断开。 但是又不能一直去发送数据,这样的话会浪费大量的资源. 此时就是心跳来保持连接: 发送方 ping opcode = 9 接收方 pong opcode = A WebSocket的使用这一部分我准备用另一篇笔记来记录 OkHttp这里单独说一下okhttp,竟然支持websocket的通信协议,而且还有一个扩展模块mockserver支持测试..简直完美 implementation “com.squareup.okhttp3:okhttp:$okhttpVersion” implementation “com.squareup.okhttp3:mockwebserver:$okhttpVersion” Java-websocketJava-WebSocket,这是使用java来实现的WebSocket客户端和服务端,也是6的飞起. 那么我下一篇笔记主要会记录Okhttp的使用,或者会分析一下okhttp中实现websocket的源码.","categories":[{"name":"Server","slug":"Server","permalink":"https://www.wangzhumo.com/categories/Server/"}],"tags":[{"name":"Android","slug":"Android","permalink":"https://www.wangzhumo.com/tags/Android/"},{"name":"Server","slug":"Server","permalink":"https://www.wangzhumo.com/tags/Server/"}]},{"title":"MacOS装机必备","slug":"macos-change-list","date":"2018-08-17T07:54:36.000Z","updated":"2019-12-22T12:08:38.547Z","comments":true,"path":"2018/08/17/macos-change-list/","link":"","permalink":"https://www.wangzhumo.com/2018/08/17/macos-change-list/","excerpt":"前言更换工作的机器,所有的环境都要再搭一次,还是挺苦逼的 这里记录下来.","text":"前言更换工作的机器,所有的环境都要再搭一次,还是挺苦逼的 这里记录下来. 环境ssh 相关 ~/.ssh/config 配置目录 ~/.ssh/下的所有公钥/密钥 brew包管理 安装 /usr/bin/ruby -e &quot;$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/master/install)&quot; List brew install htop //系统监控 brew install hexo //博客系统 brew install kotlin //kotlin编译环境 brew insatll zsh //zsh brew install vim //vim brew install tree //tree 工具 brew install python3 //py brew install polipo //终端的代理工具 brew install git //git brew install cmake //cmake编译 brew install hightlight //高亮 brew install autojump //autojump 终端iterm2 https://www.iterm2.com/ go2Shell http://zipzapmac.com/go2shell zsh~/.zshrc 环境变量ulimit -S -n 1024 export JAVA_HOME=/Library/Java/JavaVirtualMachines/jdk1.8.0_161.jdk/Contents/Home export ANDROID_HOME=/Users/phyooos/Library/Android/sdk export TOMCAT_HOME=/Users/phyooos/develop/apache-tomcat-7.0.77 export GRADLE_USER_HOME=/Users/phyooos/develop/gradle export MYSQL_HOME=/usr/local/mysql-5.7.18-macos10.12-x86_64 export GOROOT=/usr/local/go export GOPATH=/Users/phyooos/develop/workspace export GOBIN=$GOPATH/bin export NDK_HOME=/Users/phyooos/Library/Android/sdk/ndk-bundle export REPO_URL=&#39;https://mirrors.tuna.tsinghua.edu.cn/git/git-repo/&#39; export SCALA_HOME=/Users/phyooos/develop/scala-2.11.8 export MAVEN_HOME=/Users/phyooos/develop/apache-maven-3.5.0 export FLUTTER_HOME=/Users/phyooos/develop/flutter export WEBP_HOME=/Users/phyooos/develop/libwebp export DART_HOME=/Users/phyooos/develop/flutter/bin/cache/dart-sdk export PATH=/usr/local/Cellar/gcc/8.1.0/bin:/usr/local/bin:$PATH:$JAVA_HOME/bin:$ANDROID_HOME/tools:$ANDROID_HOME/platform-tools:$TOMCAT_HOME/bin:$GRADLE_HOME/bin:$MYSQL_HOME/bin:$GOROOT/bin:$GOPATH:$GOBIN:$GOPATH/bin:$FLUTTER_HOME/bin:$DART_HOME/bin:$MAVEN_HOME/bin:$SCALA_HOME/bin:$NDK_HOME:$WEBP_HOME/bin 文件桌面文件 文件夹 Develop flutter 的安装 hexo proxyee workspace 图片公共音乐workspace软件网络通讯 Aira2GUI Google Chrome ShadowsocksX-NG-R8 LanScan Pro Little Snitch Configuration Charles Foxmail 微信 QQ 钉钉 Zeplin 系统工具 Enpass 截图 - 腾讯 Dukto Bartender 3 Go2Shell Iterm2 Kaleidoscope Cheat Sheet TinyPNG4Mac Pap.er CleanMyMac Tuxera Disk Manager 开发工具 Android Studio Intellij IDEA PyCharm Xcode Tower GoLand CodeRunner Visual Studio Code Postman Yummy FTP Pro Typora 有道词典 NWeb Paw for Trello 其他 MindNode IThoughtsX Sketch Xnip 网易云音乐 Acorn IINA PicGIF","categories":[{"name":"Tools","slug":"Tools","permalink":"https://www.wangzhumo.com/categories/Tools/"}],"tags":[{"name":"Tools","slug":"Tools","permalink":"https://www.wangzhumo.com/tags/Tools/"}]},{"title":"Kotlin学习笔记-高级函数","slug":"kotlin-learn-advance-fun","date":"2018-08-13T03:28:04.000Z","updated":"2019-12-22T12:09:06.518Z","comments":true,"path":"2018/08/13/kotlin-learn-advance-fun/","link":"","permalink":"https://www.wangzhumo.com/2018/08/13/kotlin-learn-advance-fun/","excerpt":"","text":"常用高级函数map 一般方式 ```kotlinfun main(args: Array) { val list = listOf(1,2,3,4,5,6,7) //函数引用的方式int转为double list.map(Int::toDouble) val newList = list.map{ //it 就是当前元素 it *2 } } &lt;!--more--&gt; - 引用函数的map ```kotlin fun main(args: Array&lt;String&gt;) { val list = listOf(1,2,3,4,5,6,7) //函数引用的方式int转为double list.map(Int::toDouble) } //源码 map public inline fun &lt;T, R&gt; Iterable&lt;T&gt;.map(transform: (T) -&gt; R): List&lt;R&gt; { return mapTo(ArrayList&lt;R&gt;(collectionSizeOrDefault(10)), transform) //ArrayList&lt;R&gt;(collectionSizeOrDefault(10)) 初始化一个和原来一样长的list //transform 就是我们传进去的函数 } //源码 mapTo //destination 就是上面初始化好的List //transform 也是上面传进来的函数,负责转换 public inline fun &lt;T, R, C : MutableCollection&lt;in R&gt;&gt; Iterable&lt;T&gt;.mapTo(destination: C, transform: (T) -&gt; R): C { //一个for循环,遍历所有元素,并转换后添加到新List for (item in this) destination.add(transform(item)) return destination //返回List } flatMapfun main(args: Array&lt;String&gt;) { //以上是一个元素为数组的List val list = listOf(1..8,9..12,13..27 step 2,28..32) //展开List,并把List中的每一个元素中的每一个元素 + 1 val newList = list.flatMap { intRange -&gt; intRange.map { item -&gt; item + 1 } } //同上 val newList2 = list.flatMap { it -&gt; it.map { it + 1 } } // 只是展开了List,其他什么也没做 val newList3 = list.flatMap { it -&gt; it } } //源码 /** * Returns a single list of all elements yielded from results of [transform] function being invoked on each element of original collection. */ public inline fun &lt;T, R&gt; Iterable&lt;T&gt;.flatMap(transform: (T) -&gt; Iterable&lt;R&gt;): List&lt;R&gt; { //创建List , 传入针对原List中元素的转换方法 return flatMapTo(ArrayList&lt;R&gt;(), transform) } /** * Appends all elements yielded from results of [transform] function being invoked on each element of original collection, to the given [destination]. */ public inline fun &lt;T, R, C : MutableCollection&lt;in R&gt;&gt; Iterable&lt;T&gt;.flatMapTo(destination: C, transform: (T) -&gt; Iterable&lt;R&gt;): C { //遍历原来List for (element in this) { //此处的transform,转换原List中的每一个元素 val list = transform(element) destination.addAll(list) } //返回了新List return destination } reduce//实际就计算了所有元素的和 newList.reduce { acc, i -&gt; //acc 是上一次计算的结果 //i 是当前的元素 acc + i // 这个是操作的函数 } //源码 /** * Accumulates value starting with the first element and applying [operation] from left to right to current accumulator value and each element. */ public inline fun &lt;S, T: S&gt; Iterable&lt;T&gt;.reduce(operation: (acc: S, T) -&gt; S): S { //获取了我们的迭代对象 val iterator = this.iterator() //如果不是空List就继续执行 if (!iterator.hasNext()) throw UnsupportedOperationException(&quot;Empty collection can&#39;t be reduced.&quot;) //取到List的第一个元素 var accumulator: S = iterator.next() while (iterator.hasNext()) { //这一步就是把上面一个进入操作的结果和下一个元素做了 operation 的操作, //而这个 operation 就是你传进来的函数 //计算完毕之后,又把计算结果赋给了 accumulator accumulator = operation(accumulator, iterator.next()) } //最后返回结果 return accumulator } eg: val list = listOf(1,2,3,4) val accumulator = list[0] = 1 while ( -- ){ //第一次 1 = 1 + 2 = 3 //第二次 3 = 3 + 3 = 6 //第三次 6 = 6 + 6 = 10 } return 10 flod//源码表示,只是初始值是你指定的那个值,其他和reduce差不多一致的思路 /** * Accumulates value starting with [initial] value and applying [operation] from left to right to current accumulator value and each element. */ public inline fun &lt;T, R&gt; Iterable&lt;T&gt;.fold(initial: R, operation: (acc: R, T) -&gt; R): R { var accumulator = initial //operation 操作上次结构 for (element in this) accumulator = operation(accumulator, element) return accumulator } //字符串拼接 newList.fold(StringBuffer()){ acc, i -&gt; acc.append(i).append(&quot;,&quot;) } 输出: 2,3,4,5,6,7,8,9,10,11,12,13,14,16,18,20,22,24,26,28,29,30,31,32,33, filter过滤掉不符合条件的 takeWhile取第一个不符合条件元素之前的所有元素. #### let最常用的场景就是使用let函数处理需要针对一个可null的对象统一做判空处理 fun main(args: Array&lt;String&gt;) { //以上是一个元素为数组的List val list = listOf(1..8,9..12,13..27 step 2,28..32) val kc = KotlinClassA() val per : DataClass? = DataClass(12,&quot;脑壳痛&quot;) per?.copy() per?.addWhat1(kc) per?.addWhat2(kc) per?.addWhat3(kc) //let per?.let { it.copy() it.addWhat1(kc) it.addWhat2(kc) it.addWhat3(kc) } } //源码 @kotlin.internal.InlineOnly public inline fun &lt;T, R&gt; T.let(block: (T) -&gt; R): R { contract { callsInPlace(block, InvocationKind.EXACTLY_ONCE) } //把接收的参数,传入了我们提供的函数中 return block(this) } with适用于调用同一个类的多个方法时，可以省去类名重复，直接调用类的方法即可，如Android中onBinderViewHolder中，数据model的属性映射到UI上 @kotlin.internal.InlineOnly public inline fun &lt;T, R&gt; with(receiver: T, block: T.() -&gt; R): R { contract { callsInPlace(block, InvocationKind.EXACTLY_ONCE) } return receiver.block() } //用收到的实例去调用 block方法,返回值自己定义 runlet + with 的结合体 既可以直接访问实例的公有属性和方法 又弥补了with函数传入对象判空问题 @kotlin.internal.InlineOnly public inline fun &lt;T, R&gt; T.run(block: T.() -&gt; R): R { contract { callsInPlace(block, InvocationKind.EXACTLY_ONCE) } return block() } apply@kotlin.internal.InlineOnly public inline fun &lt;T&gt; T.apply(block: T.() -&gt; Unit): T { contract { callsInPlace(block, InvocationKind.EXACTLY_ONCE) } block() return this } //注意它返回的是this 闭包 就是函数的运行环境 持有函数的运行状态 函数内部可以定义函数 函数内部也可以定义类 fun fibonacci(): () -&gt; Long { var first = 0L var second = 1L return fun() : Long{ val result = second second += first first = second - first return result } } fun main(args: Array&lt;String&gt;) { val f = fibonacci() println(f()) println(f()) println(f()) println(f()) println(f()) } 输出: 1 1 2 3 5 我们发现var first = 0L,var second = 1L 这两个的值被保存住了 每次f() 后,first和 second都能记住他们当前被赋予的值 复合函数这简直太秀了 fun add(int: Int) = int + 1 fun multiply(int: Int) = int * 2 fun &lt;A, B, C&gt; compose(f: (B) -&gt; C, g: (A) -&gt; B) : (A) -&gt; C { return { x -&gt; f(g(x)) } } fun main(args: Array&lt;String&gt;) { val addAndMultiply = compose(::add, ::multiply) println(addAndMultiply(9)) //输出 19 } ###","categories":[{"name":"Java","slug":"Java","permalink":"https://www.wangzhumo.com/categories/Java/"}],"tags":[{"name":"Java，Kotlin","slug":"Java，Kotlin","permalink":"https://www.wangzhumo.com/tags/Java，Kotlin/"}]},{"title":"Kotlin学习笔记-基础","slug":"kotlin-learn-note-basic","date":"2018-08-10T07:47:59.000Z","updated":"2019-12-22T12:09:02.880Z","comments":true,"path":"2018/08/10/kotlin-learn-note-basic/","link":"","permalink":"https://www.wangzhumo.com/2018/08/10/kotlin-learn-note-basic/","excerpt":"基本类型不会隐式转换val a = 123 val b : Float = a //这样是不合法的,不支持隐式转换 val c : Float = a.toFloat()","text":"基本类型不会隐式转换val a = 123 val b : Float = a //这样是不合法的,不支持隐式转换 val c : Float = a.toFloat() 多行val lines = &quot;&quot;&quot; 好人啊. #/ $a &quot;&quot;&quot; print(lines) 输出为 好人啊. #/ 123 Process finished with exit code 0 引用类型空安全fun getValue() : String { return null //报错 } 如果你这么写,一定是会报错的,原因是 指定的返回值 String 不接受null的返回值 如果你一定要它可以返回一个空那就只能加一个? fun getValue() : String? { return null } 那么作为调用者 print(getValue()?.length) //输出 null print(getValue()!!.length) //输出 KotlinNullPointerException ,直接就给干崩了 ? 的作用是,如果为空则输出null ,如果不为空则正常使用 !!取消空安全机制,就和java一样了 类型转换对于转换异常的那些,如果一旦错误就直接奔溃,我们希望它不要崩溃,而是以其他的方式来表现 open class Parent class Child : Parent() fun main(args: Array&lt;String&gt;) { val parent = Parent() val child = parent as? Child //然而抛出了一个异常 ClassCastException,类型转换异常 print(child) } 那么Kotlin对此做了什么操作? val child = parent as? Child print(child) //输出 null,而不会直接奔溃 区间Range a..b 运算符 [a,b] a until b [a,b) val range : IntRange = 1..29 Range 的方法 contains 也可以使用 in 运算符 isEmpty EMPTY (静态变量) print(range.contains(9)) // ture print(99 in range) // false 遍历Rangefor (i in range){ print(i) } 数组创建数组val intArr: IntArray = intArrayOf(1,2,3,4,5) val charArr: CharArray = charArrayOf(&#39;a&#39;,&#39;b&#39;,&#39;c&#39;,&#39;d&#39;,&#39;e&#39;) val objArr: Array&lt;Parent&gt; = arrayOf(Parent(&quot;王&quot;),Parent(&quot;诛&quot;),Parent(&quot;魔&quot;)) 遍历for map iterator ... val/var/coustvar 可以修改 val 不可修改final 运行时常量 const 静态常量 编译期常量 Lambda//一般写法 fun doSome(a:Int,b:Int) : Int{ return a + b +1 } //如果只有返回值,其实可以直接写 fun doSome(a:Int,b:Int) : Int = a + b +1 val array = arrayOf(1,3,4,5,6,7) fun main(args: Array&lt;String&gt;) { //lambda表达式 array.forEach { print(it) } // :: 引用 array.forEach(::print) array.forEachIndexed { index, i -&gt; print(&quot;index = $index , value = $i&quot;) } } 有一点要注意的是,Lambda中的Return fun main(args: Array&lt;String&gt;) { array.forEachIndexed { index, i -&gt; if (index ==2 ) return println(&quot;index = $index , value = $i&quot;) } print(&quot;Fun End&quot;) } //输出: index = 0 , value = 1 index = 1 , value = 3 Process finished with exit code 0 我们可以看到,if (index ==2 ) return直接就返回了main的方法 那么我想跳出forEachIndexed怎么办? fun main(args: Array&lt;String&gt;) { array.forEachIndexed JUMP@{ index, i -&gt; if (index == 2) return@JUMP println(&quot;index = $index , value = $i&quot;) } print(&quot;Fun End&quot;) } //输出 index = 0 , value = 1 index = 1 , value = 3 index = 3 , value = 5 index = 4 , value = 6 index = 5 , value = 7 Fun End 我们可以发现,index = 2 的那一条消失了,因为我们跳出了方法,回到了我们标记的地方 JUMP@ 类成员重写默认的Get/Set方法class KotlinClassA{ var a = 123 get() { println(&quot;get a value&quot;) return field } set(value) { field = value println(&quot;someone set value&quot;) } } 字段延迟初始化class KotlinClassA{ var a = 123 get() { print(&quot;get a value&quot;) return field } set(value) { field = value print(&quot;someone set value&quot;) } //var直接使用lateinit即可 lateinit var b:String //val的只能用 by 了,lazy返回一个lambda表达式 val c :String by lazy { print(&quot;lazy init c&quot;) &quot;666&quot; } } fun main(args: Array&lt;String&gt;) { val kot = KotlinClassA() println(kot.a) println(kot.c) } 输出: get a value 123 lazy init c 666 Process finished with exit code 0 可以看到,c是在我调用它的时候,才打印了lazy init c说明确实是延迟加载的,否则应该是KotlinClassA初始化的时候就应该打印这句话的. 操作符在java中,操作符的作用是固定的,我们没有办法去改变它 但是在kotlin中,允许我们去自重写操作符,只需要保证入入参数量与函数名一致即可 Kotlin给出的文档 class OperatorClass(val value :Int){ //比如我想让加法变成减法 operator fun plus(other : OperatorClass):Int{ return value - other.value } operator fun plus(other : Int):Int{ return value - other.value } } fun main(args: Array&lt;String&gt;) { val opera = OperatorClass(66) //两个类相加 print(opera + OperatorClass(6)) print(opera + 10) } 输出: 60 56 我不仅仅让OperatorClass有了加法,而且还把加法改写成了减法 还有很多的操作符是可以重写的,看看文档就知道了. 表达式if表达式kotlin中的if等等,都是一个表达式,他是可以有值的,我一直没有理解这个. 看到这个例子,我明白了 const val DEBUG = 0 const val USER = 1 const val USER_NAME = &quot;kotlin&quot; const val USER_PASS_WD = &quot;jetBrains&quot; const val ADMIN = &quot;admin&quot; fun main(args: Array&lt;String&gt;) { //使用了if的返回值,每块中的最后一行就是返回值 val mode = if (args.isNotEmpty() &amp;&amp; args[0] == &quot;0&quot;) { DEBUG } else { USER } println(&quot;USER:&quot;) val user = readLine() println(&quot;PASSWORD:&quot;) val passwd = readLine() if (mode == DEBUG &amp;&amp; user == ADMIN &amp;&amp; passwd == ADMIN) { println(&quot;Welcome Admin Login.&quot;) } else if (user == USER_NAME &amp;&amp; passwd == USER_PASS_WD) { println(&quot;Welcome $user Login.&quot;) } else { println(&quot;Error.&quot;) } } When表达式when也和if表达式一样,但要注意的是,如果是要用来赋值,那么else -&gt; 也需要返回值 val mode = when{ args.isNotEmpty() &amp;&amp; args[0] == &quot;0&quot; -&gt; 0 else -&gt; 1 } when (mode){ !is Int -&gt; println(&quot;mode is Int&quot;) in 0..9 -&gt; println(&quot;$mode in 1..9&quot;) 0 -&gt; println(&quot;mode == 0&quot;) else -&gt; println(&quot;bye&quot;) } 循环for循环只要一个数据结构可迭代,就可以使用这样的方式来遍历 fun main(args: Array&lt;String&gt;) { for (value in args){ println(value) } for ((index,value) in args.withIndex()){ println(&quot;current $index index = $value&quot;) } for (valueWithIndex in args.withIndex()){ println(&quot;current ${valueWithIndex.index} index = ${valueWithIndex.value}&quot;) } } 跳出和跳过@LABEL 标签 break continue 异常这玩意也是一个表达式,别的就不说了 参数多个参数fun sing(vararg words: String,count :Int){ words.forEach(::println) println(count) } fun main(args: Array&lt;String&gt;) { val array = arrayOf(&quot;ds&quot;,&quot;ce&quot;,&quot;lp&quot;) sing(&quot;abc&quot;,&quot;def&quot;,&quot;zyx&quot;,&quot;opl&quot;,count = 4) // *Array 可以把一个数组展开 sing(*array,count = array.size) } 默认值fun sing(vararg words: String,count :Int = 1000){ words.forEach(::println) println(count) } fun main(args: Array&lt;String&gt;) { sing(&quot;12&quot;,&quot;23&quot;,&quot;63&quot;) } 下面的调用中,并没有传入count的值,但是并不会报错,因为函数中指定count的默认值了 接口/继承interface Drive{ fun drive() } interface Fix{ fun fix(){ println(&quot;维修技能&quot;) } } class CarDrive: Drive{ override fun drive() { println(&quot;驾驶技能-汽车&quot;) } } class ComputerFix: Fix{ override fun fix() { super.fix() println(&quot;维修技能-修电脑&quot;) } } class Manager : Drive,Fix{ override fun drive() { println(&quot;经理开车-奥迪轿车&quot;) } override fun fix() { super.fix() println(&quot;经理维修-汽车&quot;) } } class SeniorManager(val drive: Drive,val fix: Fix) : Drive by drive , Fix by fix fun main(args: Array&lt;String&gt;) { val manager = Manager() manager.drive() manager.fix() val carDrive = CarDrive() val computerFix = ComputerFix() val seniorManager = SeniorManager(carDrive,computerFix) seniorManager.drive() seniorManager.fix() } 接口可以有默认的方法,但是没有状态 Drive by drive , Fix by fix 代理了经理的技能. 静态方法/@JvmStaticclass Pay private constructor(val money : Double){ companion object { fun toPay(v : Double): Pay{ return Pay(v) } // JvmStatic注解的,可以在Java中像静态方法一样调用 @JvmStatic fun copyPay(p : Pay) : Pay{ return Pay(p.money) } } } kotlin: val pay = Pay.toPay(10.93) val pay2 = Pay.copyPay(pay) Java: //正常的调用,必须使用 Companion 伴生对象 Pay pay = Pay.Companion.toPay(123.8); Pay pay2 = Pay.copyPay(pay);","categories":[{"name":"Java","slug":"Java","permalink":"https://www.wangzhumo.com/categories/Java/"}],"tags":[{"name":"Java，Kotlin","slug":"Java，Kotlin","permalink":"https://www.wangzhumo.com/tags/Java，Kotlin/"}]},{"title":"Glide4.X版本图片加载显示进度","slug":"glide-okhttp-progress","date":"2018-08-09T09:40:04.000Z","updated":"2019-12-22T12:10:05.141Z","comments":true,"path":"2018/08/09/glide-okhttp-progress/","link":"","permalink":"https://www.wangzhumo.com/2018/08/09/glide-okhttp-progress/","excerpt":"前言Glide无疑是一款非常优秀的图片加载框架,但是他并没有支持显示图片加载的进度. 那么我们遇到这种需求的时候应该怎么办?自己写一个图片加载框架么? 不,我们肯定是选择自己来扩展这个框架,使得Glide”支持”显示进度 GlideImageView 用来控制start &amp; autoStart , 用来显示 progress , error OkHttp 用来支持进度的回调","text":"前言Glide无疑是一款非常优秀的图片加载框架,但是他并没有支持显示图片加载的进度. 那么我们遇到这种需求的时候应该怎么办?自己写一个图片加载框架么? 不,我们肯定是选择自己来扩展这个框架,使得Glide”支持”显示进度 GlideImageView 用来控制start &amp; autoStart , 用来显示 progress , error OkHttp 用来支持进度的回调 思考为什么我要选择使用OkHttp来改造那? @Override public void registerComponents(Context context, Glide glide, Registry registry) { registry.replace(GlideUrl.class, InputStream.class, new OkHttpUrlLoader.Factory()); } 我们可以看到,ModelLoaderFactory是我们自己传进去的,那么我只要持有这个ModelLoaderFactory不就可以知道进度了么? 追踪源码发现了初始化OkHttpClient的方法,internalClient 是Call.Factory类型的,而OkHttpClient是Call.Factory的实现类. /** * Constructor for a new Factory that runs requests using a static singleton client. */ public Factory() { this(getInternalClient()); } /** * Constructor for a new Factory that runs requests using given client. * * @param client this is typically an instance of {@code OkHttpClient}. * * 看到这个有参的构造函数了么?还是Public的.. */ public Factory(@NonNull Call.Factory client) { this.client = client; } private static Call.Factory getInternalClient() { if (internalClient == null) { synchronized (Factory.class) { if (internalClient == null) { internalClient = new OkHttpClient(); } } } return internalClient; } 那么,可以确定替换OkHttpClient的思路是正确的,下面我们来实现一下 OkHttpLoadImage 提供OkHttpClient并添加拦截器 OnProgressListener 由需要显示进度的View实现,提供一个Url,回调progress OkHttpClient 的实例 HashMap 实际上存放的是View自己 ProgressResponseBody 对外提供当前下载的进度 LoadImageView 记录当前url,显示进度 GlideLoaderModule @GlideModule 通过new OkHttpUrlLoader.Factory(OkHttpLoadImage.INSTANCE())替代默认的OkHttpClient 代码实现OkHttpLoadImage该类提供一个OkHttpClient的实例,在这个实例中添加一个NetworkInterceptor,这个拦截器提供当前下载的进度 /** * If you have any questions, you can contact by email {wangzhumoo@gmail.com} * * @author 王诛魔 2018/8/9 下午6:10 */ public final class OkHttpLoadImage { //一定要记得unRegister,这里存放的是key以及OnProgressListener //实际上,我们最好采用软引用,这样更加的安全,毕竟我们无法感知View的生命周期 private static HashMap&lt;String, OnProgressListener&gt; progressListenerMap; //添加了拦截的OkHttpClient private OkHttpClient okHttpClient; static { progressListenerMap = new HashMap&lt;&gt;(); } private OkHttpLoadImage() { initOkHttp(); } /** * 构建一个OkHttp的实例 * ProgressResponseBody 是一个比较关键的类,他提供了进度 */ private void initOkHttp() { okHttpClient = new OkHttpClient.Builder() .addNetworkInterceptor(chain -&gt; { Request request = chain.request(); Response response = chain.proceed(request); ProgressResponseBody body = new ProgressResponseBody(response, request.url().toString()); //添加监听,使得当前类知道进度 body.addOnResponseListener(responseListener); return response.newBuilder() .body(body) .build(); }) .build(); } private static class SingletonHolder { private static OkHttpLoadImage instance = new OkHttpLoadImage(); } public static OkHttpClient INSTANCE(){ return SingletonHolder.instance.okHttpClient; } private static ProgressResponseBody.OnResponseListener responseListener = new ProgressResponseBody.OnResponseListener() { @Override public void update(String key, float progress) { //去寻找这个key，并传回去当前的进度 OnProgressListener listener = progressListenerMap.get(key); if (listener != null) { listener.onProgress(progress); } } }; /** * 注册进度的回调 */ public static void register(OnProgressListener listener) { //可能会有多个View注册，但是我们只回调当前这个 progressListenerMap.put(listener.getKey(), listener); } /** * 取消监听 * * @param listener view */ public static void unRegister(OnProgressListener listener) { progressListenerMap.remove(listener.getKey()); } /** * 监听进度的接口 */ public interface OnProgressListener { //回调当前的进度给View void onProgress(float progress); //获取当前View资源的key(URL即可) String getKey(); } } ProgressResponseBody这个东西,网上到处都是 public class ProgressResponseBody extends ResponseBody{ //OkHttpLoadImage中传进来的response private final ResponseBody responseBody; private String url; private BufferedSource bufferedSource; public ProgressResponseBody(Response response,String url) { this.responseBody = response.body(); this.url = url; } @Override public MediaType contentType() { return responseBody.contentType(); } @Override public long contentLength() { return responseBody.contentLength(); } @Override public BufferedSource source() { if (bufferedSource == null) { bufferedSource = Okio.buffer(source(responseBody.source())); } return bufferedSource; } private Source source(BufferedSource source) { return new ForwardingSource(source) { long totalBytes = 0L; @Override public long read(Buffer sink, long byteCount) throws IOException { long bytesRead = super.read(sink, byteCount); // read() returns the number of bytes read, or -1 if this source is exhausted. totalBytes += bytesRead != -1 ? bytesRead : 0; if (listener != null) { //注意这块的 1.0 * , 要不两个long除法会一直是 0 listener.update(url, (float) 1.0 * totalBytes/contentLength()); } return bytesRead; } }; } private OnResponseListener listener; public void addOnResponseListener(OnResponseListener listener){ this.listener = listener; } public interface OnResponseListener{ void update(String key,float progress); } } LoadImageView/** * If you have any questions, you can contact by email {wangzhumoo@gmail.com} * * @author 王诛魔 2018/8/9 下午5:59 */ public class LoadImageView extends AppCompatImageView implements OkHttpLoadImage.OnProgressListener{ private Paint mPaint; private float progress; private String url; public LoadImageView(Context context) { this(context,null); } public LoadImageView(Context context, @Nullable AttributeSet attrs) { this(context, attrs,0); } public LoadImageView(Context context, AttributeSet attrs, int defStyleAttr) { super(context, attrs, defStyleAttr); init(); } public void setImageUrl(String url){ this.url = url; //此时开始加载 OkHttpLoadImage.register(this); ImageLoader.LoaderImg(getContext(),url).into(this); Glide.with(this).load(url).into(this); } /** * 初始化工具 */ private void init() { mPaint = new Paint(); mPaint.setColor(Color.BLACK); mPaint.setAntiAlias(true); mPaint.setStrokeWidth(5); mPaint.setTextSize(50); } @SuppressLint(&quot;DefaultLocale&quot;) @Override protected void onDraw(Canvas canvas) { super.onDraw(canvas); canvas.drawText(String.format(&quot;Already : %d&quot;,(int)(100 * progress)),100,100,mPaint); } public void progress(float progress){ this.progress = progress; invalidate(); } @Override public void onProgress(float progress) { post(() -&gt; progress(progress)); } @Override public String getKey() { return url; } public boolean isLoaded(){ return progress == 1F; } } GlideLoaderModule/** * If you have any questions, you can contact by email {wangzhumoo@gmail.com} * * @author 王诛魔 2017/8/9 下午12:16 * */ @GlideModule public final class GlideLoaderModule extends AppGlideModule { @Override public void applyOptions(Context context, GlideBuilder builder) { RequestOptions options = new RequestOptions() .centerCrop() .placeholder(R.drawable.default_images_load) .error(R.drawable.default_images_load) .priority(Priority.HIGH) .format(DecodeFormat.PREFER_ARGB_8888) .diskCacheStrategy(DiskCacheStrategy.ALL); int maxMemory = (int) Runtime.getRuntime().maxMemory(); int memoryCacheSize = maxMemory / 8; //设置内存缓存大小 File cacheDir = new File(ApiConstants.INSTANCE.getIMAGE_PATH() + File.separator); if(!cacheDir.exists()){ cacheDir.mkdirs(); } int diskCacheSize = 1024 * 1024 * 512; //设置磁盘缓存大小 builder.setMemoryCache(new LruResourceCache(memoryCacheSize)); builder.setDiskCache(new DiskLruCacheFactory(cacheDir.getPath(), &quot;Images&quot;, diskCacheSize)); builder.setDefaultRequestOptions(options); } @Override public void registerComponents(Context context, Glide glide, Registry registry) { registry.replace(GlideUrl.class, InputStream.class, new OkHttpUrlLoader.Factory(OkHttpLoadImage.INSTANCE())); } } 使用","categories":[{"name":"Android","slug":"Android","permalink":"https://www.wangzhumo.com/categories/Android/"}],"tags":[{"name":"Android","slug":"Android","permalink":"https://www.wangzhumo.com/tags/Android/"},{"name":"View","slug":"View","permalink":"https://www.wangzhumo.com/tags/View/"},{"name":"Glide","slug":"Glide","permalink":"https://www.wangzhumo.com/tags/Glide/"}]},{"title":"Glide4.X版本的基本使用","slug":"glide-4-note","date":"2018-08-09T06:32:53.000Z","updated":"2019-12-22T12:10:00.751Z","comments":true,"path":"2018/08/09/glide-4-note/","link":"","permalink":"https://www.wangzhumo.com/2018/08/09/glide-4-note/","excerpt":"前言Glide是一款性能优异,包大小中等,加载速度快的图片加载工具,也是Google推荐使用的加载框架之一. 在以前的工程中,我们都是使用3.8版本一下的Glide,而在4.X版本中,Glide的使用方式发生了一些变化,所以今天特意写了笔记来记录,以便于以后使用时查阅 地址 Glide: https://github.com/bumptech/glide","text":"前言Glide是一款性能优异,包大小中等,加载速度快的图片加载工具,也是Google推荐使用的加载框架之一. 在以前的工程中,我们都是使用3.8版本一下的Glide,而在4.X版本中,Glide的使用方式发生了一些变化,所以今天特意写了笔记来记录,以便于以后使用时查阅 地址 Glide: https://github.com/bumptech/glide 依赖:implementation (&quot;com.github.bumptech.glide:glide:4.7.1&quot;) { exclude group: &quot;com.android.support&quot; } annotationProcessor &quot;com.github.bumptech.glide:compiler:4.7.1&quot; //kotlin使用kapt // kapt &#39;com.github.bumptech.glide:compiler:4.7.1&#39; //如果你需要使用okhttp作为网络层 implementation &quot;com.github.bumptech.glide:okhttp3-integration:4.7.1&quot; 混淆(proguard):-keep public class * implements com.bumptech.glide.module.GlideModule -keep public class * extends com.bumptech.glide.module.AppGlideModule -keep public enum com.bumptech.glide.load.resource.bitmap.ImageHeaderParser$** { **[] $VALUES; public *; } # for DexGuard only -keepresourcexmlelements manifest/application/meta-data@value=GlideModule 开始使用基本配置继承 AppGlideModule /** * If you have any questions, you can contact by email {wangzhumoo@gmail.com} * @author 王诛魔 2018/8/9 下午12:16 */ @GlideModule public class GlideLoaderModule extends AppGlideModule { @Override public void applyOptions(Context context, GlideBuilder builder) { RequestOptions options = new RequestOptions() .centerCrop() .placeholder(R.drawable.default_images_load) .error(R.drawable.default_images_load) .priority(Priority.HIGH) .format(DecodeFormat.PREFER_ARGB_8888) .diskCacheStrategy(DiskCacheStrategy.ALL); int maxMemory = (int) Runtime.getRuntime().maxMemory(); int memoryCacheSize = maxMemory / 8; //设置内存缓存大小 File cacheDir = new File(ApiConstants.INSTANCE.getIMAGE_PATH() + File.separator); if(!cacheDir.exists()){ cacheDir.mkdirs(); } int diskCacheSize = 1024 * 1024 * 512; //设置磁盘缓存大小 builder.setMemoryCache(new LruResourceCache(memoryCacheSize)); builder.setDiskCache(new DiskLruCacheFactory(cacheDir.getPath(), &quot;Images&quot;, diskCacheSize)); builder.setDefaultRequestOptions(options); } @Override public void registerComponents(Context context, Glide glide, Registry registry) { registry.replace(GlideUrl.class, InputStream.class, new OkHttpUrlLoader.Factory()); } } 注意,GlideLoaderModule在4.X版本之后,不需要写到Manifest文件中去,但是需要你添加@GlideModule注解 注意,GlideLoaderModule在4.X版本之后,不需要写到Manifest文件中去,但是需要你添加@GlideModule注解 占位符 placeholder 占位符是当请求正在执行时被展示的 Drawable,当请求成功完成时,占位符会被请求到的资源替 如果资源是从内存中加载出来的，那么占位符可能根本不会被显示 如果请求失败并且没有设置 error Drawable ，则占位符将被持续展示 error 在请求永久性失败时展示 也在请求的url/model为 null ，且并没有设置 fallback Drawable 时展示 fallback 在请求的url/model为 null 时展示(注意,null). 会覆盖error的第二条显示条件 Transform(圆角)变换这块,分为几个部分 默认变换 CenterCrop FitCenter CircleCrop 多重变换使用transform方法 方式一 Glide.with(context) .load(url) .transform(new MultiTransformation(new FitCenter(), new CustomTransformation()) .into(imageView); 方式二 GlideApp.with(context) .load(url) .transforms(new FitCenter(), new CustomTransformation()) .into(imageView); 自定义变换()/** * If you have any questions, you can contact by email {wangzhumoo@gmail.com} * @author 王诛魔 2017/11/2 上午12:20 * 圆角图片 */ public class GlideRoundTransform extends BitmapTransformation { private static final String ID = &quot;com.wangzhumo.app.commonlib.utils.GlideRoundTransform&quot;; private static float radius = 0f; public GlideRoundTransform() { this(5); } /** * 圆角像素 * @param dp */ public GlideRoundTransform(int dp) { radius = Resources.getSystem().getDisplayMetrics().density * dp; } @Override protected Bitmap transform(@NonNull BitmapPool pool, @NonNull Bitmap toTransform, int outWidth, int outHeight) { return roundCrop(pool, toTransform); } private static Bitmap roundCrop(BitmapPool pool, Bitmap source) { if (source == null) return null; Bitmap result = pool.get(source.getWidth(), source.getHeight(), Bitmap.Config.ARGB_8888); Canvas canvas = new Canvas(result); Paint paint = new Paint(); paint.setShader(new BitmapShader(source, BitmapShader.TileMode.CLAMP, BitmapShader.TileMode.CLAMP)); paint.setAntiAlias(true); RectF rectF = new RectF(0f, 0f, source.getWidth(), source.getHeight()); canvas.drawRoundRect(rectF, radius, radius, paint); return result; } @Override public boolean equals(Object o) { return o instanceof GlideRoundTransform; } @Override public int hashCode() { return ID.hashCode(); } @Override public void updateDiskCacheKey(MessageDigest messageDigest) { messageDigest.update(ID.getBytes()); } } 其中equals(),hashCode(),updateDiskCacheKey主要是为了缓存和存储的正常工作 GlideExtension(扩展API)GlideOption/** * If you have any questions, you can contact by email {wangzhumoo@gmail.com} * @author 王诛魔 2018/8/9 下午2:57 * 支持快捷使用圆角图片 */ @GlideExtension public final class RoundGlideExtension { private RoundGlideExtension(){ } /** * 给url添加参数 * @param options RequestOptions */ @GlideOption public static void round(RequestOptions options,int corner){ options.transform(new GlideRoundTransform(corner)); } /** * 给url添加参数 * @param options RequestOptions */ @GlideOption public static void round(RequestOptions options){ options.transform(new GlideRoundTransform()); } } 添加@GlideExtension注解 私有构造 静态方法,以及@GlideOption注解 //通过 GlideApp.with(context).load(url).apply(options).round(); // or GlideApp.with(context).load(url).apply(options).round(corner); //来加载圆角图片 GlideType允许你添加对新的资源类型的支持，包括指定默认选项。 暂时没有使用. 总结下一期,我们做一个带进度条的图片加载.","categories":[{"name":"Android","slug":"Android","permalink":"https://www.wangzhumo.com/categories/Android/"}],"tags":[{"name":"Android","slug":"Android","permalink":"https://www.wangzhumo.com/tags/Android/"}]},{"title":"Android中使用注解笔记","slug":"annotation-simple-note","date":"2018-08-09T02:26:42.000Z","updated":"2019-12-22T12:04:34.312Z","comments":true,"path":"2018/08/09/annotation-simple-note/","link":"","permalink":"https://www.wangzhumo.com/2018/08/09/annotation-simple-note/","excerpt":"前言@Override 就是一个很常见的注解. 检查是否正确的复写父类方法 标志是重写方法 元注解 元注解是,额,嗯 注解的注解 @Retention：注解生命周期 @Target：作用范围 @Inherited：标明所修饰的注解类型是被继承的,子类会继承这个注解 @Documented：javadoc 这些都是由Java语言本身提供的最基础的注解,他们负责注解其他的注解,具体的作用见上文","text":"前言@Override 就是一个很常见的注解. 检查是否正确的复写父类方法 标志是重写方法 元注解 元注解是,额,嗯 注解的注解 @Retention：注解生命周期 @Target：作用范围 @Inherited：标明所修饰的注解类型是被继承的,子类会继承这个注解 @Documented：javadoc 这些都是由Java语言本身提供的最基础的注解,他们负责注解其他的注解,具体的作用见上文 自定义注解运行时注解(RUNTIME)/** * If you have any questions, you can contact by email {wangzhumoo@gmail.com} * @author 王诛魔 2018/8/9 上午10:50 * * 标记字段为imageUrl,图片地址 */ @Retention(RetentionPolicy.RUNTIME) @Target(ElementType.FIELD) public @interface ImageUrl { String error() default &quot;http://wangzhumo.com/css/images/avatar.png&quot;; } /** * If you have any questions, you can contact by email {wangzhumoo@gmail.com} * @author 王诛魔 2018/8/9 上午10:48 * * 标记字段为Content,内容 */ @Retention(RetentionPolicy.RUNTIME) @Target(ElementType.FIELD) public @interface Content { } @ImageUrl 与 @Content 中都没有什么方法,这里只是使用标记的功能 为了体现标记的作用 /** * If you have any questions, you can contact by email {wangzhumoo@gmail.com} * * @author 王诛魔 2018/8/9 上午10:47 */ public class Whatever { public String haha; //瞎写的字段名,标记为正文 @Content public String aaaa; //瞎写的字段名,标记为图片地址 @ImageUrl(error = &quot;http://wangzhumo.com/images/java_heap_stack.png&quot;) public String bajkfhajks; public String waht; /** * 自动生产 * * @return List */ public static List&lt;Whatever&gt; create() { List&lt;Whatever&gt; whatever = new ArrayList&lt;&gt;(); for (int i = 0; i &lt; 10; i++){ //开始建立 if (i==3){ whatever.add(new Whatever(String.format(Locale.CHINA,&quot;第%d个项目&quot;,i),&quot;&quot;)); }else{ whatever.add(new Whatever(String.format(Locale.CHINA,&quot;第%d个项目&quot;,i),&quot;http://wangzhumo.com/css/images/avatar.png&quot;)); } } return whatever; } } 在RecyclerView中使用 com.wangzhumo.playground.SimpleAdapter#onBindViewHolder @Override public void onBindViewHolder(@NonNull ViewHolder holder, int position) { try { for (Field field : getItem(position).getClass().getDeclaredFields()) { field.setAccessible(true); if (field.isAnnotationPresent(Content.class)) { holder.bindView.setContext((String) field.get(getItem(position))); } else if (field.isAnnotationPresent(ImageUrl.class)) { String imageUrl = (String) field.get(getItem(position)); if (TextUtils.isEmpty(imageUrl)) { ImageUrl url = field.getAnnotation(ImageUrl.class); holder.bindView.setImageUrl(url.error()); }else{ holder.bindView.setImageUrl(imageUrl); } } } } catch (IllegalAccessException e) { e.printStackTrace(); } } TextUtils.isEmpty(imageUrl)简单的判断,是否设置了值,如果它没有值,那就直接使用 url.error() 中设置的值 在生成数据时,我给第4个位置的图片设置了&quot;&quot;空值,则这里直接显示了我 @ImageUrl( error = “xxxxx”)中设置的图片 如果我改造一下,设置GlideApp.with(imageUrl ).error(@ImageUrl.error()) 可以成为一个很实用的方法 编译时注解(CLASS)对于我个人来说,基本上没有这样的需要,但是如Dagger2 使用编译时注解 + APT 实现依赖注入 其他如ARouter,BufferKnike,Glide也会使用这样的技术. 如Glide package com.bumptech.glide.annotation.compiler; // public final class GlideAnnotationProcessor extends AbstractProcessor{ @Override public synchronized void init(ProcessingEnvironment processingEnvironment) { super.init(processingEnvironment); //... //主要是初始化一些工具类啊什么的 } @Override public Set&lt;String&gt; getSupportedAnnotationTypes() { //... //该方法中返回所有注解的类 } @Override public SourceVersion getSupportedSourceVersion() { return SourceVersion.latestSupported(); } @Override public boolean process(Set&lt;? extends TypeElement&gt; set, RoundEnvironment env) { //... //这里是重要的部分,通过注释我们就能知道它大概做什么了 } } 遍历得到需要解析的元素列表 判断符合要求的元素 修改,整理输出参数,或者借助APT生产代码等 如果你对这部分感兴趣,不妨选一个库看看","categories":[{"name":"Java","slug":"Java","permalink":"https://www.wangzhumo.com/categories/Java/"}],"tags":[{"name":"Java","slug":"Java","permalink":"https://www.wangzhumo.com/tags/Java/"}]},{"title":"LeetCode-罗马数字转整数","slug":"roman-to-integer","date":"2018-08-06T08:36:46.000Z","updated":"2019-12-22T12:07:09.901Z","comments":true,"path":"2018/08/06/roman-to-integer/","link":"","permalink":"https://www.wangzhumo.com/2018/08/06/roman-to-integer/","excerpt":"给定一个罗马数字，将其转换成整数。输入确保在 1 到 3999 的范围内。 示例 1: 输入: &quot;III&quot; 输出: 3 前言这一题其实不在于算法有多难,而是在于你对于这个罗马数字与整形之间的关系要搞清楚 基本字符 I V X L C D M 相应的阿拉伯数字表示为 1 5 10 50 100 500 1000 上面是他们之间的对应关系,但是这还不够(以下来自百度百科)","text":"给定一个罗马数字，将其转换成整数。输入确保在 1 到 3999 的范围内。 示例 1: 输入: &quot;III&quot; 输出: 3 前言这一题其实不在于算法有多难,而是在于你对于这个罗马数字与整形之间的关系要搞清楚 基本字符 I V X L C D M 相应的阿拉伯数字表示为 1 5 10 50 100 500 1000 上面是他们之间的对应关系,但是这还不够(以下来自百度百科) 相同的数字连写，所表示的数等于这些数字相加得到的数,如:Ⅲ = 3 小的数字在大的数字的右边，所表示的数等于这些数字相加得到的数, 如:Ⅷ = 8; Ⅻ = 12 小的数字,(限于Ⅰ、X 和C)在大的数字的左边，所表示的数等于大数减小数得到的数,如:Ⅳ= 4; Ⅸ= 9 正常使用时,连写的数字重复不得超过三次 在一个数的上面画一条横线,表示这个数扩大1000倍 思路 需要一个键值对来保存罗马数字与整形的关系 遍历,并比较前一个罗马字符与当前罗马字符的大小 当前罗马字符更大,则+= 当前小,则-= 输出结果 代码实现/** * If you have any questions, you can contact by email {wangzhumoo@gmail.com} * * @author 王诛魔 2018/8/7 下午5:41 * 给定一个罗马数字，将其转换成整数。输入确保在 1 到 3999 的范围内。 * * 示例 1: * * 输入: &quot;III&quot; * 输出: 3 * */ public class RomanToIntClass { private static HashMap&lt;Character, Integer&gt; contrastMap; static { contrastMap = new HashMap&lt;&gt;(); contrastMap.put(&#39;I&#39;, 1); contrastMap.put(&#39;V&#39;, 5); contrastMap.put(&#39;X&#39;, 10); contrastMap.put(&#39;L&#39;, 50); contrastMap.put(&#39;C&#39;, 100); contrastMap.put(&#39;D&#39;, 500); contrastMap.put(&#39;M&#39;, 1000); } /** * 罗马转整形 * @param romanStr 罗马字符串 * @return 整数 */ public static int romanToInt(String romanStr){ char[] romanCharArray = romanStr.toCharArray(); int result = 0; for (int i = 0; i &lt; romanCharArray.length; i++) { //遍历这个罗马数组 if (i == romanCharArray.length -1 || contrastMap.get(romanCharArray[i+1]) &lt;= contrastMap.get(romanCharArray[i])){ //如果满足,说明当前的这个罗马字符是大于后一个罗马数字的,则应该加上当前的罗马字符 result += contrastMap.get(romanCharArray[i]); }else{ //则是前面小,后面大,应该减去当前的这个罗马字符 result -= contrastMap.get(romanCharArray[i]); } } return result; } } 结果输入: MCMXCIV 输出: 1994 Process finished with exit code 0","categories":[{"name":"Programme","slug":"Programme","permalink":"https://www.wangzhumo.com/categories/Programme/"}],"tags":[{"name":"Programme","slug":"Programme","permalink":"https://www.wangzhumo.com/tags/Programme/"}]},{"title":"算法复习笔记-快速排序","slug":"Arithmetic-quick-sort","date":"2018-07-31T10:04:11.000Z","updated":"2019-12-22T12:04:54.504Z","comments":true,"path":"2018/07/31/Arithmetic-quick-sort/","link":"","permalink":"https://www.wangzhumo.com/2018/07/31/Arithmetic-quick-sort/","excerpt":"前言通过一趟排序将要排序的数据分割成独立的两部分,其中一部分的所有数据都比另外一部分的所有数据都要小,然后再按此方法对这两部分数据分别进行快速排序,整个排序过程可以递归进行,以此达到整个数据变成有序序列。 快速排序由 C. A. R. Hoare（东尼霍尔，Charles Antony Richard Hoare）在1960年提出 .而后经过很多人,很长时间的优化,才得到现在的版本.快速排序可以说是一个至关重要的算法了,现在的很多语言基础库中的排序,就是使用的快速排序算法来完成的.","text":"前言通过一趟排序将要排序的数据分割成独立的两部分,其中一部分的所有数据都比另外一部分的所有数据都要小,然后再按此方法对这两部分数据分别进行快速排序,整个排序过程可以递归进行,以此达到整个数据变成有序序列。 快速排序由 C. A. R. Hoare（东尼霍尔，Charles Antony Richard Hoare）在1960年提出 .而后经过很多人,很长时间的优化,才得到现在的版本.快速排序可以说是一个至关重要的算法了,现在的很多语言基础库中的排序,就是使用的快速排序算法来完成的. 思考这里我打算使用前后指针的方法来完成快速排序.定义两个指针,一个curr指向数组的第一个元素,而pre指向的是curr-1的位置. 定义curr以及pre两个指针 当array[curr] &lt; key 则curr与pre指针同时向后移动 当array[curr] &gt; key 则curr向后移动一位,pre保持不动(当前这个位置的值是小于key的) 当array[curr] &lt; key 则需要交换array[curr]以及array[pre] 可以这么说,每次找到array[curr] 这个位置的元素比key要小,说明它不应该在当前的这个位置,需要和pre的位置元素交换,应为pre一直是指向了最后一个小于key的元素位置 看上图所示,序号5的这一排,我用框分出了三个部分. 绿色区域[0,pre] 都是小于key的 红色区域[pre+1,curr)都是大于key的 而橙色的区域[curr,right]都是没有经过比较的区域 那么很容易就可以看出,其实我们就是想让这个数组,以pre为分界点,左面的都小于key,而右面的都大于 那么,只要发现array[curr] &lt; key 直接和array[pre+1]交换位置,还是满足上面的要求的. 代码实现/** * If you have any questions, you can contact by email {wangzhumoo@gmail.com} * @author 王诛魔 2018/7/31 下午5:54 * 快速排序[left,right) */ public class QuickClass{ //为了给分割数组的方法使用,用于选出一个key private static Random mRandom = new Random(System.currentTimeMillis()); /** * 快速排序入口-前后指针 * * @param array 要排序的数组 * @param left 左边界 * @param right 右边界 */ public static void quickSort(int[] array, int left, int right) { //如果left &gt;= right了,说明这个数组已经不能再继续分了 if (left &gt;= right) return; //此处找到这个p,分割点,需要经过一轮的快速排序 int p = partition(array, left, right); //递归调用 quickSort(array, left, p); quickSort(array, p + 1, right); } /** * 分割数组 * 排序array[left , right] 的顺序 * 使得返回一个p ,在 array[left,p] 都小于k 在array[p+1 , right)都大于k * * @param array 要排序的数组 * @param left 左边边界 * @param right 右边边界 * @return p 分割了两个数组的位置 */ private static int partition(int[] array, int left, int right) { //随机替换一个元素到key的位置,这是为了避免如果排列一个近乎有序的数组时, //造成一侧的子数组特多,而另一侧则很少,使得效率降低 swap(array,left,mRandom.nextInt(right - left + 1) + left); //拿出key int key = array[left]; //定义一个pre等于curr-1 //为什么直接赋值为left那?因为left是我key的位置, //可以直接不用比较,curr = pre+1即是第一个要比较的元素 int pre = left; for(int curr = pre+1;curr &lt;= right;curr++){ //此时判断 array[curr] 与 key的关系即可 if(array[curr] &lt; key){ swap(array,curr, ++pre); } } //完成后需要把key元素移动到pre的位置去 swap(array,left,pre); return pre; } /** * 交换位置 * * @param arr 数组 * @param a * @param b */ private static void swap(int[] arr, int a, int b) { int temp = arr[a]; arr[a] = arr[b]; arr[b] = temp; } } 总结这还只是快速排序的最简单方法,还有更为复杂一些的三路快排等,后面继续学习 测试打印: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21","categories":[{"name":"Programme","slug":"Programme","permalink":"https://www.wangzhumo.com/categories/Programme/"}],"tags":[{"name":"Programme","slug":"Programme","permalink":"https://www.wangzhumo.com/tags/Programme/"}]},{"title":"算法复习笔记-归并排序","slug":"Arithmetic-merge-sort","date":"2018-07-31T08:24:50.000Z","updated":"2019-12-22T12:12:04.759Z","comments":true,"path":"2018/07/31/Arithmetic-merge-sort/","link":"","permalink":"https://www.wangzhumo.com/2018/07/31/Arithmetic-merge-sort/","excerpt":"前言归并排序可以说是一个经典的使用分治思维的排序算法了. 先把问题分为一些小的问题然后递归求解,而使用治的思想把分阶段求得的答案合并在一起.","text":"前言归并排序可以说是一个经典的使用分治思维的排序算法了. 先把问题分为一些小的问题然后递归求解,而使用治的思想把分阶段求得的答案合并在一起. 首先我得来一张图说明这个事: 上图显示了一个输入数组被分解的过程,下面只要我们能给他合并起来就可以完成这是输入数组的排序了 合并思路合并的时候我们需要一个临时数组的帮助,这个临时数组的大小应该是与输入数组的大小一致的. int[] array,int left,int mid,int right,int [] tempArray 需要传入 需要排序的数组,左数组的左边界, 左数组的右边界 ,右数组右边界,临时数组 遍历左右数组,直至两个数组至少有一个数组全部遍历一次 =&gt; 左数组当前index &lt;= mid &amp;&amp; 右数组当前index &lt;= right 比较左右两个数组中元素的大小. 分为两种情况: 左数组当前元素 &lt;= 右边数组当前元素 交换tempArray当前位置 与 左数组当前元素 tempArray 的index ++ ,因为这一个位置已经确定了,应该确定下一个元素了 左边当前元素index ++ ,这个元素已经比较过了,应该移动到下一个位置与右数组元素比较 右边当前元素更大 交换tempArray当前位置 与 右数组当前元素 tempArray 的index ++ 右边当前元素index ++ 当上面的循环完成后,还有一种可能是,右边或左边的数组中还有元素没有参与比较 =&gt; 因为这些剩下的元素都比另一个数组中元素大,而这个数组本身也是有序的则 =&gt; 把这些剩下的元素全部追加到tempArray 最后我们发现,tempArray已经是一个有序的数组了,但是我们要排序的是array =&gt; 把tempArray中元素全部复制给array 代码实现/** * If you have any questions, you can contact by email {wangzhumoo@gmail.com} * @author 王诛魔 2018/7/31 下午4:26 * 归并排序 */ public class MergeClass { /** * 归并排序 * * @param array 需要排序的数组 * @param left 左边界 * @param right 右边界 * @param tempArray 临时数组,避免频繁创建数组 */ public static void MergeSort(int[] array,int left,int right,int [] tempArray){ mergeSort(array, left, right, tempArray); } public static void mergeSort(int[] array,int left,int right,int [] tempArray){ //通过观察上图,我们可以知道,如果 left &gt;= right //就是最小的数组了,所以要停止递归,开始返回 if(left &gt;= right){ return; } //计算当前传入数组的中点,用来把数组分成两个部分,这里注意避免int越界 int mid = left + (right - left) / 2 ; //递归调用左右数组 //左边数组 [left , mid] mergeSort(array, left, mid, tempArray); //右边数组 (mid,right] mergeSort(array, mid + 1 , right , tempArray); //合并这个数组,需要原始数组,临时数组,左右边界以及mid(这是为了计算右边数组的开始index) merge(array,left,mid,right,tempArray); } /** * 合并数组 * * @param array * @param left * @param mid * @param right * @param tempArray */ public static void merge(int[] array,int left,int mid,int right,int [] tempArray){ //为了后面的操作,先定义好几个边界值 int i = left; //左数组index开始位置 int j = mid + 1; //右数组idnex开始位置 int temp = 0; //临时数组index的开始位置 //1.循环 while(i &lt;= mid &amp;&amp; j &lt;= right){ //2.比较大小 if(array[i] &lt;= array[j]){ //合并赋值与index ++ tempArray[temp++] = array[i++]; }else{ tempArray[temp++] = array[j++]; } } //3.剩余元素 while(i &lt;= mid){ tempArray[temp++] = array[i++]; } while(j &lt;= right){ tempArray[temp++] = array[j++]; } //4.复制回array temp = 0; while(left &lt;= right){ array[left++] = tempArray[temp++]; } } } 最后测试了一下,没问题 13 21 23 26 45 67 123 213 456 563","categories":[{"name":"Programme","slug":"Programme","permalink":"https://www.wangzhumo.com/categories/Programme/"}],"tags":[{"name":"Programme","slug":"Programme","permalink":"https://www.wangzhumo.com/tags/Programme/"}]},{"title":"ConstraintLayout使用指南-进阶使用","slug":"ConstraintLayout-Advance","date":"2018-07-30T06:54:45.000Z","updated":"2019-12-22T12:11:36.552Z","comments":true,"path":"2018/07/30/ConstraintLayout-Advance/","link":"","permalink":"https://www.wangzhumo.com/2018/07/30/ConstraintLayout-Advance/","excerpt":"前言ConstraintLayout使用指南-基础的约束 通过上一篇的了解,大概已经知道ConstraintLayout的基本功能了,但是对于我们日常的开发工作,还是有一定的差距,所以这一篇,主要记录一些开发中用到的进阶功能. 行了,接上文的纵横比,上代码","text":"前言ConstraintLayout使用指南-基础的约束 通过上一篇的了解,大概已经知道ConstraintLayout的基本功能了,但是对于我们日常的开发工作,还是有一定的差距,所以这一篇,主要记录一些开发中用到的进阶功能. 行了,接上文的纵横比,上代码 开发中实例参照线(Guidelines) 本来以为很高端 public class Guideline extends View{ 构造函数{ super.setVisibility(8); } public void setVisibility(int visibility) { } public void draw(Canvas canvas) { } } 哈哈,就是一个VIew,不绘制在界面上而已. &lt;android.support.constraint.Guideline android:id=&quot;@+id/guideline&quot; android:layout_width=&quot;wrap_content&quot; android:layout_height=&quot;wrap_content&quot; app:layout_constraintGuide_begin=&quot;127dp&quot; //这里是指从右边开使,偏移127dp app:layout_constraintGuide_end=&quot;127dp&quot; //这里是指从左边开使,偏移127dp app:layout_constraintGuide_percent=&quot;0.5&quot; //在整个布局的50%处,也就是居中 android:orientation=&quot;vertical&quot;/&gt; //线的类型是,垂直 那么,我们可以将其他控件附着在它上面,一起布局移动 Chain 链这玩意可厉害了,就比权重什么的强了有1000倍吧 比如我想把下图这样的三个控件平分整个布局宽度 正常的操作是,用一个LinearLayout设置权重 如果我们使用ConstraintLayout会更加简单,而且功能更多 &lt;layout xmlns:app=&quot;http://schemas.android.com/apk/res-auto&quot; xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;&gt; &lt;android.support.constraint.ConstraintLayout android:id=&quot;@+id/rootView&quot; android:background=&quot;@android:color/white&quot; android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;match_parent&quot;&gt; &lt;ImageView android:layout_width=&quot;wrap_content&quot; android:layout_height=&quot;wrap_content&quot; app:srcCompat=&quot;@mipmap/ic_launcher&quot; android:id=&quot;@+id/imageView2&quot; app:layout_constraintStart_toStartOf=&quot;parent&quot; app:layout_constraintEnd_toStartOf=&quot;@+id/imageView3&quot; app:layout_constraintHorizontal_chainStyle=&quot;spread_inside&quot;/&gt; &lt;ImageView android:layout_width=&quot;wrap_content&quot; android:layout_height=&quot;wrap_content&quot; app:srcCompat=&quot;@mipmap/ic_launcher&quot; android:id=&quot;@+id/imageView3&quot; app:layout_constraintStart_toEndOf=&quot;@+id/imageView2&quot; app:layout_constraintEnd_toStartOf=&quot;@+id/imageView4&quot;/&gt; &lt;ImageView android:layout_width=&quot;wrap_content&quot; android:layout_height=&quot;wrap_content&quot; app:srcCompat=&quot;@mipmap/ic_launcher&quot; android:id=&quot;@+id/imageView4&quot; app:layout_constraintStart_toEndOf=&quot;@+id/imageView3&quot; app:layout_constraintEnd_toEndOf=&quot;parent&quot;/&gt; &lt;/android.support.constraint.ConstraintLayout&gt; &lt;/layout&gt; 你可能会说,这么多layout_constraintStart_toEndOf 什么的,明明更麻烦 操作步骤 选中一个控件 框选所有要组成Chain的控件 添加Chain 还能看到我点击了一个 链接 按钮,他们三个的布局又发生了变化 chainStyle这是由chainStyle的改变造成的 app:layout_constraintHorizontal_chainStyle=&quot;spread_inside&quot; spread(默认的模式) 平分间隙让多个 View 布局到剩余空间 spread_inside 边缘的两个 View 紧贴父控件边缘,剩余的 View 在剩余的空间内平分间隙布局 packed 所有的Views打包居中,相互没有间隔 要注意的是spread还有两个强大的东西 如果我把三个控件的width设置为 0dp会这样: 如果你想让他们几个控件按比例平分: 可以添加该属性 app:layout_constraintHorizontal_weight = &quot;0.3&quot; 这是我设置的 0.3 : 0.2 : 0.5 覆盖父控件&lt;ImageView android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;200dp&quot; app:srcCompat=&quot;@drawable/ic_launcher_background&quot; android:id=&quot;@+id/imageView5&quot; android:scaleType=&quot;fitXY&quot; app:layout_constraintStart_toStartOf=&quot;parent&quot; app:layout_constraintEnd_toEndOf=&quot;parent&quot; app:layout_constraintTop_toTopOf=&quot;parent&quot; tools:ignore=&quot;VectorDrawableCompat&quot;/&gt; &lt;ImageView android:id=&quot;@+id/imageView7&quot; android:layout_width=&quot;40dp&quot; android:layout_height=&quot;40dp&quot; app:srcCompat=&quot;@mipmap/icon_youtube&quot; tools:layout_editor_absoluteX=&quot;160dp&quot; app:layout_constraintBottom_toBottomOf=&quot;@+id/imageView5&quot; app:layout_constraintTop_toBottomOf=&quot;@+id/imageView5&quot;/&gt; 主要关注这两句 app:layout_constraintBottom_toBottomOf=&quot;@+id/imageView5&quot; app:layout_constraintTop_toBottomOf=&quot;@+id/imageView5&quot; 我们的imageView7 吧它的上下都指定了位于 imageView5的下底边. 百分比布局app:layout_constraintHorizontal_bias=&quot;0.3&quot; 用好这个属性和 GuideLine即可 未完待续..后面有用的,会继续添加到这里","categories":[{"name":"Android","slug":"Android","permalink":"https://www.wangzhumo.com/categories/Android/"}],"tags":[{"name":"Android","slug":"Android","permalink":"https://www.wangzhumo.com/tags/Android/"}]},{"title":"今日头条的屏幕适配方案","slug":"Screen-toutiao-resize","date":"2018-07-30T06:16:26.000Z","updated":"2019-12-22T12:06:45.760Z","comments":true,"path":"2018/07/30/Screen-toutiao-resize/","link":"","permalink":"https://www.wangzhumo.com/2018/07/30/Screen-toutiao-resize/","excerpt":"前言 今日头条传送门: https://mp.weixin.qq.com/s/d9QCoBP6kV9VSWvVldVVwA 现在Android端的适配方案也是五花八门的,但就是这样,我们的UI设计师们还觉得和他们的设计图不一致,我真的是服了他们的像素眼. 今日头条的这个适配方案,可以说是取巧到一个妙啊的水平了.","text":"前言 今日头条传送门: https://mp.weixin.qq.com/s/d9QCoBP6kV9VSWvVldVVwA 现在Android端的适配方案也是五花八门的,但就是这样,我们的UI设计师们还觉得和他们的设计图不一致,我真的是服了他们的像素眼. 今日头条的这个适配方案,可以说是取巧到一个妙啊的水平了. 思路android.util.TypedValue#applyDimension public static float applyDimension(int unit, float value, DisplayMetrics metrics) { switch (unit) { case COMPLEX_UNIT_PX: return value; case COMPLEX_UNIT_DIP: return value * metrics.density; case COMPLEX_UNIT_SP: return value * metrics.scaledDensity; case COMPLEX_UNIT_PT: return value * metrics.xdpi * (1.0f/72); case COMPLEX_UNIT_IN: return value * metrics.xdpi; case COMPLEX_UNIT_MM: return value * metrics.xdpi * (1.0f/25.4f); } return 0; } 这一段就是,系统来调用,以便缩放调整自己的大小,满足对应屏幕大小的代码了. 主要看COMPLEX_UNIT_PX,COMPLEX_UNIT_DIP ,COMPLEX_UNIT_SP这三个case 因为我们开发的过程中,也主要是用了这三种单位,尤其是DIP,很多时候我们会把字体的大小也用DIP这个单位来写. value * metrics.density 通过观察我们可以发现,都是value * DisplayMetrics.常量 那么我要是能把DisplayMetrics里面的这个常量值改了,是不是就可以为所欲为了? public float density; //... public float scaledDensity; 幸福来得太突然,这几个常量都是 public 而且非 final的. 具体实现举例说明我最近做了一个大屏的项目,使得是960dp,看看这个公式 我的这个屏幕宽度是 3000px,他的宽度是960dp case COMPLEX_UNIT_DIP: return value * metrics.density; 带入公式 3000px = density * 960dp =&gt; 则 density = 3000 / 960 =&gt; 则 density = 屏幕真实宽度 / 设计图宽度(dp) 那么下面直接贴代码了 /** * If you have any questions, you can contact by email {wangzhumoo@gmail.com} * * @author 王诛魔 2018/6/25 下午5:17 * * 今日头条的屏幕适配方案: * 修改density值,强行把所有不同尺寸分辨率的手机的宽度dp值改成同一个值 */ public class ResizeDensity { private static float sNoncompatDensity; private static float sNoncompatScaledDensity; /** * * @param activity activity * @param application application */ public static void setCustomDensity(@NonNull Activity activity, @NonNull final Application application) { DisplayMetrics appDisplayMetrics = application.getResources().getDisplayMetrics(); if (sNoncompatDensity == 0) { sNoncompatDensity = appDisplayMetrics.density; sNoncompatDensity = appDisplayMetrics.scaledDensity; application.registerComponentCallbacks(new ComponentCallbacks() { @Override public void onConfigurationChanged(Configuration newConfig) { if (newConfig != null &amp;&amp; newConfig.fontScale &gt; 0) { sNoncompatScaledDensity = application.getResources().getDisplayMetrics().scaledDensity; } } @Override public void onLowMemory() { } }); } float targetDensity = appDisplayMetrics.widthPixels / 960; float targetScaleDensity = targetDensity * (sNoncompatScaledDensity / sNoncompatDensity); int targetDensityDpi = (int) (160 * targetDensity); appDisplayMetrics.density = targetDensity; appDisplayMetrics.scaledDensity = targetScaleDensity; appDisplayMetrics.densityDpi = targetDensityDpi; final DisplayMetrics activityDisplayMetrics = activity.getResources().getDisplayMetrics(); activityDisplayMetrics.density = targetDensity; activityDisplayMetrics.scaledDensity = targetScaleDensity; activityDisplayMetrics.densityDpi = targetDensityDpi; } } 总结直接在Activity中去调用就可以达到效果了. 今日头条发现的一个小问题: 但是测试后发现另外一个问题，就是如果在系统设置中切换字体，再返回应用，字体并没有变化。于是还得监听下字体切换，调用 Application#registerComponentCallbacks 注册下 onConfigurationChanged 监听即可。 阅读源码…读源码…源码…","categories":[{"name":"Android","slug":"Android","permalink":"https://www.wangzhumo.com/categories/Android/"}],"tags":[{"name":"Android","slug":"Android","permalink":"https://www.wangzhumo.com/tags/Android/"}]},{"title":"Android事件分发机制-ViewGroup","slug":"Android-MotionEvent-ViewGroup","date":"2018-07-30T04:20:02.000Z","updated":"2019-12-22T12:03:43.376Z","comments":true,"path":"2018/07/30/Android-MotionEvent-ViewGroup/","link":"","permalink":"https://www.wangzhumo.com/2018/07/30/Android-MotionEvent-ViewGroup/","excerpt":"总览什么是事件分发就是将系统传递过来的MotionEvent分发到某个具体的View,并处理这个MotionEvent的整个过程 我们先要明白 责任链模式 ViewGroup和View的树形结构 一次完整的MotionEvent事件(ACTION_DOWN , ACTION_MOVE , ACTION_UP)","text":"总览什么是事件分发就是将系统传递过来的MotionEvent分发到某个具体的View,并处理这个MotionEvent的整个过程 我们先要明白 责任链模式 ViewGroup和View的树形结构 一次完整的MotionEvent事件(ACTION_DOWN , ACTION_MOVE , ACTION_UP) 主要方法 boolean dispatchTouchEvent(MotionEvent ev) 这个方法是分发点击事件的方法,只要这个点击事件能传递到当前的控件,就会调用这个方法 boolean onInterceptTouchEvent(MotionEvent ev) 是否要拦截这个事件?要明白的是,View是没有这个方法的,因为View是最下层的,没有资格去拦截. 它要么消费事件,要么不消费返回它的父控件,而不是自己拦截掉事件. boolean onTouchEvent(MotionEvent event) 处理点击事件,ViewGroup的dispatchTouchEvent方法会调用这个方法. 主要参与成员 Activity 我们要明白,一个事件在物理硬件层产生后,是由系统的输入系统处理,然后经过其传递通道(如果深入了解,我们可以知道,其底层是由一个双向的Socket来做到的),传递到UI线程,Activity是第一个拿到这个事件的,但是它并不能处理这个事件,所以Activity必须把这个事件分发下去,而不会自己处理. ViewGroup 它与View最大的不同在于,虽然它也是View的子类,但是它可能还管理着其他ViewGroup &amp; View,所以它是有所有的三个方法的. View 既是所有控件的父类,也是我们说的最基本的控件,它只能选择处理或不处理事件,没有其他操作了. 阅读源码Activity#dispatchTouchEventpublic boolean dispatchTouchEvent(MotionEvent ev) { if (ev.getAction() == MotionEvent.ACTION_DOWN) { onUserInteraction(); //空方法,不看 } //查看superDispatchTouchEvent发现是一个抽象方法,那么我们去找它的实现类 if (getWindow().superDispatchTouchEvent(ev)) { return true; } //直接调用了onTouchEvent() return onTouchEvent(ev); } =&gt; Window 的实现类,现在只有一个 PhoneWindow @Override public boolean superDispatchTouchEvent(MotionEvent event) { return mDecor.superDispatchTouchEvent(event); //那么我们知道mDecor是DecorView,它继承了FrameLayout并且是TitleView 和 ContextView的容器 } //DecorView的superDispatchTouchEvent方法 public boolean superDispatchTouchEvent(MotionEvent event) { return super.dispatchTouchEvent(event); } 很明显的,我们知道这个super是指的DecorView的父类ViewGroup android.view.ViewGroup#dispatchTouchEvent ViewGroup#dispatchTouchEvent这个代码长到爆炸 @Override public boolean dispatchTouchEvent(MotionEvent ev) { //...省略 //搜了半天才知道,mInputEventConsistencyVerifier调试用的,连带辅助功能的都省略了 boolean handled = false; //onFilterTouchEventForSecurity 这个方法是View中的,如果false就要丢弃事件 //第一步 : //如果是ture才继续来处理这个事件,其实就是Window是否被遮盖的值 if (onFilterTouchEventForSecurity(ev)) { final int action = ev.getAction(); final int actionMasked = action &amp; MotionEvent.ACTION_MASK; // Handle an initial down. if (actionMasked == MotionEvent.ACTION_DOWN) { //第二步 : //这里清除掉了所有之前的状态, //1. clearTouchTargets() 看起来是清空了一个保存需要接受事件View的链表 // mFirstTouchTarget链表初始化 //2.mGroupFlags &amp;= ~FLAG_DISALLOW_INTERCEPT; // 这个标记意为:不允许ViewGroup对触摸事件进行拦截 cancelAndClearTouchTargets(ev); resetTouchState(); } final boolean intercepted; //第三步: //检查当前ViewGroup是否想要拦截触摸事件,并把值写入intercepted返回 if (actionMasked == MotionEvent.ACTION_DOWN || mFirstTouchTarget != null) { //这个标志位通过requestDisallowInterceptTouchEvent来设置 final boolean disallowIntercept = (mGroupFlags &amp; FLAG_DISALLOW_INTERCEPT) != 0; if (!disallowIntercept) { //如果不禁用拦截事件,则调用onInterceptTouchEvent(ev); //并且返回onInterceptTouchEvent的返回值给intercepted intercepted = onInterceptTouchEvent(ev); ev.setAction(action); // restore action in case it was changed } else { intercepted = false; } } else { // There are no touch targets and this action is not an initial down // so this view group continues to intercept touches. intercepted = true; } //...省略 //第四步,检查是否取消了事件 final boolean canceled = resetCancelNextUpFlag(this) || actionMasked == MotionEvent.ACTION_CANCEL; // 第五步,把事件canceled,intercepted 既没有被取消,也没有被拦截的时候 // 把事件分发到它的子View中去 final boolean split = (mGroupFlags &amp; FLAG_SPLIT_MOTION_EVENTS) != 0; TouchTarget newTouchTarget = null; boolean alreadyDispatchedToNewTouchTarget = false; if (!canceled &amp;&amp; !intercepted) { //省略.. if (actionMasked == MotionEvent.ACTION_DOWN || (split &amp;&amp; actionMasked == MotionEvent.ACTION_POINTER_DOWN) || actionMasked == MotionEvent.ACTION_HOVER_MOVE) { final int actionIndex = ev.getActionIndex(); // always 0 for down final int idBitsToAssign = split ? 1 &lt;&lt; ev.getPointerId(actionIndex) : TouchTarget.ALL_POINTER_IDS; //清空这个idBitsToAssign之前的TouchTarget链表 removePointersFromTouchTargets(idBitsToAssign); //获取这个View的所有子View个数 final int childrenCount = mChildrenCount; if (newTouchTarget == null &amp;&amp; childrenCount != 0) { final float x = ev.getX(actionIndex); final float y = ev.getY(actionIndex); // Find a child that can receive the event. // Scan children from front to back. final ArrayList&lt;View&gt; preorderedList = buildTouchDispatchChildList(); final boolean customOrder = preorderedList == null &amp;&amp; isChildrenDrawingOrderEnabled(); final View[] children = mChildren; //第六步,执行事件分发 //我们可以看到这里是遍历所有的子View,并把 for (int i = childrenCount - 1; i &gt;= 0; i--) { final int childIndex = getAndVerifyPreorderedIndex( childrenCount, i, customOrder); final View child = getAndVerifyPreorderedView( preorderedList, children, childIndex); //省略... //这里判断,当前循环到的这个子View是否可点击,并且这个坐标 //在子View的可视范围内,如果都满足,则跳出判断继续执行下面的代码,如果 //不能满足条件,则continue,跳过这个View if (!canViewReceivePointerEvents(child) || !isTransformedTouchPointInView(x, y, child, null)) { ev.setTargetAccessibilityFocus(false); continue; } newTouchTarget = getTouchTarget(child); if (newTouchTarget != null) { // Child is already receiving touch within its bounds. // Give it the new pointer in addition to the ones it is handling. newTouchTarget.pointerIdBits |= idBitsToAssign; break; } resetCancelNextUpFlag(child); //我们可以看到,这里把事件分发下去了,给了当前的这个child if (dispatchTransformedTouchEvent(ev, false, child, idBitsToAssign)) { // Child wants to receive touch within its bounds. //如果能走到这里,则子View返回的肯定是ture,说明子View //消费 &amp; 拦截了这个事件 mLastTouchDownTime = ev.getDownTime(); if (preorderedList != null) { // childIndex points into presorted list, find original index for (int j = 0; j &lt; childrenCount; j++) { if (children[childIndex] == mChildren[j]) { mLastTouchDownIndex = j; break; } } } else { mLastTouchDownIndex = childIndex; } mLastTouchDownX = ev.getX(); mLastTouchDownY = ev.getY(); //ddTouchTarget()将child添加到mFirstTouchTarget newTouchTarget = addTouchTarget(child, idBitsToAssign); //设置alreadyDispatchedToNewTouchTarget为true alreadyDispatchedToNewTouchTarget = true; break; } // The accessibility focus didn&#39;t handle the event, so clear // the flag and do a normal dispatch to all children. ev.setTargetAccessibilityFocus(false); } if (preorderedList != null) preorderedList.clear(); } if (newTouchTarget == null &amp;&amp; mFirstTouchTarget != null) { // Did not find a child to receive the event. // Assign the pointer to the least recently added target. newTouchTarget = mFirstTouchTarget; while (newTouchTarget.next != null) { newTouchTarget = newTouchTarget.next; } newTouchTarget.pointerIdBits |= idBitsToAssign; } } } //以上,判断不被取消,不被拦截的方法完毕了 //第七步,继续分发事件 // Dispatch to touch targets. //这里注意看dispatchTransformedTouchEvent的第三个参数,是null //在该方法中,child这个参数为null,则是直接调用了super.dispatchTouchEvent(ev) if (mFirstTouchTarget == null) { // No touch targets so treat this as an ordinary view. handled = dispatchTransformedTouchEvent(ev, canceled, null, TouchTarget.ALL_POINTER_IDS); } else { // Dispatch to touch targets, excluding the new touch target if we already // dispatched to it. Cancel touch targets if necessary. TouchTarget predecessor = null; TouchTarget target = mFirstTouchTarget; while (target != null) { //TouchTarget 这里是一直在遍历这个链表,进行判断,事件分发 final TouchTarget next = target.next; if (alreadyDispatchedToNewTouchTarget &amp;&amp; target == newTouchTarget) { handled = true; } else { final boolean cancelChild = resetCancelNextUpFlag(target.child) || intercepted; if (dispatchTransformedTouchEvent(ev, cancelChild, target.child, target.pointerIdBits)) { handled = true; } if (cancelChild) { if (predecessor == null) { mFirstTouchTarget = next; } else { predecessor.next = next; } target.recycle(); target = next; continue; } } predecessor = target; target = next; } } //第八步 如果有必要,更新取消标记 // Update list of touch targets for pointer up or cancel, if needed. if (canceled || actionMasked == MotionEvent.ACTION_UP || actionMasked == MotionEvent.ACTION_HOVER_MOVE) { resetTouchState(); } else if (split &amp;&amp; actionMasked == MotionEvent.ACTION_POINTER_UP) { final int actionIndex = ev.getActionIndex(); final int idBitsToRemove = 1 &lt;&lt; ev.getPointerId(actionIndex); removePointersFromTouchTargets(idBitsToRemove); } } if (!handled &amp;&amp; mInputEventConsistencyVerifier != null) { mInputEventConsistencyVerifier.onUnhandledEvent(ev, 1); } return handled; } 我们不妨来梳理一下 第一步至第三步都是根据各种标记,是否可见等来判断是否需要分发这个事件. 从第四步开始,才是开始分发这个事件的代码,第五步判断是不是DOWN,MOVE事件,如果是就开始分发给每一个子View,同时把这个View添加到了mFirstTouchTarget这个链表中 而我们可以看到第七步,mFirstTouchTarget == null判断这个链表,如果不是null就继续分发事件,如果是null的话就直接回调父类的super.dispatchTouchEvent 这样我们可以得出一个结论: 如果一个View没有接收到DOWN事件,而后的事件它肯定也无法接收到. android.view.ViewGroup#dispatchTransformedTouchEvent private boolean dispatchTransformedTouchEvent(MotionEvent event, boolean cancel, View child, int desiredPointerIdBits) { final boolean handled; //省略... // Perform any necessary transformations and dispatch. if (child == null) { //如果子View为空,则把自己当做一个View来处理,这里是直接调用的View.dispatchTouchEvent handled = super.dispatchTouchEvent(transformedEvent); } else { final float offsetX = mScrollX - child.mLeft; final float offsetY = mScrollY - child.mTop; transformedEvent.offsetLocation(offsetX, offsetY); if (! child.hasIdentityMatrix()) { transformedEvent.transform(child.getInverseMatrix()); } //这里就很明白了,事件又传递到该ViewGroup的子View中去了 handled = child.dispatchTouchEvent(transformedEvent); } // Done. transformedEvent.recycle(); //返回 return handled; } android.view.ViewGroup#onInterceptTouchEvent public boolean onInterceptTouchEvent(MotionEvent ev) { if (ev.isFromSource(InputDevice.SOURCE_MOUSE) &amp;&amp; ev.getAction() == MotionEvent.ACTION_DOWN &amp;&amp; ev.isButtonPressed(MotionEvent.BUTTON_PRIMARY) &amp;&amp; isOnScrollbarThumb(ev.getX(), ev.getY())) { return true; } return false; } 注意看一下他的注释 Implement this method to intercept all touch screen motion events. 一般都是返回false的,如果你需要拦截所有的事件而不去分发,重写然后返回ture即可 而ViewGroup的onTouchEvent是直接走的View.onTouchEvent()总结 ViewGroup中dispatchTouchEvent()会把事件进行遍历传递 遍历它自己的所有子View,然后调用child的dispatchTouchEvent()来分发触摸事件 ViewGroup的某个子View没有接受ACTION_DOWN,则它再也不会被分发事件了 ViewGroup的onInterceptTouchEvent()默认返回false 也就是说,如果你需要自定义的ViewGroup拦截事件,直接重写返回false即可 ViewGroup的onTouchEvent 并没有自己的实现,直接调用其父类View的 下篇View走起","categories":[{"name":"View","slug":"View","permalink":"https://www.wangzhumo.com/categories/View/"}],"tags":[{"name":"Android","slug":"Android","permalink":"https://www.wangzhumo.com/tags/Android/"},{"name":"View","slug":"View","permalink":"https://www.wangzhumo.com/tags/View/"}]},{"title":"贝塞尔曲线练习-谷歌猜画小歌的倒计时","slug":"Bezier-Google-caihuaxiaoge","date":"2018-07-27T08:42:41.000Z","updated":"2019-12-22T12:05:02.754Z","comments":true,"path":"2018/07/27/Bezier-Google-caihuaxiaoge/","link":"","permalink":"https://www.wangzhumo.com/2018/07/27/Bezier-Google-caihuaxiaoge/","excerpt":"总的来说一共有四段二阶贝塞尔曲线，其实我们是可以只用一次高阶贝塞尔曲线来搞定的，但是那样不是很划算，所以我用四段二阶曲线拼接为一个循环。 示意图： 图中大框表示手机屏幕，我们只要每次都移动S点的位置就可以做到模拟波浪。","text":"总的来说一共有四段二阶贝塞尔曲线，其实我们是可以只用一次高阶贝塞尔曲线来搞定的，但是那样不是很划算，所以我用四段二阶曲线拼接为一个循环。 示意图： 图中大框表示手机屏幕，我们只要每次都移动S点的位置就可以做到模拟波浪。 那么需要确定 宽度（D点位置） 波浪高度 （C 点，控制点的高度，它的宽度是不做变化的） 起始点的位置 当我们开始移动时，只需要移动S点位置即可，其他点都调用quadTo ，lineTo 的API就可以直接相对位置的位移 实现效果图: 好了，既然道理已经明白了，那就开始代码把 实现选择继承View实现，我们没有其他的控件需要协调，只要管好自己就OK,直接上View即可 本来构思的是做一个可以画多条波浪的View,但是试了一下,多条很难看…..而且我是为了练手,所以半途改了设计 WaveView.java WaveView主要负责初始化Wave.java实例,以及计算水面的高度其他都是具体交给了Wave.java做的 onDraw的主要逻辑: @Override protected void onDraw(Canvas canvas) { //这一步是画了一个圆角矩形,达到整个控件的圆角效果 //在super之前调用,除了背景,可以挡着所有的绘制 canvas.clipPath(radiusPath); super.onDraw(canvas); //为了实现最后时刻的抖动效果 matrix.setRotate(postRotate, 0.5F, 0.5F);//忽略,未实现 canvas.save();//忽略,未实现 canvas.concat(matrix);//忽略,未实现 //draw wave,这一步就是把两条波浪都画了出来,for循环所有的波浪,其实就2条 for (int i = waveList.length-1; i &gt;= 0; i--) { waveList[i].drawWave(canvas); } canvas.restore();//忽略,未实现 } 水面高度动画:(其实这里没有设置动画的时长,因为这个是留给使用者来设置的) /** * 设置水升起的动画 * @return ValueAnimator */ private ValueAnimator getWaterRaiseAnim() { //初始化动画 if (waterAnimator == null) { //可以看到,我们的变化范围是 0F - mHeight waterAnimator = ValueAnimator.ofFloat(0F, mHeight); waterAnimator.setInterpolator(new AccelerateInterpolator()); waterAnimator.addUpdateListener(animation -&gt; { for (Wave wave : waveList) { //循环调用wave,告诉每一个实例,高度变化了 wave.updateHeight((float) animation.getAnimatedValue()); } }); } return waterAnimator; } 两个startAnim,目的是用户不传递时间时,我们使用默认的20 * 1000毫秒 //开始动画 public void startAnim() { startAnim(DEFAULT_TIME); } /** * 开始动画 * @param time 时间单位 秒 */ public void startAnim(long time) { if (animatorSet != null) { if (animatorSet.isRunning()) { animatorSet.cancel(); } animatorSet.start(); }else{ initAnim(time); animatorSet.start(); } } //这里本来还添加了晃动的动画,注释掉的就是 private void initAnim(long time) { animatorSet = new AnimatorSet(); waterAnimator = getWaterRaiseAnim(); waterAnimator.setDuration(time); animatorSet.play(waterAnimator); //rotateAnim = getRotateAnim(); //animatorSet.play(rotateAnim).after(time / 5 * 4) } Wave.java 主要负责绘制波浪,并自己调用动画达到波浪起伏效果 绘制的方法: /** * 当前这一条波浪的绘制 * * @param canvas 画布 */ public void drawWave(Canvas canvas) { //如果不是第一层,则不需要要画波浪下面的部分 drawWave(isTop()); canvas.drawPath(mPath, mPaint); } /** * @param isNeed 是否需要绘制下面部分 */ private void drawWave(boolean isNeed) { mPath.reset(); mPath.moveTo(mLeftTop.x, mLeftTop.y); mPath.quadTo(mControlFirst.x, mControlFirst.y, mLeftMid.x, mLeftMid.y); mPath.quadTo(mControlSecond.x, mControlSecond.y, mMid.x, mMid.y); mPath.quadTo(mControlThree.x, mControlThree.y, mRightMid.x, mRightMid.y); mPath.quadTo(mControlFour.x, mControlFour.y, mRightTop.x, mRightTop.y); if (isNeed) { mPath.lineTo(mRightBottom.x, mRightBottom.y); mPath.lineTo(mLeftBottom.x, mLeftBottom.y); mPath.lineTo(mLeftTop.x, mLeftTop.y); } else { mPath.lineTo(mRightTop.x, mRightTop.y + mWaveTrough); mPath.lineTo(mLeftTop.x, mLeftTop.y + mWaveTrough); mPath.lineTo(mLeftTop.x, mLeftTop.y); } } 动画 /** * 初始化一个动画,并开启动画 */ public void startAnim() { ValueAnimator valueAnimator; if ((layerNum &amp; 1) == 0) { //达到位移是从左向右的效果 valueAnimator = ValueAnimator.ofFloat(mLeftTop.x, 0); } else { //位移从右向左的移动 valueAnimator = ValueAnimator.ofFloat(mRightTop.x, mWidth); } valueAnimator.setInterpolator(new LinearInterpolator()); valueAnimator.setDuration(1000); //无限的动画,一直播放,达成一个循环 valueAnimator.setRepeatCount(Animation.INFINITE); valueAnimator.addUpdateListener(animation -&gt; { float value = (float) animation.getAnimatedValue(); //交给next方法,具体的算出每一个点的下一个位置 next(value); }); valueAnimator.start(); } next(float value) /** * 变化后的数值 * @param value x方向的位移 */ private void next(float value) { if ((layerNum &amp; 1) == 0) { //这是向右移动 mLeftTop.set(value, mHeight - mWaterHeight); mLeftMid.set(mLeftTop.x + mWidth / 2f, mHeight - mWaterHeight); mMid.set(mLeftMid.x + mWidth / 2f, mHeight - mWaterHeight); mRightMid.set(mMid.x + mWidth / 2f, mHeight - mWaterHeight); mRightTop.set(mRightMid.x + mWidth / 2f, mHeight - mWaterHeight); mControlFirst.set(mLeftTop.x + mWidth / 4f, mLeftTop.y + mWaveTrough); mControlSecond.set(mLeftMid.x + mWidth / 4f, mLeftMid.y - mWavePeak); mControlThree.set(mMid.x + mWidth / 4f, mMid.y + mWaveTrough); mControlFour.set(mRightMid.x + mWidth / 4f, mRightMid.y - mWaveTrough); } else { //向左移动 mLeftTop.set(value, mHeight - mWaterHeight); mLeftMid.set(mLeftTop.x - mWidth / 2f, mHeight - mWaterHeight); mMid.set(mLeftMid.x - mWidth / 2f, mHeight - mWaterHeight); mRightMid.set(mMid.x - mWidth / 2f, mHeight - mWaterHeight); mRightTop.set(mRightMid.x - mWidth / 2f, mHeight - mWaterHeight); mControlFirst.set(mLeftTop.x - mWidth / 4f, mLeftTop.y + mWaveTrough); mControlSecond.set(mLeftMid.x - mWidth / 4f, mLeftMid.y - mWavePeak); mControlThree.set(mMid.x - mWidth / 4f, mMid.y + mWaveTrough); mControlFour.set(mRightMid.x - mWidth / 4f, mRightMid.y - mWaveTrough); } //这里我们只对第一个波浪设置了回调,所以必须要判断,不是空才能通知WaveView重绘 if (onRequestDraw != null) { onRequestDraw.onDraw(); } } 总结定义一定要清楚,要不然会把自己混进去. 具体代码请到 GIthub : https://github.com/wangzhumo/module_views","categories":[{"name":"View","slug":"View","permalink":"https://www.wangzhumo.com/categories/View/"}],"tags":[{"name":"Android","slug":"Android","permalink":"https://www.wangzhumo.com/tags/Android/"},{"name":"View","slug":"View","permalink":"https://www.wangzhumo.com/tags/View/"}]},{"title":"Android开发xml中的样式","slug":"Android-xml-style","date":"2018-07-26T05:23:26.000Z","updated":"2019-12-22T12:04:30.976Z","comments":true,"path":"2018/07/26/Android-xml-style/","link":"","permalink":"https://www.wangzhumo.com/2018/07/26/Android-xml-style/","excerpt":"前言我们在App中,很多时候需要一个统一的风格,样式.如TextView,EditText,Button,ProgressBar,CheckBox等等,都需要背景,阴影等.我们可以用UI设计师提供的切图,但是如果我们能使用Android提供的shape、selector、layer-list、level-list、style、theme等实现会更好. 下面做一个基本使用的笔记.","text":"前言我们在App中,很多时候需要一个统一的风格,样式.如TextView,EditText,Button,ProgressBar,CheckBox等等,都需要背景,阴影等.我们可以用UI设计师提供的切图,但是如果我们能使用Android提供的shape、selector、layer-list、level-list、style、theme等实现会更好. 下面做一个基本使用的笔记. Shapeshape定义的xml文件我们都是存放在drawable目录下，如果你的项目没有则新建一个. 使用shape可以通过android:shape属性指定下面四种类型的形状 rectangle: 矩形 oval: 椭圆形 line: 线形 ring: 环形 基本属性 corners 设置圆角,rectangle矩形的时候用 可以radius使用所有的圆角,也可以单独设置每一个圆角 android:radius 四个圆角都会使用这个值 android:topLeftRadius 左上角的半径 android:topRightRadius 右上角的半径 android:bottomLeftRadius 左下角的半径 android:bottomRightRadius 右下角的半径 soid 设置填充色 android:color 填充色 stroke 设置描边线条 android:color 描边线条颜色 android:width 描边线条宽度 android:dashWidth 设置线条为虚线时的横线长度 android:dashGap 设置线条为虚线时的横线之间的间隔 padding 内容与边界的内间距 android:left 左内间距 android:right 右内间距 android:top 上内间距 android:bottom 下内间距 gradient 这个属性可以给你的图形设置渐变 android:type 渐变的类型 (第一次用方形,哈哈) linear 线性渐变 sweep 扫描渐变 radial 放射渐变 android:startColor 渐变开始的颜色 android:centerColor 渐变的中间色 android:endColor 渐变结束的颜色 android:angle 渐变的角度,当你设置线性渐变可用 android:centerX 渐变中心的X坐标,当你设置放射渐变有效 android:centerY 渐变中心的Y坐标 ,当你设置放射渐变有效 android:gradientRadius 渐变的半径,针对放射渐变 rectangle同基本属性 linestroke &amp; size 组合实现,常用来做EditText的光标 oval size 可以设置图形的宽,高 android:width 宽度 android:height 高度 其他同基本属性 ring android:innerRadius 里面圆的半径 android:innerRadiusRatio 默认3,便是内圆半径是宽度/3 android:thickness 环的宽度 android:thicknessRatio 默认是9,表示环的宽度是宽度/9 &lt;shape xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot; android:innerRadiusRatio=&quot;3&quot; android:shape=&quot;ring&quot; android:thicknessRatio=&quot;9&quot; android:useLevel=&quot;false&quot;&gt; &lt;gradient android:endColor=&quot;@color/colorAccent&quot; android:startColor=&quot;#FFFFFF&quot; android:type=&quot;sweep&quot; /&gt; &lt;/shape&gt; 图示: Selectorselector可以添加多个Item,表示不同的状态的不同资源.drawable &amp; color 要注意的: drawable的资源放在 drawable目录,并且指定的是 android:drawable color 的放在color目录,并且指定 android:color 那么下面我列举出所有的可以设置的状态 android:state_enabled: 设置触摸或点击事件是否可用状态 android:state_pressed: 是否按压状态 android:state_selected: 是否选中状态，true表示已选中，false表示未选中 android:state_checked: 是否勾选状态 android:state_checkable: 勾选是否可用状态 android:state_focused: 是否获得焦点状态 android:state_window_focused: 当前窗口是否获得焦点状态 android:state_activated: 是否被激活状态 android:state_hovered: 是在上面滑动的状态 android:enterFadeDuration 状态改变时的淡入时间 android:exitFadeDuration 状态改变时旧状态消失的淡出 layout-listlayer-list的作用是把多个drawable按照顺序层叠在一起显示. 它既可以是根节点,也可以作为selector的Item存在. 我们可以使用layer-list的特性来做阴影效果. &lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt; &lt;layer-list xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;&gt; &lt;item android:left=&quot;4dp&quot; android:top=&quot;4dp&quot;&gt; &lt;shape&gt; &lt;solid android:color=&quot;@android:color/darker_gray&quot; /&gt; &lt;corners android:radius=&quot;10dp&quot; /&gt; &lt;/shape&gt; &lt;/item&gt; &lt;item android:bottom=&quot;4dp&quot; android:right=&quot;4dp&quot;&gt; &lt;shape&gt; &lt;solid android:color=&quot;@android:color/white&quot; /&gt; &lt;corners android:radius=&quot;10dp&quot; /&gt; &lt;/shape&gt; &lt;/item&gt; &lt;/layer-list&gt; layer-list的item可以通过以下四个属性来设置偏移量： android:top 顶部偏移量 android:bottom 底部偏移量 android:left 左边偏移量 android:right 右边偏移量 level-listlevel-list可以存放多张drawable,每一张drawable对应一定的level范围,使用时通过level值展示对应的drawable android:drawable 指定drawable资源 android:minLevel 该Drawable的最小level值 android:maxLevel 该Drawable的最大level值 &lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt; &lt;level-list xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;&gt; &lt;item android:drawable=&quot;@drawable/draw1&quot; android:maxLevel=&quot;50&quot; android:minLevel=&quot;0&quot; /&gt; &lt;item android:drawable=&quot;@drawable/draw2&quot; android:maxLevel=&quot;100&quot; android:minLevel=&quot;50&quot; /&gt; &lt;/level-list&gt;","categories":[{"name":"View","slug":"View","permalink":"https://www.wangzhumo.com/categories/View/"}],"tags":[{"name":"Android","slug":"Android","permalink":"https://www.wangzhumo.com/tags/Android/"},{"name":"View","slug":"View","permalink":"https://www.wangzhumo.com/tags/View/"}]},{"title":"Android Studio中使用CMake进行JNI开发","slug":"Android-Studio-CMake-JNI","date":"2018-07-25T03:07:06.000Z","updated":"2019-12-22T12:03:56.577Z","comments":true,"path":"2018/07/25/Android-Studio-CMake-JNI/","link":"","permalink":"https://www.wangzhumo.com/2018/07/25/Android-Studio-CMake-JNI/","excerpt":"前言定一个小目标,替代RenderScript来做一个图片的高斯模糊,因为这是一个比较考验性能的操作,所以我打算用C来做这个操作(主要原因是我自己不会写C++,刚好看到有这个开源算法…) 创建项目 new -&gt; new Module -&gt; Android Library 当项目创建好之后,这只是一个单纯的Library,并不能使用JNI开发 下面,我们把它改造一下(下图是改造完成的目录结构):","text":"前言定一个小目标,替代RenderScript来做一个图片的高斯模糊,因为这是一个比较考验性能的操作,所以我打算用C来做这个操作(主要原因是我自己不会写C++,刚好看到有这个开源算法…) 创建项目 new -&gt; new Module -&gt; Android Library 当项目创建好之后,这只是一个单纯的Library,并不能使用JNI开发 下面,我们把它改造一下(下图是改造完成的目录结构): 添加CMakeLists.txt 选中lib_blur - new File - CMakeLists.txt cmake_minimum_required(VERSION 3.4.1) #设置生成的so动态库最后输出的路径 #set(CMAKE_LIBRARY_OUTPUT_DIRECTORY ${PROJECT_SOURCE_DIR}/src/main/jniLibs/${ANDROID_ABI}) add_library( # 库名 sample # 该库生成动态函数 SHARED # 依赖的文件 src/main/cpp/samplelib.cpp) find_library( # 设置Path变量的名称 log-lib # 指定要查询的库名字 # 在ndk中查找 liblog.so 函数库 log ) target_link_libraries( # 目标库 sample # 要链接的库 android # Links the target library to the log library # included in the NDK. ${log-lib} ) 修改build.gradeandroid { defaultConfig { //... ndk { // 设置支持的SO库架构 abiFilters &#39;armeabi-v7a&#39;, &#39;x86&#39; } externalNativeBuild { cmake { cppFlags &quot;-std=c++14&quot;, &quot;-frtti&quot;, &quot;-fexceptions&quot; } } } //... externalNativeBuild { cmake { path &quot;CMakeLists.txt&quot; } } } 编写C++文件我们的C文件都在src/main/cpp文件夹下,每一个C文件都需要在CMakeLists.txt文件中指定 # 依赖的文件 src/main/cpp/samplelib.cpp samplelib.cpp #include &lt;jni.h&gt; #include &lt;stdlib.h&gt; #include &lt;string&gt; #include &lt;android/log.h&gt; #define TAG &quot;JNI_LOG&quot; #define LOGE(...) __android_log_print(ANDROID_LOG_ERROR,TAG ,__VA_ARGS__) using namespace std; #ifdef __cplusplus extern &quot;C&quot; { #endif //定义我Java文件的位置,注意是&#39;/&#39;分开 static const char *className = &quot;com/wangzhumo/app/commonlib/jni/JniManager&quot;; //返回一个string jstring stringFromJNI(JNIEnv *env,jclass clz) { std::string hello = &quot;Hello from C++&quot;; return env-&gt;NewStringUTF(hello.c_str()); } //返回一个string 并把这句话打印到logcat中去 jstring sayHello(JNIEnv* env,jclass clz) { std::string hello = &quot;Say Hello from C++&quot;; LOGE(&quot;Say Hello and value&quot;); return env-&gt;NewStringUTF(hello.c_str()); } //获取所有方法名 static JNINativeMethod gJniMethods[] = { {&quot;sayHello&quot;, &quot;()Ljava/lang/String;&quot;, (void*)sayHello}, {&quot;stringFromJNI&quot;, &quot;()Ljava/lang/String;&quot;, (void*)stringFromJNI}, }; //其中{&quot;MethodName&quot;,&quot;(入参)返回值&quot;,()Method} //动态注册本地方法 static int jniRegisterNativeMethods(JNIEnv* env, const char* className, const JNINativeMethod* gMethods, int numMethods) { jclass clazz; clazz = (env)-&gt;FindClass( className); if (clazz == NULL) { return -1; } int result = 0; if ((env)-&gt;RegisterNatives(clazz, gMethods, numMethods) &lt; 0) { result = -1; } (env)-&gt;DeleteLocalRef(clazz); return result; } //JNI_OnLoad回调 JNIEXPORT jint JNICALL JNI_OnLoad(JavaVM* vm, void* reserved){ JNIEnv* env = NULL; jint result = -1; if (vm-&gt;GetEnv((void**) &amp;env, JNI_VERSION_1_6) != JNI_OK) { return result; } jniRegisterNativeMethods(env, className, gJniMethods, sizeof(gJniMethods) / sizeof(JNINativeMethod)); return JNI_VERSION_1_6; } #ifdef __cplusplus } #endif 编写Java文件public class JniManager { static{ System.loadLibrary(&quot;sample&quot;); } public static native String sayHello(); public static native String stringFromJNI(); } 编译 Build -&gt; Make Project 编译完成,如果成功则 build -&gt; intermediates -&gt; cmake 下就有 .so文件 如图所示: 我们可以看到,生成了 armeabi-v7a, x86两种类型的.so文件,如果不在build.gradle中声明: ndk { // 设置支持的SO库架构 abiFilters &#39;armeabi-v7a&#39;, &#39;x86&#39; } 调用class MainActivity : AppCompatActivity() { override fun onCreate(savedInstanceState: Bundle?) { super.onCreate(savedInstanceState) setContentView(R.layout.activity_main) } override fun onResume() { super.onResume() Log.e(&quot;JNI&quot;,JniManager.sayHello()) Log.e(&quot;JNI&quot;,JniManager.stringFromJNI()) } } 结果: 07-26 17:42:41.420 6685-6685/com.wangzhumo.playground E/JNI_LOG: Say Hello and value 07-26 17:42:41.420 6685-6685/com.wangzhumo.playground E/JNI: Say Hello from C++ 07-26 17:42:41.420 6685-6685/com.wangzhumo.playground E/JNI: Hello from C++ 其中JNI_LOG是由 cpp 中的方法打印到Android的控制台的 JNI是我们在MainActivity中调用的 Log.e(&quot;JNI&quot;,JniManager.sayHello()) Log.e(&quot;JNI&quot;,JniManager.stringFromJNI()) 结语以上说明我的JNI算是初步完成了调用 http://zhixinliu.com/2015/07/01/2015-07-01-jni-register/ https://developer.android.com/ndk/guides/ 前言中的Flag真是立的好,C++不是很会,所以只能往简单了写,真是可怜的我","categories":[{"name":"Android","slug":"Android","permalink":"https://www.wangzhumo.com/categories/Android/"}],"tags":[{"name":"Android","slug":"Android","permalink":"https://www.wangzhumo.com/tags/Android/"}]},{"title":"递归调用创建单链表","slug":"Recursion-Linked-List","date":"2018-07-15T03:05:09.000Z","updated":"2019-12-22T12:07:54.299Z","comments":true,"path":"2018/07/15/Recursion-Linked-List/","link":"","permalink":"https://www.wangzhumo.com/2018/07/15/Recursion-Linked-List/","excerpt":"前言很多的面试中,都有要求实现一个单链表,这里就搞一个试试.","text":"前言很多的面试中,都有要求实现一个单链表,这里就搞一个试试. 实现Node.kt //创建一个Node class Node(val value:Int){ var next : Node? = null } 这个Node有一个value,它是一个必传且不可修改的参数,就直接放在了构造了 next指向了下一个Node,这样就可以完成一个单向的链表,让我想起了 Message的next next默认是null,这是因为单链表最后一个next中就是null. ListCreated.kt class ListCreated { fun createList(list: List&lt;Int&gt;): Node? { //1. if (list.isEmpty()) { return null } //2. val currentNode = Node(list[0]) println(&quot;before ${currentNode.value}&quot;) //3. val nextNode = createList(list.subList(1, list.size)) if (nextNode != null) { println(&quot;after ${currentNode.value}&quot;) } //4. currentNode.next = nextNode return currentNode } } class ListCreated { fun createList(list: List&lt;Int&gt;): Node? { //1. if (list.isEmpty()) { return null } //2. val currentNode = Node(list[0]) println(&quot;before ${currentNode.value}&quot;) //3. val nextNode = createList(list.subList(1, list.size)) if (nextNode != null) { println(&quot;after ${currentNode.value}&quot;) } //4. currentNode.next = nextNode return currentNode } } 我们需要去判断List,如果为空就直接返回null了 这里就是当前的这个Node,保存了当前的value,但是next还是为null的 这里就是递归调用的地方,传入的参数是一个subList,当然是去掉了第一个,因为第一个已经是currentNode了 把currentNode的next指向了nextNode,构成单向 MainTest.java public class MainClass { public static void main(String[] args){ List&lt;Integer&gt; integerList = Arrays.asList(1,4,6,2); ListCreated created = new ListCreated(); Node node = created.createList(integerList); printAll(node); } public static void printAll(Node node){ while (node != null){ System.out.print(node.getValue()); System.out.print(&quot; &quot;); node = node.getNext(); } } } 打印结果: before 1 before 4 before 6 before 2 after 6 after 4 after 1 1 4 6 2 我们可以清楚的知道before 1,4,6,2 而没有打印,说明压入了栈,指令没有返回 after本来应该是 2,6,4,1的,为什么2没有打印出来,是因为 if (nextNode != null) { println(&quot;after ${currentNode.value}&quot;) } 链表最后一个Node的next是为null的,所以没有打印 出栈的顺序,也是按照栈的规则,先进后出. 可以看到出入栈的顺序","categories":[{"name":"Java","slug":"Java","permalink":"https://www.wangzhumo.com/categories/Java/"}],"tags":[{"name":"Java","slug":"Java","permalink":"https://www.wangzhumo.com/tags/Java/"}]},{"title":"设计模式-装饰者设计模式","slug":"Design-Pattern-Decoration","date":"2018-07-14T11:05:28.000Z","updated":"2019-12-22T12:11:05.936Z","comments":true,"path":"2018/07/14/Design-Pattern-Decoration/","link":"","permalink":"https://www.wangzhumo.com/2018/07/14/Design-Pattern-Decoration/","excerpt":"认识装饰者模式装饰者模式一般由一下几部分组成: Component：装饰者和被装饰者的共同父类,是一个接口或者抽象类,定义了基本行为 ConcreteComponent：具体的组件对象,实现了组件的接口,定义具体对象,通常就是被装饰者 Decorator：抽象装饰者,需要继承Component,它内部维护了一个指向Component实例的引用,对于ConcreteComponent来说,不需要知道Decorator的存在,就可以完成对ConcreteComponent的装饰 ConcreteDecorator：具体装饰者,来完成具体的装饰功能,扩展ConcreteComponent.","text":"认识装饰者模式装饰者模式一般由一下几部分组成: Component：装饰者和被装饰者的共同父类,是一个接口或者抽象类,定义了基本行为 ConcreteComponent：具体的组件对象,实现了组件的接口,定义具体对象,通常就是被装饰者 Decorator：抽象装饰者,需要继承Component,它内部维护了一个指向Component实例的引用,对于ConcreteComponent来说,不需要知道Decorator的存在,就可以完成对ConcreteComponent的装饰 ConcreteDecorator：具体装饰者,来完成具体的装饰功能,扩展ConcreteComponent. 我们知道在编码中,倡导使用组合,而不是继承来扩展和复用功能,装饰者模式也是基于组合来完成的.装饰者模式可以很灵活的给对象添加功能,作为一个外部的类给对象添加功能,而不用直接修改对象本身,或者创建子类. 实现那我们就按照上面的结构,一一来创建 就拿我下班后要干的事说起吧,每天下班我回家必须要背一会单词,这个是我的基本任务 可选的任务: Coding 看书 看电视 玩手机 Componentabstract class HomeWork{ //完成了作业 open fun doWork() : String { return &quot;下班后任务&quot; } //完成作业花费时间 abstract fun costTime() : Int } 可以看到,我下班后的任务,定义了一个任务,一个耗费时间 这个Component可以是接口,也可以是抽象类,根据自己的需要来定就行 ConcreteComponentclass BaseWork : HomeWork(){ override fun doWork(): String { return &quot;背单词&quot; } override fun costTime() : Int { return 30 } } Decoratorabstract class Decorator : HomeWork(){ abstract override fun costTime(): Int } ConcreteDecoratorclass ProgrammeWork(private val work : HomeWork) : Decorator(){ override fun doWork(): String { return work.doWork() + &quot; Coding&quot; } override fun costTime(): Int { return work.costTime() + 45 } } class TelevisionWork(private val work: HomeWork) : Decorator(){ override fun doWork(): String { return work.doWork() + &quot; 看电视&quot; } override fun costTime(): Int { return work.costTime() + 60 } } 执行结果public static void main(String[] args){ BaseWork work = new BaseWork(); System.out.println(work.doWork() + String.format(&quot; 耗费时间 : %d 分钟&quot;, work.costTime())); //如果说我心情好还学了一会代码 ProgrammeWork programmeWork = new ProgrammeWork(work); System.out.println(programmeWork.doWork() + String.format(&quot; 耗费时间 : %d 分钟&quot;, programmeWork.costTime())); //本来想睡了,但是媳妇看的电视特好看,我又去看了电视 TelevisionWork tvWork = new TelevisionWork(programmeWork); System.out.println(tvWork.doWork() + String.format(&quot; 耗费时间 : %d 分钟&quot;, tvWork.costTime())); } //Run: 背单词 耗费时间 : 30 分钟 背单词 Coding 耗费时间 : 75 分钟 背单词 Coding 看电视 耗费时间 : 135 分钟 Process finished with exit code 0 其实我觉得装饰者和代理模式很像,像到我想不到有什么本质的差异,可能是我自己没有深刻的理解这两个设计模式,所以我希望下次有机会能搞明白. https://blog.csdn.net/yeguxin/article/details/77337649 这里是我现在觉得讲的有点道理的.","categories":[{"name":"Java","slug":"Java","permalink":"https://www.wangzhumo.com/categories/Java/"}],"tags":[{"name":"Java","slug":"Java","permalink":"https://www.wangzhumo.com/tags/Java/"},{"name":"设计模式","slug":"设计模式","permalink":"https://www.wangzhumo.com/tags/设计模式/"}]},{"title":"设计模式-状态模式的使用","slug":"Design-pattern-State","date":"2018-07-14T00:45:32.000Z","updated":"2019-12-22T12:10:52.272Z","comments":true,"path":"2018/07/14/Design-pattern-State/","link":"","permalink":"https://www.wangzhumo.com/2018/07/14/Design-pattern-State/","excerpt":"状态模式(State)定义允许一个对象在其内部状态改变时改变它的行为,对象看起来似乎修改了它的类,状态模式是一种对象行为型模式。 那么我们在编码的过程中,有什么地方会遇到这样的状况那?","text":"状态模式(State)定义允许一个对象在其内部状态改变时改变它的行为,对象看起来似乎修改了它的类,状态模式是一种对象行为型模式。 那么我们在编码的过程中,有什么地方会遇到这样的状况那? 组成环境类(Context) : 它内部维护一个State子类的实例,这个实例定义的是当前状态. 抽象状态类(State) : 定义一个接口,其中封装Context的一个特定状态的相关行为. 具体状态类(ConcreteState): 实现一个与Context的一个状态相关的行为. 使用情况 如果一个对象,它的行为完全取决于它的某一种状态,而且这个状态是动态变化的. 代码中包含大量与对象状态有关的条件语句 代码实现现在有这么一个需求,用户分为不同的等级,每个等级所进行的操作是不一样的. State interface UserState{ //接收一个价格,再返回一个处理后的价格 fun pay (level:Double) : Double } ConcreteState class NormalState :UserState{ override fun pay(level: Double): Double { val result = level * 1.0 println(&quot;${javaClass.simpleName} 需要支付 : $result&quot;) return result } } class BossState : UserState{ override fun pay(level: Double): Double { val result = 0 println(&quot;${javaClass.simpleName} 需要支付 : $result&quot;) return 0.0 } } class VIPState : UserState{ override fun pay(level: Double): Double { //会员95% val result = level * 0.95 println(&quot;${javaClass.simpleName} 需要支付 : $result&quot;) return result } } Context class UserContext{ //保存状态 private var mState : UserState = NormalState() fun setUser(state: UserState){ this.mState = state } fun pay(price:Double){ mState.pay(price) } } 测试public class MainClass { public static void main(String[] args){ UserContext userContext = new UserContext(); userContext.pay(1000); userContext.setUser(new VIPState()); userContext.pay(1000); userContext.setUser(new BossState()); userContext.pay(1000); } } //result: NormalState 需要支付 : 1000.0 VIPState 需要支付 : 950.0 BossState 需要支付 : 0 Process finished with exit code 0 StateMachine复杂的状态机看着是没啥用的东西,明明可以用if else 搞定的,为什么一定要使用设计模式,而且还多了好几个类 只是我这里写的例子太简单,但还是把state 和 行为拉了出来,如果后面要加状态再添加实现类即可 BUT这只是最简单的实现,我们可以看看系统中有什么高级的东西 com/android/internal/util/StateMachine.java 当我看到这个类,我一下就明白为什么要用状态模式 我们现在的结构,非常简单,确实可以被if else替换,只是不那么优雅 但是如果,你的State是这样的那? 你还可以用if - else么?这时候给你加一个state,不说改代码,起码要理一会才行 使用SmHandle sm; //添加状态 sm.addState(S0,null); //S1 S2添加为S0的子类 sm.addState(S1,S0); sm.addState(S2,S0); //S3 S3添加为S1的子类 sm.addState(S3,S1); sm.addState(S4,S1); //S5 S6 S7添加为S2的子类 sm.addState(S5,S2); sm.addState(S6,S2); sm.addState(S7,S2); //设置初始状态 setInitialState(S4); 这样会构造成","categories":[{"name":"Java","slug":"Java","permalink":"https://www.wangzhumo.com/categories/Java/"}],"tags":[{"name":"Java","slug":"Java","permalink":"https://www.wangzhumo.com/tags/Java/"},{"name":"设计模式","slug":"设计模式","permalink":"https://www.wangzhumo.com/tags/设计模式/"}]},{"title":"RecyclerView中notifyItemRangeChanged无效的BUG","slug":"RecyclerView-unuseful-notifyItemRangeChanged","date":"2018-07-13T14:39:55.000Z","updated":"2019-12-22T12:07:39.310Z","comments":true,"path":"2018/07/13/RecyclerView-unuseful-notifyItemRangeChanged/","link":"","permalink":"https://www.wangzhumo.com/2018/07/13/RecyclerView-unuseful-notifyItemRangeChanged/","excerpt":"前言RecyclerView是我们日常开发中用的最频繁的几个控件之一,可以说一个App没有RecyclerView的参与,可能根本就做不出来.然而同时,RecyclerView尽管有复用机制,我们使用的时候,还是应该尽量的节省内存,提高性能. 所以,对于RecyclerView中的Item,尽量少刷新,越少越好.","text":"前言RecyclerView是我们日常开发中用的最频繁的几个控件之一,可以说一个App没有RecyclerView的参与,可能根本就做不出来.然而同时,RecyclerView尽管有复用机制,我们使用的时候,还是应该尽量的节省内存,提高性能. 所以,对于RecyclerView中的Item,尽量少刷新,越少越好. notifyItemRangeChanged是主要的一个方法,其他的notifyItemChanged等几个不同入参的方法,其实最后都是调用notifyItemRangeChanged: android.support.v7.widget.RecyclerView.Adapter #notifyItemRangeChanged(int positionStart, int itemCount, @Nullable Object payload) 我们可以看到它的几个参数 positionStart 开始的位置 itemCount 需要刷新几个Item payload 这个参数比较重要,如果它为null,则回调中会刷新整个View而不是局部刷新 好了,我们来说说这个BUG 看到赞,评论两个字段了么? 现在的需求是要加一个阅读量的,如图中的红色字 这个阅读量本地先做一个点击就加一的东西,而不去请求网络来刷新. 其实怎么刷这个赞都行,我们都需要先提供一个修改这一个 阅读量View 的功能 所以我理所当然的用notifyItemRangeChanged来做了一遍. BUG再现当我信心满满的把这个运行到真机上测试的时候,我是拒绝的,这个阅读量的数字,一直保持0 一动也不动,于是我就开始了一步步的排除之旅.屋漏偏逢连夜雨,我的数据线好像有点接触不良,只得开启了WIFI ADB用来调试App,但是这就意味着我不能 debug了,那么我只能使出 Log 大法. 先贴上我当时的代码: @Override protected void onBindViewHolder(@NonNull ViewHolder holder, @NonNull MediaItem item, @NonNull List&lt;Object&gt; payloads) { Log.d(&quot;Adapter&quot;,&quot;onBindViewHolder&quot; + payloads.isEmpty()); if (payloads.isEmpty()){ onBindViewHolder(holder, item); }else{ holder.mTvPvNum.setText(payloads.get(0).toString()); } } @Override protected void onBindViewHolder(@NonNull ViewHolder holder, @NonNull MediaItem item) { holder.mTvMediaAuthor.setText(item.getSourceName()); holder.mTvMediaTime.setText(DateFormatUtil.getDataStringForNews(item.getPublishTimeBO())); // 省略其他不相关代码... holder.itemView.setOnClickListener(v -&gt; { if (onNewsClickListener != null) { Log.d(&quot;Adapter&quot;,&quot;onBindViewHolder&quot; + item.getFormatPvNum()); getAdapter().notifyItemChanged(holder.getAdapterPosition(),item.addPvNum().getFormatPvNum()); onNewsClickListener.onArticleClick(item); } }); } 使用notifyItemChanged 调用notifyItemXXX系列方法 在onBindViewHolder(ViewHolder,MediaItem item,List&lt;Object&gt; payloads)方法中判断List&lt;Object&gt; payloads的值 如果payloads值为空,则刷新全部,我这里直接调用了onBindViewHolder(holder, item);来进行整个Item的更新 如果payloads的值不为空,则进行局部更新即可 预期效果在点击整个Item时调用之前准备的回调方法,并且 getAdapter().notifyItemChanged(postion,item.addPvNum().getFormatPvNum()); 那么对应postion位置的Item应该会刷新它的 阅读量 BUG发生原因探索已知条件(通过Log可知) 调用notifyItemChanged成功了 onBindViewHolder(ViewHolder, item,List&lt;Object&gt; payloads)方法没有被成功调起 推测原因如果说我当前的这个Adapter确实调用了notifyItemChanged,并且参数无误,但是却无法拉起回调 只能是回调方法没有被调起,我记起来了一些当时看过的RecyclerView源码 慢慢说起: public void setAdapter(Adapter adapter) { // bail out if layout is frozen setLayoutFrozen(false); setAdapterInternal(adapter, false, true); processDataSetCompletelyChanged(false); requestLayout(); } RecyclerView中的setAdapter,我们只需要关注其中的setAdapterInternal(adapter, false, true); 暂时不用去了解其他几个方法,这4个方法中只有这一个方法参数中带了adapter,说明就是这个方法把RecyclerView和Adapter关联了起来. private void setAdapterInternal(Adapter adapter, boolean compatibleWithPrevious, boolean removeAndRecycleViews) { if (mAdapter != null) { mAdapter.unregisterAdapterDataObserver(mObserver); mAdapter.onDetachedFromRecyclerView(this); } if (!compatibleWithPrevious || removeAndRecycleViews) { removeAndRecycleViews(); } mAdapterHelper.reset(); final Adapter oldAdapter = mAdapter; mAdapter = adapter; if (adapter != null) { adapter.registerAdapterDataObserver(mObserver); adapter.onAttachedToRecyclerView(this); } if (mLayout != null) { mLayout.onAdapterChanged(oldAdapter, mAdapter); } mRecycler.onAdapterChanged(oldAdapter, mAdapter, compatibleWithPrevious); mState.mStructureChanged = true; } 看起来,是把老的Adapter清除,并设置传入的adapter为Adapter的值 if (adapter != null) { adapter.registerAdapterDataObserver(mObserver); adapter.onAttachedToRecyclerView(this); } 重点在这句话adapter.registerAdapterDataObserver(mObserver); 很明显,这是对数据变化注册成为一个观察者,查看源码发现最后是放到了 mObservable 中 大概已经知道是怎么回事了,可能我们当前的Adapter没有注册上观察者,所以没有回调过来吧. 为了证实我的猜测,我借了同事的测试机和线 证实猜想开启DEBUG一步一步跟过来. android.support.v7.widget.RecyclerView.AdapterDataObserver#onItemRangeChanged(int, int) 最后,跑到了这里来.一个真真正正的空方法 于是查看了一下mObservable,只有一个值RefreshAndLoadMoreHelper,而我自己的Adapter明明是叫做MultiTypeAdapter 看到这里,我的猜想已经证实,RefreshAndLoadMoreHelper是我自己封装,用来支持上拉加载,下拉刷新的工具类,其实它自己也继承了RecyclerView.Adapter,并且在RefreshAndLoadMoreHelper的构造方法中,调用了 recyclerView.setAdapter(mHeaderFooterAdapter);,这就是说,我自己设置的Adapter永远会被它覆盖. 解决BUG已经知道了原因,是由于我自己的工具类,替代了本来设置的Adapter,,现在的mHeaderFooterAdapter是与当前RecyclerView关联的,但是我们在代码中 调用的是(开头的代码): getAdapter().notifyItemChanged(holder.getAdapterPosition(),item.addPvNum().getFormatPvNum()); getAdapter()返回的是Adapter而不是关联RecyclerView的mHeaderFooterAdapter 所以,我们只要想办法,在Adapter中调用了方法后,通知mHeaderFooterAdapter一声,让它去完成操作即可 代码如下: Adapter.registerAdapterDataObserver(new RecyclerView.AdapterDataObserver() { @Override public void onChanged() { mHeaderFooterAdapter.notifyDataSetChanged(); } @Override public void onItemRangeChanged(int positionStart, int itemCount, @Nullable Object payload) { mHeaderFooterAdapter.notifyItemRangeChanged(positionStart, itemCount, payload); } }); Adapter是我自己原来设置的 mHeaderFooterAdapter是工具类 这里面的意思就是,给我自己的Adapter注册了一个观察者,每当我在Adapter中调用了方法,就会回调这里,在这里本来是通知RecyclerView来处理的,但是我们并不需要直接来处理,委托给mHeaderFooterAdapter即可,所以我在回调中直接调用了,mHeaderFooterAdapter.notifyItemRangeChanged这样就OK了.","categories":[{"name":"Bug","slug":"Bug","permalink":"https://www.wangzhumo.com/categories/Bug/"}],"tags":[{"name":"Android","slug":"Android","permalink":"https://www.wangzhumo.com/tags/Android/"},{"name":"Bug","slug":"Bug","permalink":"https://www.wangzhumo.com/tags/Bug/"}]},{"title":"ConstraintLayout使用指南-基础的约束","slug":"ConstraintLayout-Basic","date":"2018-07-12T07:49:34.000Z","updated":"2019-12-22T12:11:28.692Z","comments":true,"path":"2018/07/12/ConstraintLayout-Basic/","link":"","permalink":"https://www.wangzhumo.com/2018/07/12/ConstraintLayout-Basic/","excerpt":"前言ConstraintLayout现在已经是新建布局的默认跟布局了,况且确实好用,有必要学习一波 ConstraintLayout,来自官网的文档,觉得不是很直观,于是我想把它做成GIF图 compile &#39;com.android.support.constraint:constraint-layout:1.1.2&#39; 截止我写下这篇笔记的时候,已经是1.1.2版本了,下面所有的代码都是基于1.1.2版本.","text":"前言ConstraintLayout现在已经是新建布局的默认跟布局了,况且确实好用,有必要学习一波 ConstraintLayout,来自官网的文档,觉得不是很直观,于是我想把它做成GIF图 compile &#39;com.android.support.constraint:constraint-layout:1.1.2&#39; 截止我写下这篇笔记的时候,已经是1.1.2版本了,下面所有的代码都是基于1.1.2版本. 面板 首先应该明白主要的两个面板 蓝色的区域,我们成为设计蓝图,下文称蓝图面板 右边的是属性面板,下文称属性面板,可以在这里进行精细调整 单个控件的约束再演示之前,建议大家都使用Android Studio 提供的Design 模式来创建和修改约束布局,方便而且直观 我的Android Studio 版本是3.1.3,如果有和我操作界面不一致的,请自行对应 margin效果 如果我只给左边和上边加上约束,那么就会是margin的效果,代码表现如下: &lt;Button android:id=&quot;@+id/button&quot; android:layout_width=&quot;wrap_content&quot; android:text=&quot;Button&quot; android:layout_height=&quot;wrap_content&quot; android:layout_marginStart=&quot;28dp&quot; android:layout_marginTop=&quot;28dp&quot; app:layout_constraintStart_toStartOf=&quot;parent&quot; app:layout_constraintTop_toTopOf=&quot;parent&quot; /&gt; 如果你想调节这个margin,即可以拖动,也可以去属性面板调整,也可以在代码中修改 居中/偏移效果 可以看到,我在左边和上边已经有margin的情况下,给右边和下边也加上了约束,现在BUTTON大体上是居中效果 为什么是”大体”居中那? 看箭头附近的 28 28 8 8 ,这是在margin的基础上居中的,去掉margin就是绝对居中的了 现在我们看属性面板: 略小的红框中,就是margin,这样的调节框还有3个 看到那个可以滑动的轴了么? 中间还有个50的数字,这个是调节BUTTON在垂直方向的偏移 其他几个操作框同理可推其作用 比如我需要一个登录在垂直方向的0.75处,也就是在整个页面的3/4处 可以直接拉动这个控制点,使他的数值变为75,也可以在代码中修改,代码表现如下: &lt;Button android:id=&quot;@+id/button&quot; android:layout_width=&quot;wrap_content&quot; android:layout_height=&quot;wrap_content&quot; android:text=&quot;登录&quot; app:layout_constraintBottom_toBottomOf=&quot;parent&quot; app:layout_constraintEnd_toEndOf=&quot;parent&quot; app:layout_constraintStart_toStartOf=&quot;parent&quot; app:layout_constraintTop_toTopOf=&quot;parent&quot; app:layout_constraintVertical_bias=&quot;0.75&quot; /&gt; 此时的BUTTON就会处在整个布局的3/4处,就不放图了 纵横比 代码表现如下: &lt;ImageView android:layout_width=&quot;0dp&quot; android:layout_height=&quot;0dp&quot; android:src=&quot;@mipmap/login_bg&quot; android:scaleType=&quot;fitXY&quot; app:layout_constraintDimensionRatio=&quot;h,16:9&quot; app:layout_constraintEnd_toEndOf=&quot;parent&quot; app:layout_constraintStart_toStartOf=&quot;parent&quot; app:layout_constraintTop_toTopOf=&quot;parent&quot; /&gt; 多个控件的约束","categories":[{"name":"Android","slug":"Android","permalink":"https://www.wangzhumo.com/categories/Android/"}],"tags":[{"name":"Android","slug":"Android","permalink":"https://www.wangzhumo.com/tags/Android/"}]},{"title":"JVM的垃圾回收Garbage Collection","slug":"JVM-Garbage-Collection","date":"2018-07-11T07:45:01.000Z","updated":"2019-12-22T12:09:12.086Z","comments":true,"path":"2018/07/11/JVM-Garbage-Collection/","link":"","permalink":"https://www.wangzhumo.com/2018/07/11/JVM-Garbage-Collection/","excerpt":"前言我们知道在线程创建时,程序计数器,本地方法栈,虚拟机栈随之创建,线程销毁时随之销毁 并且栈中的栈帧也随着方法的进入与退出执行出入栈操作,最重要的是每一个栈帧消耗的内存基本上在类结构确定时就已经知道,这几个区域的内存分配与回收都是确定的,不需要过多考虑回收. 但是进程中的 堆(heap) 以及 方法区与上面的几个栈是不同的,当程序处于运行时期才能确定,它们的内存分配与回收都是动态的. 垃圾收集主要就是这部分.","text":"前言我们知道在线程创建时,程序计数器,本地方法栈,虚拟机栈随之创建,线程销毁时随之销毁 并且栈中的栈帧也随着方法的进入与退出执行出入栈操作,最重要的是每一个栈帧消耗的内存基本上在类结构确定时就已经知道,这几个区域的内存分配与回收都是确定的,不需要过多考虑回收. 但是进程中的 堆(heap) 以及 方法区与上面的几个栈是不同的,当程序处于运行时期才能确定,它们的内存分配与回收都是动态的. 垃圾收集主要就是这部分. 内存中对象引用状态要进行垃圾收集,第一件要确定的就是这个对象是否不被任何方式引用,当确定没有任何引用就可以进行回收. 引用：要说引用状态就要明白什么是引用，如果Reference类型的数据中存储的数值代表的是另外一块内存的起始地址，我们就说这块内存代表着一个引用。 在JDK1.2之后,JAVA对引用的概念进行了扩充,将引用分外4种 强引用, val onj = Object() 软引用 ,有用但是非必须的对象 弱引用,用来描述非必须对象 虚引用 那么如何判断呢? 引用计数法即对象有一个引用计数器,每被引用一次就加1,引用释放就减去1,如果计数器为0,那就说明对象”已死” 但是Java虚拟机并没有采用这种方式,因为没有办法解决循环引用的问题 A与B对象,互相持有对方的引用,那么就算他们两个计数器永远不可能等于0,哪怕这两个对象都没有用了. 可达性分析算法JVM就是通过这种方式来判断对象是否存活. 这种算法,就是通过一系列的GC Roots对象作为起始点,从这些节点向下搜索,搜索走过的路径被称为引用链(Reference Chain),当一个对象到GC Roots没有任何引用链相连接的话,就可以判断这个对象不可用了. GC Roots： 虚拟机栈（栈帧中的本地变量表）中的引用对象 方法区中类静态属性引用变量 方法区中常量引用对象 本地方法栈中的JNI引用对象 回收对象通过上面的可达性分析算法,我们就可以判断出那些可回收的对象,但是实际上他们也不是立即被回收 第一次不可达,没有与GC Roots相连接的引用链,他会被标记一次并且进行一次筛选,筛选是否有必要执行finalize()方法,当对象没有覆盖finalize()或者是该方法已经被虚拟机调用,都将视为”没有必要执行”. 如果一个对象被判定需要执行finalize()方法,那么这个对象会被放在F-Queue的队列中,并在稍后由虚拟机创建一个低优先级的Finalizer线程去执行它,稍后GC将会对F-Queue中的对象进行第二次筛选,如果该对象重新被引用了,那么它将被移出F-Queue队列,完成自救.否则,就真的被回收了. 垃圾收集算法标记-清除算法这个算法分为两个部分,首先标记出所有需要回收的对象，在标记完成后统一回收所有被标记的对象 这样的算法虽然可以达到目的,但是效率不高,而且标记-清除后会产生大量的不连续内存碎片,这会导致较大的对象分配内存时无法找到符合的内存块,导致提前触发另一次垃圾回收. 复制算法这种算法的思路是,把一大块内存分为两个部分,A部分正常使用,当A块内存使用完,就把A内存中还存活的对象复制到另一块内存上去,然后一次性清理掉A上所有的内容. 这样的算法,简单而且高效,而且不会有大量不连续内存的问题产生,但是这样的话,永远只能使用到内存的一半空间,未免有些浪费了. IBM通过研究,将内存分为一块较大的Eden空间和两块较小的Survivor空间,8:1:1 标记-整理算法标记过程 仍然与上面说的“标记-清除”算法一样,但是后续不是直接执行清理,而是把可回收对象都向一端移动,然后直接清理掉端边界以外的内存. 分代回收算法一般是把Java堆 分为新生代和老年代，这样就可以根据各个年代的特点采用最适当的收集算法。 新生代:只有少量存活,就选用复制算法,付出少量存活对象的复制成本就可以完成收集 老年代:对象存活率高,没有额外空间对它进行分配担保,就要使用“标记—清理”或者“标记—整理”算法来进行回收 安全点(GC入口)我们都知道GC是阻塞所有线程的,”Stop The World”这样的. 程序执行时并非在所有地方都 能停顿下来开始GC,只有在到达安全点时才能暂停 . 至于对安全点的选定,也是很复杂,这里就不了解了. 抢先式中断:GC发生时,把所有线程全部中断,如果有发现线程断的地方不在安全点上,就恢复线程,直到它继续执行指令到达”安全点”. 主动式中断:GC需要中断时,设置标识,而每一个线程执行时主动轮询这个标志,发现中断标识就自己主动挂起.","categories":[{"name":"Java","slug":"Java","permalink":"https://www.wangzhumo.com/categories/Java/"}],"tags":[{"name":"Java","slug":"Java","permalink":"https://www.wangzhumo.com/tags/Java/"}]},{"title":"Android中的贝塞尔曲线","slug":"Android-Bezier","date":"2018-07-05T08:05:12.000Z","updated":"2019-12-22T12:12:59.954Z","comments":true,"path":"2018/07/05/Android-Bezier/","link":"","permalink":"https://www.wangzhumo.com/2018/07/05/Android-Bezier/","excerpt":"简介贝塞尔曲线(Bézier curve) 我们在很多App种都能发现它的影子,比如说","text":"简介贝塞尔曲线(Bézier curve) 我们在很多App种都能发现它的影子,比如说 QQ的小红点 下拉刷新的粘连效果 个人动态等页面的波浪效果 阅读软件的翻页效果 贝塞尔曲线是用一系列点来控制曲线状态，主要就是：数据点、控制点。我们可以通过调整控制点，来使得贝塞尔曲线形状变化 数据点 指定了起始位置 控制点 一或多个,决定了曲线的轨迹 这里放两个在线查看贝塞尔曲线的链接 http://myst729.github.io/bezier-curve/ http://cubic-bezier.com/#.17,.67,.83,.67 这里是一个快速确定点位置的教程 https://www.jianshu.com/p/1d766455445b","categories":[{"name":"Android","slug":"Android","permalink":"https://www.wangzhumo.com/categories/Android/"}],"tags":[{"name":"Android","slug":"Android","permalink":"https://www.wangzhumo.com/tags/Android/"}]},{"title":"GitHub使用SSH的方式免密上传","slug":"GitHub-With-SSH","date":"2018-07-05T05:13:25.000Z","updated":"2019-12-22T12:10:10.728Z","comments":true,"path":"2018/07/05/GitHub-With-SSH/","link":"","permalink":"https://www.wangzhumo.com/2018/07/05/GitHub-With-SSH/","excerpt":"前言前一段时间换了github账号,各种转移数据,累死我 而后,我顺手添加了github的ssh-key(新创建了一个rsa的Key),然而当我: # phyooos @ wangzhumo in ~/develop/hexo [12:10:02] C:2 $ hexo d INFO Deploying: git INFO Clearing .deploy_git folder... #... git@github.com: Permission denied (publickey). fatal: Could not read from remote repository. 很迷,完全不知道为什么","text":"前言前一段时间换了github账号,各种转移数据,累死我 而后,我顺手添加了github的ssh-key(新创建了一个rsa的Key),然而当我: # phyooos @ wangzhumo in ~/develop/hexo [12:10:02] C:2 $ hexo d INFO Deploying: git INFO Clearing .deploy_git folder... #... git@github.com: Permission denied (publickey). fatal: Could not read from remote repository. 很迷,完全不知道为什么 排除问题查看~/.ssh目录-rw------- 1 phyooos staff 1.6K 6 27 2017 aliyun_rsa -rw-r--r-- 1 phyooos staff 398B 6 27 2017 aliyun_rsa.pub -rw-r--r-- 1 phyooos staff 402B 5 22 2017 authorized_keys -rw-r--r-- 1 phyooos staff 1.1K 6 28 14:48 config -rw------- 1 phyooos staff 3.2K 6 27 18:05 github_rsa -rw-r--r-- 1 phyooos staff 746B 6 27 18:05 github_rsa.pub -rw------- 1 phyooos staff 1.6K 5 17 2017 id_rsa -rw-r--r--@ 1 phyooos staff 402B 5 17 2017 id_rsa.pub -rw-r--r-- 1 phyooos staff 1.3K 7 5 12:33 known_hosts 其中 -rw------- 1 phyooos staff 3.2K 6 27 18:05 github_rsa -rw-r--r-- 1 phyooos staff 746B 6 27 18:05 github_rsa.pub 就是我创建用来给github用的 查看~/.ssh/config# ---- github------------------ Host github HostName github.com User git IdentityFile /Users/phyooos/.ssh/github_rsa # ----------------------------- 也是没有问题的,而github上的key也就确实是github_rsa.pub Tower但是我的Tower上,也有几个github上的项目,却可以正常的上传, 而Tower上的私钥是我手动配上去的,所以问题只有可能是终端中没有按照我的配置IdentityFile /Users/phyooos/.ssh/github_rsa来和github建立连接 我尝试把id_rsa.pub密钥加入到github上. To github.com:wangzhumo/wangzhumo.github.io.git c45bbef..6b25311 HEAD -&gt; master Branch &#39;master&#39; set up to track remote branch &#39;master&#39; from &#39;git@github.com:wangzhumo/wangzhumo.github.io.git&#39;. INFO Deploy done: git 竟然成功了. 结论~/.ssh/config中的配置,莫名没有生效,我至今也不知道为什么 还是说,github在终端中上传时,只会默认去拿id_rsa??? 那就先这么用吧..迷","categories":[{"name":"Tools","slug":"Tools","permalink":"https://www.wangzhumo.com/categories/Tools/"}],"tags":[{"name":"Github","slug":"Github","permalink":"https://www.wangzhumo.com/tags/Github/"}]},{"title":"Android非静态内部类与匿名内部类引起的内存泄漏","slug":"Android-inner-class-leak","date":"2018-07-05T04:06:51.000Z","updated":"2019-12-22T12:03:35.101Z","comments":true,"path":"2018/07/05/Android-inner-class-leak/","link":"","permalink":"https://www.wangzhumo.com/2018/07/05/Android-inner-class-leak/","excerpt":"内存内存泄漏简单的说，当我们的对象创建时，就占用了一部分内存，而在这个对象没有被引用后会进行回收销毁， 以释放掉占用的内存。但是如果jvm没有成功回收这个对象，就会造成内存泄漏。 内存溢出Android中的OOM，系统会给每一个Android程序分配一定的内存。我的的App可能会因为大量的内存泄漏而导致内存耗尽，引发OOM导致整个App的崩溃。 就算内存没有耗尽而崩溃，也会导致App内存不足。此时我们创建新的对象或者其他方式需要使用内存时，GC就会主动进行垃圾回收，为你的操作准备好内存空间，每次GC都是阻塞操作，这就会导致我们的App卡顿。 所以，我们优化App卡顿时，有一点就是要关注“内存抖动”。","text":"内存内存泄漏简单的说，当我们的对象创建时，就占用了一部分内存，而在这个对象没有被引用后会进行回收销毁， 以释放掉占用的内存。但是如果jvm没有成功回收这个对象，就会造成内存泄漏。 内存溢出Android中的OOM，系统会给每一个Android程序分配一定的内存。我的的App可能会因为大量的内存泄漏而导致内存耗尽，引发OOM导致整个App的崩溃。 就算内存没有耗尽而崩溃，也会导致App内存不足。此时我们创建新的对象或者其他方式需要使用内存时，GC就会主动进行垃圾回收，为你的操作准备好内存空间，每次GC都是阻塞操作，这就会导致我们的App卡顿。 所以，我们优化App卡顿时，有一点就是要关注“内存抖动”。 案例handler的内部类 public class MainActivity extends Activity { private final Handler mHandler = new Handler() { @Override public void handleMessage(Message msg) { // do something } } public void test1(){ // 延时60s mHandler.postDelayed(new Runnable() { @Override public void run() { //run } }, 6000); finish(); } } 我们知道在主线程中创建的Handler会被关联到 Looper（主线程的）中去，而主线程的Looper在应用程序的整个生命周期中存在 ，此时的Message会持有Handler对象，用来最后处理消息。 也就是调用Handler#handleMessage(Message msg) 当我们调用test1()方法 延时60s执行（但实际上，这个message已经发送，在消息队列中了，只是60s后才 handleMessage） finish()掉这MainActivity new Runnable是一个匿名内部类，会持有隐式的外部类引用 这下就微妙了，MainActivity已经被finish了，但是延时Message却还存在于消息队列中，直到它被处理 延时Message 持有 MainActivity的Handler(用来处理这个消息)，而我们知道在Java中，非静态内部类和匿名类会隐式持有一个外部类的引用 ，在这里就是Handler隐式持有MainActivity 这下就导致，MainActivity 没有被垃圾回收机制回收 还有个Runnable那… 解决思路 去除隐式引用，可以把非静态内部类转化成静态的 手动管理外部类依赖，如果一定要使用，可以手动传入外部类（像Context这样的完全可以使用ApplicationContext替代） 案例小结非静态的内部类，由于它的生命周期不能同外部类一致，它的生存周期已经超过了它的外部类。 所以在它的外部类被回收时，被它打断了这个操作，导致内存泄漏产生 内部类Java中内部类分为四种 静态内部类 静态匿名内部类 非静态内部类 非静态内部匿名类 说明 成员内部类 静态内部类 静态成员 静态成员需同时有final关键词修饰 可以 静态方法 不可定义 可以 访问外部类非static属性/方法 外部类名.this.成员方法/属性 不可以 外部类访问内部类 需要通过内部类的一个实例来访问 需要通过内部类的一个实例来访问 创建实例 外部类名.内部类名 实例名 = 外部类实例名.new 内部类构造方法(参数) 外部类名.内部类名 实例名 = new 外部类名.内部类名(参数) 编译后的class文件 单独的class文件(so内部类中的方法和变量可以跟父类的方法和变量同名)，外部类$内部类.class 单独的class文件(so内部类中的方法和变量可以跟父类的方法和变量同名)，外部类$内部类.class 其他 与外部类平级的类继承内部类时，其构造方法中需要传入父类的实例对象。且在构造方法的第一句调用“外部类实例名.super(内部类参数)” 无 说明 成员内部类 匿名内部类 静态成员 静态成员需同时有final关键词修饰 不可定义 静态方法 不可定义 不可定义 访问外部类非static属性/方法 外部类名.this.成员方法/属性 外部类名.this.成员方法/属性 外部类访问内部类 需要通过内部类的一个实例来访问 需要通过内部类的一个实例来访问 创建实例 外部类名.内部类名 实例名 = 外部类实例名.new 内部类构造方法(参数) 如上：父类 实例名 = new 父类（）{} 编译后的class文件 单独的class文件(so内部类中的方法和变量可以跟父类的方法和变量同名)，外部类$内部类.class 单独的class文件，使用类$数字.class 其他 与外部类平级的类继承内部类时，其构造方法中需要传入父类的实例对象。且在构造方法的第一句调用“外部类实例名.super(内部类参数)” 无 https://www.cnblogs.com/dorothychai/p/6007709.html 启示 非静态内部类 改为 静态非匿名内部类 使用弱引用 在适当的时机手动销毁，在onDestory中手动销毁 养成良好的习惯，Context、Handler、Timer、Thread 、广播 、 IO 等都要注意销毁","categories":[{"name":"Android","slug":"Android","permalink":"https://www.wangzhumo.com/categories/Android/"}],"tags":[{"name":"Android","slug":"Android","permalink":"https://www.wangzhumo.com/tags/Android/"},{"name":"Java","slug":"Java","permalink":"https://www.wangzhumo.com/tags/Java/"}]},{"title":"Git Submodule 子模块的使用","slug":"Git-Submodule","date":"2018-07-02T08:41:23.000Z","updated":"2019-12-22T12:10:15.405Z","comments":true,"path":"2018/07/02/Git-Submodule/","link":"","permalink":"https://www.wangzhumo.com/2018/07/02/Git-Submodule/","excerpt":"前言Git是一个开源的分布式版本控制系统,大家公司可能都是使用的Git来进行版本控制. 对于我个人,本地项目也喜欢使用git,万一哪天想回退一下,没有git可就真费劲了. 对于git的常规操作不用多说,今天贴一个submodule的真实使用过程","text":"前言Git是一个开源的分布式版本控制系统,大家公司可能都是使用的Git来进行版本控制. 对于我个人,本地项目也喜欢使用git,万一哪天想回退一下,没有git可就真费劲了. 对于git的常规操作不用多说,今天贴一个submodule的真实使用过程 项目结构如上. 为了方便我自己玩,我开了一个playground的项目 playground . ├── app #主项目 ├── lib_common #子项目,其中主要提供三方的依赖,以及整个项目的公共代码部分 #因为这个项目需要及时更新,方便每个人使用,所以是一个submodule来管理 ├── lib_player ├── module_views #今天要演示的子模块 其实Submodule 和Android的组件化更配哦,属于强强联合 创建module_views模块建立module在我们playground的项目上,创建一个新模块,怎么操作就不说了 在module_views中初始化Git 注意,当module_views这个模块创建时,一定不要手快把这个模块添加到playground整个项目的版本控制中 记得忽略module_views整个module 直接贴操作了 # phyooos @ wangzhumo in ~ [16:38:01] $ cd ~/workspace/playground # phyooos @ wangzhumo in ~/workspace/playground on git:master x [16:58:48] $ ll | grep &#39;module_views&#39; drwxr-xr-x 11 phyooos staff 352B 7 2 16:31 module_views # phyooos @ wangzhumo in ~/workspace/playground on git:master x [16:59:03] $ cd module_views # phyooos @ wangzhumo in ~/workspace/playground/module_views [16:59:19] $ git init Reinitialized existing Git repository in /Users/phyooos/workspace/playground/module_views/.git/ 因为我的module_views已经创建git仓库了,所以最后一步提示 Reinitialized existing Git repository 关联远程仓库这一步随意,我本人是在github上创建了一个名为module_views的库 拿到远程仓库地址 git@github.com:wangzhumo/module_views.git # phyooos @ wangzhumo in ~/workspace/playground/module_views [16:59:30] $ git remote add origin git@github.com:wangzhumo/module_views.git # phyooos @ wangzhumo in ~/workspace/playground/module_views on git:master o [16:59:30] $ git push Everything up-to-date # phyooos @ wangzhumo in ~/workspace/playground/module_views on git:master o [17:06:51] $ git status On branch master Your branch is up to date with &#39;origin/master&#39;. nothing to commit, working tree clean 添加远程仓库,并push,把本地代码提交到github上去,因为我自己已经提交过了,所以可以看到 Everything up-to-date 添加子模块到playground中贴操作 # phyooos @ wangzhumo in ~/workspace/playground on git:master x [16:38:12] $ git submodule add git@github.com:wangzhumo/module_views.git ./module_views The following path is ignored by one of your .gitignore files: module_views Use -f if you really want to add it. # phyooos @ wangzhumo in ~/workspace/playground on git:master x [16:38:59] C:1 $ git submodule add -f git@github.com:wangzhumo/module_views.git ./module_views Adding existing repo at &#39;module_views&#39; to the index # phyooos @ wangzhumo in ~/workspace/playground on git:master x [16:39:21] $ git submodule 1616423ab118e2154bcf018c825f6ed3a57cf59b lib_common (heads/master) 55ae43eb327207a456624c69e3c01868f8cf43e3 module_views (heads/master) # phyooos @ wangzhumo in ~/workspace/playground on git:master x [16:39:48] $ git submodule foreach git pull Entering &#39;lib_common&#39; Already up to date. Entering &#39;module_views&#39; Already up to date. 下面解释每一条命令 git submodule add git@github.com:wangzhumo/module_views.git ./module_views 添加子模块 git submodule add &lt;repository&gt; &lt;path&gt; 添加子模块 提示如下: The following path is ignored by one of your .gitignore files: module_views Use -f if you really want to add it. 说我已经把module_views添加到忽略文件中了,如果确实想这样操作,加上-f强制操作 git submodule add -f git@github.com:wangzhumo/module_views.git ./module_views 可以看到提示,我已经成功的把module_views作为子项目添加到playground中了 git submodule 一共看到两个子模块,一个是刚添加的module_views,一个是我之前添加的 git submodule foreach git pull 拉取最新代码 其他submodule操作文档","categories":[{"name":"Tools","slug":"Tools","permalink":"https://www.wangzhumo.com/categories/Tools/"}],"tags":[{"name":"Git","slug":"Git","permalink":"https://www.wangzhumo.com/tags/Git/"}]},{"title":"ServiceLoader 与 责任链设计模式","slug":"serviceloader-zerenlian","date":"2018-06-26T10:22:46.000Z","updated":"2019-12-22T12:06:37.946Z","comments":true,"path":"2018/06/26/serviceloader-zerenlian/","link":"","permalink":"https://www.wangzhumo.com/2018/06/26/serviceloader-zerenlian/","excerpt":"前因最近在做人脸识别的一些东西 主要是使用百度的SDK来完成采集, 识别. 这个功能是使用百度云的Api来对人脸进行分析,拿到年龄 颜值 等等信息","text":"前因最近在做人脸识别的一些东西 主要是使用百度的SDK来完成采集, 识别. 这个功能是使用百度云的Api来对人脸进行分析,拿到年龄 颜值 等等信息 第一版设计稿: 那我就直接把请求到的数据展示了一下,然而 第二版设计稿: 这一版就是需要把拿到的数值按照区间来展示成文字描述 那么,应该就是各种switch if else …. 本来也是做Demo,所以我们可以高点其他的东西,于是我就想起了责任链模式,勉强可以做做么 实现责任链定义抽象类com.baidu.aip.fl.func.service.HandlerFace.java 接口 public abstract class HandlerFace { private HandlerFace nextHandler; //接收一个实体类 public abstract ResultBean process(ResultBean bean); //返回下一个处理类 public HandlerFace nextHandler(){ return nextHandler; } //设置下一个处理类 public void setHandler(HandlerFace handler){ this.nextHandler = handler; } } 具体实现com.baidu.aip.fl.func.service.AgeHandlerFace.java 实现类,处理年龄信息 public class AgeHandlerFace extends HandlerFace { @Override public ResultBean process(ResultBean bean) { //1.处理自己的事情 if (bean != null &amp;&amp; bean.getIntAge() == 0 ){ bean.setResultAge(&quot;-&quot;); }else if (bean != null &amp;&amp; bean.getIntAge() &lt;= 5){ bean.setResultAge(&quot;小朋友&quot;); }else if (bean != null &amp;&amp; bean.getIntAge() &lt;= 10){ bean.setResultAge(&quot;中等朋友&quot;); }else if (bean != null &amp;&amp; bean.getIntAge() &lt;= 15){ bean.setResultAge(&quot;大朋友&quot;); }else if (bean != null &amp;&amp; bean.getIntAge() &lt;= 20){ bean.setResultAge(&quot;成年人&quot;); }else if (bean != null &amp;&amp; bean.getIntAge() &lt;= 40){ bean.setResultAge(&quot;中年人&quot;); }else if (bean != null &amp;&amp; bean.getIntAge() &lt;= 60){ bean.setResultAge(&quot;老年人&quot;); }else if (bean != null &amp;&amp; bean.getIntAge() &lt;= 100){ bean.setResultAge(&quot;年纪好大&quot;); } //2.是否有下一个人来处理 if (nextHandler() != null){ //2.1.如果有下一个处理类,则把信息交给他继续处理 return nextHandler().process(bean); } //3.没有下一个处理直接返回 return bean; } } AgeHandlerFace类只处理年纪相关的东西 com.baidu.aip.fl.func.service.BeautyHandlerFace.java com.baidu.aip.fl.func.service.GenderHandlerFace.java 同样实现HandlerFace,分别处理颜值和性别 ServiceLoader上面的责任链其实已经可以使用,但是需要手动来初始化每个具体实现类, 并且一个一个设置 nextHandler ,最后调用处理 public class RealProcessFace{ //保存HandlerFace的每一个实现类 private static ArrayList&lt;HandlerFace&gt; arraylist; static { arraylist = new ArrayList(); //通过ServiceLoader来加载所有HandlerFace的实现类 ServiceLoader&lt;HandlerFace&gt; processors = ServiceLoader.load(HandlerFace.class); Iterator iterator = processors.iterator(); while (iterator.hasNext()) { //iterator.next() 这里具体实现类才真正的初始化了 arraylist.add((HandlerFace) iterator.next()); } } /** * 获取组合短语 * @param task 人脸信息 * @return 组合短语 */ public static String process(ResultBean task) { for (int i = 0; i &lt; arraylist.size() - 1 ; i++) { //依次设置setHandler //因为我并不需要他们依次处理,所以我并不关系他们处理的顺序 //如果是需要顺序执行的话,建议还是手动处理 arraylist.get(i).setHandler(arraylist.get(i+1)); } //调用第一个处理类,就会依次调用后面的处理类 ResultBean resultBean = arraylist.get(0).process(task); //返回处理结果 return resultBean.format(); } } 使用方法 1.创建一个base类,就是我上面写过的,可以是接口和抽象类 com.baidu.aip.fl.func.service.HandlerFace 2.一个或多个实现类 com.baidu.aip.fl.func.service.AgeHandlerFace.java com.baidu.aip.fl.func.service.BeautyHandlerFace.java com.baidu.aip.fl.func.service.GenderHandlerFace.java 这里一共是3个 3.定义resources/META-INF/ …. 文件 该文件无拓展名 文件名就是 base类 或者接口 的全路径( 包名 + Filename ) 文件中每一行写一个实现类的全路径名( 包名 + Filename ) src/main/resources/META-INF/services/com.baidu.aip.fl.func.service.HandlerFace com.baidu.aip.fl.func.service.GenderHandlerFace com.baidu.aip.fl.func.service.AgeHandlerFace com.baidu.aip.fl.func.service.BeautyHandlerFace 4.获取所有实现类 ServiceLoader&lt;HandlerFace&gt; processors = ServiceLoader.load(HandlerFace.class); //注意此时实现类都没有实例化 Iterator iterator = processors.iterator(); while (iterator.hasNext()) { //iterator.next() 这里具体实现类才真正的初始化了 arraylist.add((HandlerFace) iterator.next()); } 这样的懒加载过程是由ServiceLoader实现的 总结责任链这样的形式,为后期的扩展提供了很大的便利 AgeHandlerFace 中,我可以分更细的粒度,也可以合并. eg: 50 以下都是年轻人 100 - 50 是老年人 责任链虽然Android端最显著的算是 事件分发机制 ,很多框架中也都有使用,filter这样的东西 ServiceLoader这个东西,很强大 在插件化,以及 服务提供等方面都有应用","categories":[{"name":"Java","slug":"Java","permalink":"https://www.wangzhumo.com/categories/Java/"}],"tags":[{"name":"Java","slug":"Java","permalink":"https://www.wangzhumo.com/tags/Java/"},{"name":"设计模式","slug":"设计模式","permalink":"https://www.wangzhumo.com/tags/设计模式/"}]},{"title":"Android自定义一个遮罩引导层","slug":"Android-Shade","date":"2018-05-21T08:53:08.000Z","updated":"2019-12-22T12:03:49.815Z","comments":true,"path":"2018/05/21/Android-Shade/","link":"","permalink":"https://www.wangzhumo.com/2018/05/21/Android-Shade/","excerpt":"分析需求高亮显示指定的控件(1个或者多个) 只有一个高亮控件,则直接绘制即可 多个高亮控件,则分两种效果展示 顺序展示每一个控件 展示所有控件 高亮部分的形状 方形 圆形","text":"分析需求高亮显示指定的控件(1个或者多个) 只有一个高亮控件,则直接绘制即可 多个高亮控件,则分两种效果展示 顺序展示每一个控件 展示所有控件 高亮部分的形状 方形 圆形 展示与消失 自动展示,自动消失 点击消失 点击指定部分消失 实现方式遮罩层 直接在本来的页面是添加,不用时消失 使用DecorView的方式,添加view即可 使用透明Activity覆盖 选择第二种方式来实现 第一种方便但是耗时耗力,并且不能通用 第二种是大家都认可的一种方式,而且支持配置 第三种,对原界面生命周期造成影响,不太好 高亮的实现PorterDuffXfermode :: PorterDuff.Mode.XOR) 代码设计 mask layer View 用来实现遮罩层 高亮显示绘制\u0010 指示语位置 mask layer Manager 用来管理 遮罩层 addView Show / hide DecorView 操作 其他配置信息 mask bean 用来存放需要高亮的View信息(高度,宽度..) 实现mask: MaskGuideView 遮罩层容器 MaskLayout 高亮控件与指示语的位置,以及排列展示 MaskManager 加载管理整个遮罩层 MaskType 高亮控件的形状, 圆 方 TargetInfo 高亮控件的位置信息 TargetInfo.java /** * If you have any questions, you can contact by email { wangzhumoo@gmail.com} * * @author 王诛魔 2018/5/21 下午7:20 * * 高亮区域信息 */ public class TargetInfo { /* * 高亮区域起始X坐标 */ public int startX; /* * 高亮区域起始Y坐标 */ public int startY; /* * 高亮区域宽度 */ public int width; /* * 高亮区域高度 */ public int height; /* * 偏移量 */ public int offset = 10; /** * 获取半径 */ public int getRadius() { return Math.max(width, height) / 2; } } MaskType.java /** * If you have any questions, you can contact by email { wangzhumoo@gmail.com} * * @author 王诛魔 2018/5/21 下午7:18 */ public enum MaskType { Rect,Circle } /** * If you have any questions, you can contact by email { wangzhumoo@gmail.com} * * @author 王诛魔 2018/5/21 下午11:35 * * 负责管理,准备,操作MaskGuideView */ public class MaskManager { //属性 private static final String TAG = &quot;MaskManager&quot;; private final ViewGroup mRootView; private final MaskGuideView mMaskGuideView; private final Context mContext; private List&lt;TargetInfo&gt; mTargetInfoList; private List&lt;View&gt; mTargetViewList; private List&lt;MaskLayout&gt; mMaskLayoutList; private MaskType mMaskType; private boolean isShowAll; private int mPadding; /** * 计算targetInfo * * @param targetView view * @return TargetInfo */ private TargetInfo generateTargetInfo(View targetView) { int[] location = new int[2]; //我们需要的是,这个targetView在整个屏幕上的位置 targetView.getLocationOnScreen(location); TargetInfo targetInfo = new TargetInfo(); //计算startX width ... switch (mMaskType) { case Rect: targetInfo.startX = location[0] - mPadding; targetInfo.startY = location[1] - mPadding; targetInfo.width = targetView.getWidth() + 2 * mPadding; targetInfo.height = targetView.getHeight() + 2 * mPadding; break; case Circle: int diameter = Math.max(targetView.getWidth() + 2 * mPadding, targetView.getHeight() + 2 * mPadding); targetInfo.startX = location[0] - mPadding; targetInfo.startY = location[1] - mPadding - (diameter / 2 - targetView.getHeight() / 2 - mPadding); targetInfo.width = diameter; targetInfo.height = diameter; break; } Log.e(TAG, &quot;generateTargetInfo: &quot; + targetInfo.toString() ); return targetInfo; } /* * builder模式 */ public static class Builder { private ViewGroup mRootView; private MaskGuideView mMaskGuideView; private Context mContext; private List&lt;TargetInfo&gt; mTargetInfoList; private List&lt;MaskLayout&gt; mMaskLayoutList; private List&lt;View&gt; mTargetViewList; private MaskType mMaskType = MaskType.Circle; private int mPadding = 0; private int mGravity = Gravity.TOP; private boolean isShowAll; ...省略 public MaskManager build() { this.mMaskGuideView.setOnClickListener(this.mMaskGuideView); return new MaskManager(this); } } } 额,代码传git好了","categories":[],"tags":[{"name":"Android","slug":"Android","permalink":"https://www.wangzhumo.com/tags/Android/"},{"name":"View","slug":"View","permalink":"https://www.wangzhumo.com/tags/View/"}]},{"title":"Android Binder机制(一)","slug":"Android-Binder-1","date":"2018-05-11T05:56:25.000Z","updated":"2019-12-22T12:13:09.468Z","comments":true,"path":"2018/05/11/Android-Binder-1/","link":"","permalink":"https://www.wangzhumo.com/2018/05/11/Android-Binder-1/","excerpt":"ServiceManager首先我们要了解一下ServiceManager. ServiceManager的功能主要就是注册,查询服务,作为一个大管家的角色出现.","text":"ServiceManager首先我们要了解一下ServiceManager. ServiceManager的功能主要就是注册,查询服务,作为一个大管家的角色出现. 注册服务：记录服务名和信息，放到服务列表 查询服务：根据服务名查询相应的的信息 ServiceManager是有权限控制的，只有具有相应权限的进程才能注册,查询服务 http://gityuan.com/2015/11/08/binder-get-sm/ Linux内存内核空间为什么进程间不可以直接通讯那? 因为每个进程的内存空间都是隔离起来的,不可能随意去访问其他进程的内存. 在32位系统中,寻址空间最大为4G,那么这4G内存,一般将1G分配给内核空间,3G用户空间,Linux内核由系统内的所有进程共享. 这么一来,我们就可以在内核空间为所欲为了,不,并不能.用户进程不能直接操作内核. Android是在Linux的内核上跑的,那么为什么Android要自己做一个Binder来实现进程间的通讯那? 我们都知道Linux上Socket/管道/消息队列都可以做到进程间的通讯,但是通过这些都需要2次内存拷贝, 而Binder只需要一次就可以完成,大大的提高效率 BINDER_MMAPmmap可以将一个文件或者其它对象映射进内存 在Binder中,通过在用户空间(当前进程的用户空间)创建一个虚拟地址空间,并在内核空间创建相同大小的虚拟地址空间. 接着申请一块物理内存,将物理内存映射到内核虚拟地址空间和用户虚拟内存空间,这样就实现了用户控件和内核空间的同步. 大概流程 copy_from_user 首先是要发出消息的,那么先从用户控件from 拷贝数据 binder_thread_write 第二步就是把刚才拷贝的数据写入到内核空间 binder_thread_read 第三步再次读取刚才从用户控件from读取并写入内核空间的数据 copy_to_user 最后当然是从内核空间拷贝数据到用户空间to(即目标) PS:以上均建立在每一次操作都成功的基础上 来自Gityuan大神的分享http://gityuan.com/2015/11/01/binder-driver/ 解释说明: 首先Client端发送消息,通过copy_from_user从Client端拷贝数据到内核空间去 而后还记得BINDER_MMAP中的操作么,内核空间的地址与Server是同一块物理内存, Server就可以通过这个方式,直接同步到Client发送的数据. binder_init：初始化字符设备； binder_open：打开驱动设备，过程需要持有binder_main_lock同步锁； binder_mmap：申请内存空间，该过程需要持有binder_mmap_lock同步锁； binder_ioctl：执行相应的ioctl操作，该过程需要持有binder_main_lock同步锁； 当处于binder_thread_read过程，read_buffer无数据则释放同步锁，并处于wait_event_freezable过程，等有数据到来则唤醒并尝试持有同步锁。","categories":[],"tags":[{"name":"Android","slug":"Android","permalink":"https://www.wangzhumo.com/tags/Android/"},{"name":"Source Code","slug":"Source-Code","permalink":"https://www.wangzhumo.com/tags/Source-Code/"},{"name":"Binder","slug":"Binder","permalink":"https://www.wangzhumo.com/tags/Binder/"}]},{"title":"线程与进程的异同以及Android中的IPC机制","slug":"Thread-Process-IPC","date":"2018-05-10T09:16:06.000Z","updated":"2019-12-22T12:06:11.987Z","comments":true,"path":"2018/05/10/Thread-Process-IPC/","link":"","permalink":"https://www.wangzhumo.com/2018/05/10/Thread-Process-IPC/","excerpt":"线程与进程Google Doc (https://developer.android.com/guide/components/processes-and-threads) 进程是资源分配的最小单位，线程是cpu调度的最小单位. 进程是应用程序的执行实例,一个进程中可以包含多个线程, 而一个进程的创建分配是要消耗较大的性能的,相比来说线程就要比进程的开销小. 对于进程来说不共享资源,内存是独立的.而线程共享它所在的线程的资源,内存. 进程间的通信就要更加麻烦,需要使用IPC( Inter-Proscess Communication)进程间的通讯 线程方便很多,但是线程间的同步又是一个较为大的课题了. 想强调的是，线程关注的是中央处理器的运行，而不是进程那样关注内存等资源的管理。","text":"线程与进程Google Doc (https://developer.android.com/guide/components/processes-and-threads) 进程是资源分配的最小单位，线程是cpu调度的最小单位. 进程是应用程序的执行实例,一个进程中可以包含多个线程, 而一个进程的创建分配是要消耗较大的性能的,相比来说线程就要比进程的开销小. 对于进程来说不共享资源,内存是独立的.而线程共享它所在的线程的资源,内存. 进程间的通信就要更加麻烦,需要使用IPC( Inter-Proscess Communication)进程间的通讯 线程方便很多,但是线程间的同步又是一个较为大的课题了. 想强调的是，线程关注的是中央处理器的运行，而不是进程那样关注内存等资源的管理。 Android中的IPC机制如下图所示:(已经不知道哪里的配图了…感谢分享) IPC简介IPC(Inter-Process Communication) 进程间通信 使用场景: 在Android程序中，一般情况下一个程序就是一个进程 App间的通信,常见的如需要使用其他App的数据 一个App使用多进程,比如指定运行线程android:process=&quot;:name&quot; 需要注意的是,如果一个App使用多进程,Application也会多次创建 Bundle常见于Activity,service中传递数据 需要注意的是,bundle中的数据必须支持序列化(Serializable,Parcelable) 文件共享SharedPreference就是这种实现的. 适合对同步要求不高的使用方式,需要注意处理好并发的问题. MessengerMessenger 对 AIDL 进行了封装，它实现了一种基于消息的进程间通信的方式 frameworks/base/core/java/android/os/IMessenger.aidl 它的AIDL文件就在这里保存着! AIDLAIDL（Android Interface definition language） 是 Android 提供的一种进程间通信 (IPC) 机制 需要注意的是AIDL支持的数据类型与Java接口支持的数据类型有些不同: 所有基础类型（int, char…） String，List，Map 所有Parcelable的类 并且要根据需要添加 in out 的关键词 ContentProvider主要是针对数据库使用的,最常见的例子就是Android中有很多已经定义好的ContentProvider Socket说到这里,就不得不提一下Binder了 http://www.wangzhumo.com/Source-Code/Android-Binder%E6%9C%BA%E5%88%B6-%E4%B8%80/","categories":[{"name":"Java","slug":"Java","permalink":"https://www.wangzhumo.com/categories/Java/"}],"tags":[{"name":"Java","slug":"Java","permalink":"https://www.wangzhumo.com/tags/Java/"}]},{"title":"Java中的内存模型","slug":"Java-memory-module","date":"2018-05-09T14:26:54.000Z","updated":"2019-12-22T12:09:45.514Z","comments":true,"path":"2018/05/09/Java-memory-module/","link":"","permalink":"https://www.wangzhumo.com/2018/05/09/Java-memory-module/","excerpt":"","text":"1. 堆在JVM中只有一个,java回收机制主要就是作用于这一块 堆主要是用来存放存储对象的内容及其本身的. 2. 方法区方法区也和堆一样,是被线程共享的. 存放了类的信息(方法,字段,名称),静态变量,常量 Java1.7之前,字符串常量池也是放在这里的,但是1.7以后移动到堆里面去了 3. 虚拟机栈 每一个栈帧的出入栈都是一个方法被调起直到结束返回的过程. 每个线程都会有一个自己的Java栈，栈帧中包括 局部变量表(Local Variables) 方法中的局部变量,函数的参数等.对于基础类型的变量直接存储他的值,而引用类型的变量 则存储的是指向对象的引用 操作数栈(Operand Stack) 指向运行时常量池的引用(Reference to runtime constant pool) 保证方法可以使用当前类的常量 方法返回地址(Return Address) 执行一个方法完成后需要返回调用它的地方 附加信息 4. 程序计数器Program Counter Register 也称作为PC寄存器,保存的是程序当前执行的指令的地址 5.本地方法栈本地方法栈则是为执行本地方法（Native Method）服务的","categories":[{"name":"Java","slug":"Java","permalink":"https://www.wangzhumo.com/categories/Java/"}],"tags":[{"name":"Java","slug":"Java","permalink":"https://www.wangzhumo.com/tags/Java/"}]},{"title":"Android的启动流程","slug":"Android-App-Launch","date":"2018-05-09T07:00:12.000Z","updated":"2019-12-22T12:12:44.312Z","comments":true,"path":"2018/05/09/Android-App-Launch/","link":"","permalink":"https://www.wangzhumo.com/2018/05/09/Android-App-Launch/","excerpt":"系统结构 应用层 即为开发出来的一些app,当然还包括了一些系统App 应用框架层(Java API Framework) 这一层由java编写,提供给我们平时开发使用的API,主要的一些组件: Manager Activity Manager , Window Manager , Package Manager ,Location Manager Notification Manager,Resource Manager,Telephony Manager Content Providers View System 系统运行库层 C/C++程序库和Android运行时库 硬件抽象层(HAL) Linux内核层","text":"系统结构 应用层 即为开发出来的一些app,当然还包括了一些系统App 应用框架层(Java API Framework) 这一层由java编写,提供给我们平时开发使用的API,主要的一些组件: Manager Activity Manager , Window Manager , Package Manager ,Location Manager Notification Manager,Resource Manager,Telephony Manager Content Providers View System 系统运行库层 C/C++程序库和Android运行时库 硬件抽象层(HAL) Linux内核层 Android的启动主要过程 init进程 init进程是由内核启动的,是用户空间的第一个进程,可以说是一个root进程 当init进程启动后会创建挂载系统目录,设备节点, 解析init.rc 和 init.hardware.rc,启动属性服务，以及一系列的服务和进程 本地守护进程 启动 servicemanager 管理binder的通讯 surfaceflinger UI mediaserver 音视频,相机 netd 蓝牙、wifi、usb等 adbd rild installd 需要注意的是这些都是一个独立的Linux进程 Native系统服务 运行在本地守护进程中,所属进程初始化的时候会将Native系统服务注册到ServiceManager中,方便我们通过Binder机制调用Native系统服务 Java服务 再创建本地服务的同时,init进程还会创建Zygote进程 Zygote也是Android中相当重要的一个进程了,Zygote进程会建立一个Dalvik VM并且启动 System Server系统服务 System Server将启动Android Service AccessibilityManagerService 截获用户输入，并根据输入给用户一些额外的反馈，起到辅助效果的服务AccountManagerService 管理设备中所有账号的服务，包括账号、密码、授权管理功能ActivityManagerService 管理所有组件的服务，安卓系统的核心服务 AlarmManagerService 管理闹钟的服务AppWidgetService 管理APP widgets的工作，包括加载、删除、布局等AssetAtlasService 将一些系统图片资源合并成一个纹理图传给GPU达到硬件加速的效果的服务AudioService 管理音频的服务BackupManagerService 管理备份和应用数据的服务BatteryService 管理电池的服务BluetoothManagerService 管理系统蓝牙的服务CertBlacklister 更新系统SSL证书的公共秘钥和序列号黑名单的服务ClipboardService 管理系统剪贴板的服务CommonTimeManagementService 管理公共时间配置的服务ConnectivityService 管理网络连接的服务ContentService 管理系统数据更新通知的服务，和ContentProvider密切相关CountryDetectorService 检测当前系统所属国家的服务DevicePolicyManagerService 管理系统设备配置的服务DeviceStorageMonitorService 管理系统存储空间的服务，当存储空间小于某个阈值时，会发出警告广播DiskStateService 管理系统存储空间统计的服务DisplayManagerService 管理显示设备的服务DreamManagerService 管理屏幕保护的服务DropBoxManagerService 生成和管理系统运行中日志文件的服务EntropyMixer 加载和保存随机信息的服务IdleMaintenanceService 管理系统在空闲时执行维护任务的服务InputManagerService 管理触屏输入的服务InputMethodManagerService 管理系统输入法的服务LightsService 管理光传感器的服务LocationManagerService 管理定位和位置的服务LockSettingsService 管理系统锁屏设置的服务MountService 管理系统存储设备挂载和卸载的服务NetWorkManagementService 管理系统网络的服务NetWorkPolicyManagerService 管理网络连接策略的服务NetWorkStatsService 管理网络连接状态的服务NetWorkTimeUpdateService 根据网络时间更新本地时间的服务NotificationManagerService 管理系统通知的服务PackageManagerService 管理应用包的服务PowerManagerService 管理系统电源的服务PrintManagerService 管理打印的服务RecognitionManagerService 管理身份识别的服务SamplingProfilerService 记录和分析系统启动性能的服务SchedulingPolicyService 管理系统调度策略的服务SearchManagerServcie 管理系统搜索功能的服务SerialServie 管理系统串口设备的服务StatusBarManagerService 管理系统状态栏的服务TelephonyRegistry 监听和管理通话事件和状态的服务TextServicesManagerService 文本拼写检查的服务UiModeManagerService 设置和管理系统UI模式的服务UsbService 管理USB连接的服务UserManagerService 管理系统用户身份信息的服务VibratorService 管理系统振动器的服务ＷallpaperManagerService 管理系统桌面背景墙纸的服务WifiP2pService 管理Wifi点对点连接的服务WifiService 管理系统Wifi设备的服务WindowManagerService 管理窗口的服务，安卓系统的核心服务 这些服务都会注册到Service Manager中去,完成ServcieManager对服务的管理 需要注意的是,由System Server创建的这些服务,都是存在于System Server进程中的线程 举例说明一下 servicemanager是init的子进程 Zygote是init的子进程，fork出来所有的虚拟机 system server是Zygote的子进程 Home启动 当所有的任务启动后,会通过ActivityManager启动Home界面 同时发送ACTION_BOOT_COMPLETED广播","categories":[{"name":"Source Code","slug":"Source-Code","permalink":"https://www.wangzhumo.com/categories/Source-Code/"}],"tags":[{"name":"Android","slug":"Android","permalink":"https://www.wangzhumo.com/tags/Android/"},{"name":"Source Code","slug":"Source-Code","permalink":"https://www.wangzhumo.com/tags/Source-Code/"}]},{"title":"JVM虚拟机中的类加载器","slug":"JVM-class-loader","date":"2018-03-11T02:35:47.000Z","updated":"2019-12-22T12:09:14.814Z","comments":true,"path":"2018/03/11/JVM-class-loader/","link":"","permalink":"https://www.wangzhumo.com/2018/03/11/JVM-class-loader/","excerpt":"前言前一篇梳理了一下类加载机制的大概流程,其中就涉及到一个很重要的东西类加载器,在加载阶段”通过一个类的全限定名获取描述此类的二进制字节流” 我们知道二级制字节流不只是我们编写的代码 可以从一些jar,war包等压缩文件中获取 已经凉了的Applet,也就是可以从网络中获取 运行时生成,如动态代理,retrofit中使用的技术之一 其他… 那么下面我要知道的是: 类加载器的含义和作用 类加载器的类型 类加载器的应用","text":"前言前一篇梳理了一下类加载机制的大概流程,其中就涉及到一个很重要的东西类加载器,在加载阶段”通过一个类的全限定名获取描述此类的二进制字节流” 我们知道二级制字节流不只是我们编写的代码 可以从一些jar,war包等压缩文件中获取 已经凉了的Applet,也就是可以从网络中获取 运行时生成,如动态代理,retrofit中使用的技术之一 其他… 那么下面我要知道的是: 类加载器的含义和作用 类加载器的类型 类加载器的应用 类加载器类加载器最初是为了Java Applet的需求而研发的,为了方便应用程序自己决定如何去获取所需要的类,而把这个操作放到了JAVA虚拟机外部去实现. 实现这个动作的代码模块被称为类加载器 有一点需要注意的是,在JVM中,任意一个类都需要由类加载器和它本省共同确立其在JVM中的唯一性 每一个类加载器都拥有一个独立的类命名空间. 变现为: 如果同一个类,被不同的两个类加载器加载,那么它们就必然不相等. 类加载器的类型 启动类加载器 Bootstrap ClassLoader ,是由C++实现的,作为虚拟机的一部分 其他类加载器,这些加载器都是由JAVA语言实现的,独立于JVM之外并且都是java.lang.ClassLoader的子类 上面的分类是对于JVM而言的分类,在我们编码的过程中,对类加载器分为; 启动类加载器 Bootstrap ClassLoader, 负责将/lib 目录中的文件加载到虚拟机内存中 扩展类加载器 Extension ClassLoader 负责加载/lib/ext 目录中的文件,或者被 java.ext.dirs系统变量指定的路径中文件 我们可以直接使用扩展类加载器 应用程序类加载器 Application ClassLoader ClassLoader.getSystemClassLoader()方法可以返回,一般称为系统类加载器 负责加载用户路径中的类库,如果程序中没有使用自定义的类加载器,则默认是使用该类加载器的 双亲委派模型#####模型结构 //我们看看代码中是怎么组织的 protected Class&lt;?&gt; loadClass(String name, boolean resolve) throws ClassNotFoundException { // First, check if the class has already been loaded Class&lt;?&gt; c = findLoadedClass(name); if (c == null) { try { if (parent != null) { c = parent.loadClass(name, false); } else { c = findBootstrapClassOrNull(name); } } catch (ClassNotFoundException e) { // ClassNotFoundException thrown if class not found // from the non-null parent class loader } if (c == null) { // If still not found, then invoke findClass in order // to find the class. c = findClass(name); } } return c; } 上面的代码,总的来说有 findLoadedClass(name) 查找是否已经加载过这个class了,如果不为空就直接返回了这个class 在看下一步 try { if (parent != null) { c = parent.loadClass(name, false); } else { c = findBootstrapClassOrNull(name); } } 如果父加载器 parent不为空,则加载工作交给父加载器去执行, 而这个父加载器也会有它的父加载器 最后如果这个class还没有加载 if (c == null) { // If still not found, then invoke findClass in order // to find the class. c = findClass(name); } 才轮到自己去加载 要注意的是,这些类加载器的父子关系,不是由继承来实现的,而是使用组合 模型加载流程类加载器收到了一个类加载的请求,但是不会立马去自己加载,而是委派给父加载器去尝试加载,然后层层委派直到顶层的启动类加载器中.如果没有成功加载,子加载器才会自己去加载. 这样做是有明显的好处的: 这些类加载器都具有了优先级关系 保证了某些类的一致性,如Object,通过委派,最终都是由最顶层的启动类加载器完成加载的. 类加载器的应用先来看一个例子,加深一下理解 //一个类,需要放在项目目录外,避免被系统类加载器加载 public class TestClassLoader{ public void createBy(){ System.out.println(&quot;I&#39;m Batman , Come from &quot; + getClass().getClassLoader().getClass()); } } 自定义的类加载器 import java.io.FileInputStream; //自定义的类加载器 public class MarvelStudios extends ClassLoader { //存放的是TestClassLoader.class的位置,记得先编译成class再使用 private final static String CLASS_FILE_PATH = &quot;/Users/phyooos/workspace/java_workspace/kotlind/soucre/TestClassLoader.class&quot;; private byte[] loadByte(String name) throws Exception { FileInputStream fis = new FileInputStream(CLASS_FILE_PATH); int len = fis.available(); byte[] data = new byte[len]; fis.read(data); fis.close(); return data; } @Override protected Class&lt;?&gt; findClass(String name) throws ClassNotFoundException { //这里获取文件 try { byte[] data = loadByte(name); return defineClass(name, data, 0, data.length); } catch (Exception e) { e.printStackTrace(); throw new ClassNotFoundException(); } } } 测试一下 public class MainClass { public static void main(String[] args){ MarvelStudios classLoader = new MarvelStudios(); Class clazz = null; try { clazz = classLoader.loadClass(&quot;TestClassLoader&quot;); Object obj = clazz.newInstance(); Method createMethod = clazz.getDeclaredMethod(&quot;createBy&quot;,null); createMethod.invoke(obj, null); } catch (Exception e) { e.printStackTrace(); } } } 运行结果为 I&#39;m Batman , Come from class MarvelStudios Process finished with exit code 0 这里显而易见,使用了自定义的类加载器,从硬盘上加载了一个class文件,如果你想加载一个java文件,也只需要调用 //defineClass方法可以把二进制流字节组成的文件转换为一个java.lang.Class Class&lt;?&gt; c = this.defineClass(name, bytes, 0, bytes.length); 这只是一个简单的自定义类加载器使用,可以从硬盘上加载java代码. 其他如: 代码加密 热部署 热修复","categories":[{"name":"Java","slug":"Java","permalink":"https://www.wangzhumo.com/categories/Java/"}],"tags":[{"name":"Java","slug":"Java","permalink":"https://www.wangzhumo.com/tags/Java/"}]},{"title":"JVM虚拟机的类加载机制","slug":"JVM-load-class","date":"2018-03-10T03:20:10.000Z","updated":"2019-12-22T12:09:09.261Z","comments":true,"path":"2018/03/10/JVM-load-class/","link":"","permalink":"https://www.wangzhumo.com/2018/03/10/JVM-load-class/","excerpt":"前言关于JVM虚拟机的类加载机制,大概有如下的几个问题 类加载机制是什么? 类加载的流程","text":"前言关于JVM虚拟机的类加载机制,大概有如下的几个问题 类加载机制是什么? 类加载的流程 类加载机制我们所写的Java代码,最终都是编译成class字节码文件,这些字节码文件描述了各种信息 需要加载到虚拟机中才能使用运行 而虚拟机啊把描述类的数据从Class文件中加载到内存,并且对数据进行校验,转换解析和初始化, 最终形成可以被虚拟机直接使用的Java类型,这就是虚拟机的类加载机制. 类加载机制的流程虚拟机中类加载的全过程: 加载 , 验证 ,准备 , 解析 , 初始化这五个部分 加载在加载阶段,完成的是: 通过类的全限定名(import * 这些)来获取定义此类的二进制字节流. 将这个二进制字节流的静态存储结构转化为方法区的运行时数据结构. 在内存中生成一个代表这个类的java.lang.Class对象,作为方法区这个类的各种数据的访问入口. 当我们的虚拟机将二进制字节流文件加载后,会存放在方法区中,而后实例化一个Class类的对象,(对于HotSpot虚拟机而言)会放在方法区中,而不是一般存放对象,引用类型的堆(heap)中,这个Class对象就可以作为程序访问方法区中这些类型数据的外部接口. PS:加载的过程中,也可能会伴随着 连接过程(检查,准备,解析),但是必然是先发生加载,而后才可能出现连接 验证验证这个阶段非常的重要 我们知道在JAVA代码中,是无法进行一些不安全的操作的,但是class字节码文件却可以做到,类似数组越界访问,跳转到不存在的代码行…. 那么,验证就非常重要了,直接决定了Java虚拟机的安全性. 大概包含: 文件格式验证只有通过了文件格式验证,字节码二进制流才会进入到方法区中. 比如: 魔数CAFEBABE ,主次版本号,常量池中常量类型,编码等等… #####元数据验证 主要目的是对类的元数据进行语义检验,确保描述信息符合JAVA的语言规范 比如:是否有父类,是否实现了所继承类或实现接口的必要方法,返回值类型… #####字节码验证 在元数据验证对元数据中的数据类型做完检测后,这个阶段会对类的方法体进行校验分析,保证被验证的类方法不会在运行时对虚拟机做出不安全操作. 符号引用验证发生在虚拟机将符号引用转化为直接引用的时候,这个转化的操作将发生在-解析阶段. 符号引用:符号引用以一组符号来描述所引用的目标，符号可以是任何形式的字面量，只要使用时能够无歧义的定位到目标即可。在编译时，java类并不知道所引用的类的实际地址，因此只能使用符号引用来代替。 直接引用:如果有了直接引用，那引用的目标必定已经被加载入内存中了.直接引用有:1直接指向目标的指针 2.相对偏移量3.一个能间接定位到目标的句柄 ####准备 准备阶段是正式为变量分配内存并设置类变量初始值的阶段,这些变量的内存都将在方法区进行分配. 类变量:被static修饰的变量,这里还有一个要注意的就是final修饰的,这是一种特殊情况,会在准备阶段就初始化为指定的值.(在字段属性表中表现为ConstantValue属性) 而不是像通常情况下,会给静态变量赋零值. 解析在符号引用验证中提到过,这个阶段是虚拟机将常量池内的符号引用替换为直接引用的过程. 解析的操作一般针对类,接口,字段,类方法,接口方法,方法类型,方法句柄和调用点限定符7类符号引用 大概分为: 类或者接口的解析,字段解析,类方法解析,接口方法解析 初始化初始化是类加载的最后一个阶段,之前的阶段,除了在加载阶段可以通过自定义类加载器参与之外,其他的都是由虚拟机主导和控制.而到了初始化阶段,才真正开始执行类中定义的JAVA代码,这个阶段根据代码中定义好的计划去初始化类变量和其他资源. 初始化阶段是执行类构造器&lt;client&gt;()方法的过程.","categories":[{"name":"Java","slug":"Java","permalink":"https://www.wangzhumo.com/categories/Java/"}],"tags":[{"name":"Java","slug":"Java","permalink":"https://www.wangzhumo.com/tags/Java/"}]},{"title":"Android通讯机制分析-Handler","slug":"Handler-analyze","date":"2018-03-07T06:13:47.000Z","updated":"2019-12-22T12:09:50.960Z","comments":true,"path":"2018/03/07/Handler-analyze/","link":"","permalink":"https://www.wangzhumo.com/2018/03/07/Handler-analyze/","excerpt":"Handler在Android世界中的地位不言而喻.这篇笔记算是简单的记录一下我对于Handler的理解. 当时第一次对Handler产生兴趣是我在知乎上看到一个问题: Android中为什么主线程不会因为Looper.loop()里的死循环卡死","text":"Handler在Android世界中的地位不言而喻.这篇笔记算是简单的记录一下我对于Handler的理解. 当时第一次对Handler产生兴趣是我在知乎上看到一个问题: Android中为什么主线程不会因为Looper.loop()里的死循环卡死 Handler消息机制的构成 Handler 主要就是发送各种消息sendMessage等,以及处理消息handleMessage Message 即是传递消息的载体,有时候也会承载硬件发出的消息. Looper 这是一个循环Looper.loop,并负责将消息发送给目标. MessageQueue 消息队负责将消息发送都消息池以及在消息池中拿走消息 Message类分析首先我们要看到 private static Message sPool; // sometimes we store linked lists of these things /*package*/ Message next; sPool声明为static 也就是说所有的Message实例共享 next则为每一个实例都有的 Message类中,一系列的obtain,如下: obtain(Handler h) obtain(Handler h, int what) obtain(Handler h, Runnable callback) … obtain() 复用机制 我们查看源码可知,他们最后都调用obtain()获得一个Message实体 android.os.Message#obtain() /** * Return a new Message instance from the global pool. Allows us to * avoid allocating new objects in many cases. */ public static Message obtain() { synchronized (sPoolSync) { if (sPool != null) { Message m = sPool; sPool = m.next; m.next = null; m.flags = 0; // clear in-use flag sPoolSize--; return m; } } return new Message(); } 可以看到,当sPool为null时才会new Message(); 如果不为null则把当前的sPool赋值给Message m 而后把sPool赋值为m.next()(也就是sPool没有赋值前它的下一个Message对象) 查看源码分析可知,有一个Message的消息池,采用的是单链表头插法,next永远指向的是下一个可复用的实例地址 所以,如果我们在代码中要使用Message实例,就尽量使用obtain()这一系列方法,而不要直接New 加入消息池 android.os.Message#recycleUnchecked /** * Recycles a Message that may be in-use. * Used internally by the MessageQueue and Looper when disposing of queued Messages. */ void recycleUnchecked() { // Mark the message as in use while it remains in the recycled object pool. // Clear out all other details. flags = FLAG_IN_USE; what = 0; arg1 = 0; arg2 = 0; obj = null; replyTo = null; sendingUid = -1; when = 0; target = null; callback = null; data = null; synchronized (sPoolSync) { if (sPoolSize &lt; MAX_POOL_SIZE) { next = sPool; sPool = this; sPoolSize++; } } } 这里其实就是把无用的Message实例,加入消息池的地方. sPoolSize &lt; MAX_POOL_SIZE只要当前消息池没有到极限,就next = sPool;且sPool = this; 可以简单理解为把之前的sPool可复用对象向后移动一位,把当前这个要回收的Message置为第一个可复用对象 所以,Message主要就是装载数据,并且实现了Message的复用机制 MessageQueue类分析","categories":[{"name":"Source Code","slug":"Source-Code","permalink":"https://www.wangzhumo.com/categories/Source-Code/"}],"tags":[{"name":"Android","slug":"Android","permalink":"https://www.wangzhumo.com/tags/Android/"},{"name":"Source Code","slug":"Source-Code","permalink":"https://www.wangzhumo.com/tags/Source-Code/"}]},{"title":"RelativeLayout中Button覆盖其他View","slug":"RelativeLayout-Button-over","date":"2018-03-07T03:53:36.000Z","updated":"2019-12-22T12:07:24.703Z","comments":true,"path":"2018/03/07/RelativeLayout-Button-over/","link":"","permalink":"https://www.wangzhumo.com/2018/03/07/RelativeLayout-Button-over/","excerpt":"前言布局文件中,RelativeLayout包裹时,在RelativeLayout中的View,应该是”层层压上”的. 越往底下写的Viwe,在视图上越在上层.","text":"前言布局文件中,RelativeLayout包裹时,在RelativeLayout中的View,应该是”层层压上”的. 越往底下写的Viwe,在视图上越在上层. 问题activity_main.xml&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt; &lt;layout xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot; xmlns:app=&quot;http://schemas.android.com/apk/res-auto&quot; xmlns:tools=&quot;http://schemas.android.com/tools&quot;&gt; &lt;data&gt; &lt;variable name=&quot;click&quot; type=&quot;com.wangzhumo.app.single.MainActivity.ClickFunc&quot;/&gt; &lt;/data&gt; &lt;RelativeLayout android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;match_parent&quot; tools:context=&quot;com.wangzhumo.app.single.MainActivity&quot;&gt; &lt;ImageView android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;match_parent&quot; android:layout_marginBottom=&quot;50dp&quot; tools:background=&quot;@tools:sample/backgrounds/scenic&quot;/&gt; &lt;Button android:id=&quot;@+id/button_finsh&quot; android:layout_width=&quot;wrap_content&quot; android:layout_height=&quot;wrap_content&quot; android:layout_alignParentTop=&quot;true&quot; android:layout_centerHorizontal=&quot;true&quot; android:onClick=&quot;@{(v) -&gt; click.onFinshAct(v)}&quot; android:text=&quot;Finsh&quot; /&gt; &lt;Button android:id=&quot;@+id/button_dis&quot; android:layout_width=&quot;wrap_content&quot; android:layout_height=&quot;wrap_content&quot; android:layout_alignParentEnd=&quot;true&quot; android:layout_alignParentTop=&quot;true&quot; android:onClick=&quot;@{(v) -&gt; click.onStartAct(v)}&quot; android:text=&quot;Start&quot; tools:ignore=&quot;MissingConstraints&quot; tools:layout_editor_absoluteX=&quot;88dp&quot; tools:layout_editor_absoluteY=&quot;0dp&quot; /&gt; &lt;Button android:id=&quot;@+id/button_start&quot; android:layout_width=&quot;wrap_content&quot; android:layout_height=&quot;wrap_content&quot; android:onClick=&quot;@{(v) -&gt; click.onShowDialog(v)}&quot; android:text=&quot;Dialog&quot; tools:ignore=&quot;MissingConstraints&quot; tools:layout_editor_absoluteX=&quot;176dp&quot; tools:layout_editor_absoluteY=&quot;0dp&quot; /&gt; &lt;Button android:id=&quot;@+id/button2&quot; android:layout_width=&quot;wrap_content&quot; android:layout_height=&quot;wrap_content&quot; android:layout_alignParentStart=&quot;true&quot; android:onClick=&quot;@{(v) -&gt; click.onPxActivity(v)}&quot; android:layout_below=&quot;@+id/button_start&quot; android:layout_marginTop=&quot;22dp&quot; android:text=&quot;Pixe&quot; /&gt; &lt;Button android:id=&quot;@+id/button3&quot; android:layout_width=&quot;wrap_content&quot; android:layout_height=&quot;wrap_content&quot; android:onClick=&quot;@{(v) -&gt; click.onTralActivity(v)}&quot; android:layout_alignStart=&quot;@+id/button_finsh&quot; android:layout_alignTop=&quot;@+id/button2&quot; android:text=&quot;Tranl&quot; tools:text=&quot;@tools:sample/lorem/random&quot;/&gt; &lt;ImageView android:layout_marginBottom=&quot;100dp&quot; android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;match_parent&quot; tools:background=&quot;@tools:sample/backgrounds/scenic&quot;/&gt; &lt;/RelativeLayout&gt; &lt;/layout&gt; View的结构如下: 然而实际效果如下: 分析如下:造成这样效果,是Button的原因 分析:整个页面除了 2,3,4,5 这5个Button之外,其他的View都依旧遵循RelativeLayout的规则 解决方案在stackoverflow上我找到了Button造成这个效果的原因 https://stackoverflow.com/questions/27080338/android-5-0-androidelevation-works-for-view-but-not-button/27112143#27112143 是因为Android5.0之后,Button默认添加了StateListAnimator,具体就是对 android:elevation android:translationZ 两个属性进行了修改,我们如何去掉这个默认的效果那? ##### android:stateListAnimator设置为null即可 &lt;Button ... android:stateListAnimator=&quot;@null&quot; /&gt; 如果你需要添加stateListAnimator效果的话 &lt;Button ... android:stateListAnimator=&quot;@anim/you_animator&quot; /&gt;","categories":[{"name":"Bug","slug":"Bug","permalink":"https://www.wangzhumo.com/categories/Bug/"}],"tags":[{"name":"Android","slug":"Android","permalink":"https://www.wangzhumo.com/tags/Android/"},{"name":"Bug","slug":"Bug","permalink":"https://www.wangzhumo.com/tags/Bug/"}]},{"title":"ConfigChanges的属性值","slug":"ConfigChanges","date":"2018-03-05T09:51:12.000Z","updated":"2019-12-22T12:11:40.322Z","comments":true,"path":"2018/03/05/ConfigChanges/","link":"","permalink":"https://www.wangzhumo.com/2018/03/05/ConfigChanges/","excerpt":"","text":"通过设置这个属性可以使Activity捕捉设备状态变化 &quot;mcc&quot; 国际移动用户识别码所属国家代号是改变了----- sim被侦测到了，去更新mcc mcc是移动用户所属国家代号 &quot;mnc&quot; 国际移动用户识别码的移动网号码是改变了------ sim被侦测到了，去更新mnc MNC是移动网号码，最多由两位数字组成，用于识别移动用户所归属的移动通信网 &quot;locale&quot; 地址改变了-----用户选择了一个新的语言会显示出来 &quot;touchscreen&quot; 触摸屏是改变了------通常是不会发生的 &quot;keyboard&quot; 键盘发生了改变----例如用户用了外部的键盘 &quot;keyboardHidden&quot; 键盘的可用性发生了改变 &quot;navigation&quot; 导航发生了变化-----通常也不会发生 &quot;screenLayout&quot; 屏幕的显示发生了变化------不同的显示被激活 &quot;fontScale&quot; 字体比例发生了变化----选择了不同的全局字体 &quot;uiMode&quot; 用户的模式发生了变化 &quot;orientation&quot; 屏幕方向改变了 &quot;screenSize&quot; 屏幕大小改变了 &quot;smallestScreenSize&quot; 屏幕的物理大小改变了，如：连接到一个外部的屏幕上 http://www.cnblogs.com/carlo/p/4311010.html","categories":[{"name":"Android","slug":"Android","permalink":"https://www.wangzhumo.com/categories/Android/"}],"tags":[{"name":"Android","slug":"Android","permalink":"https://www.wangzhumo.com/tags/Android/"}]},{"title":"Activity与Fragment的生命周期","slug":"Activity-Fragment-life","date":"2018-03-05T06:02:42.000Z","updated":"2019-12-22T12:12:33.061Z","comments":true,"path":"2018/03/05/Activity-Fragment-life/","link":"","permalink":"https://www.wangzhumo.com/2018/03/05/Activity-Fragment-life/","excerpt":"前言做Android开发好些年了,这些基础的知识,完完整整的在博客上写一次. Activity生命周期必不可少的一张图,来自Google Android developer 的文档上","text":"前言做Android开发好些年了,这些基础的知识,完完整整的在博客上写一次. Activity生命周期必不可少的一张图,来自Google Android developer 的文档上 回调方法简述 onCreate() 当Activity创建时,会回调该方法,常用于初始化View 或其他的一些功能的初始化 onStart() Activity已经初始化完毕,此时的页面是可见状态,则回调onStart();方法 Activity启动：onCreate() -&gt; onStart() -&gt; onResume() onResume() 当Activity可见,并且获得焦点,可以与用户交互时回调 在我们处理一些视屏操作,或者是Fragment懒加载等都可以用到 onPause() 当调用onPause()时,说明Activity被阻挡,部分UI已经不可见了,但是Activity的UI并没有完全消失. onStop() 当Activity完全不可见,且到了后台之后,如果系统内存不足,系统可能会杀死当前Activity 在这个方法中可以取消一些动画效果等 onDestory() Activity退出,销毁 常用于销毁,回收资源 经典场景1.正常启动 系统调用onCreate方法 , 然后调用onStart() , 最后调用 onResume() ,用户可操作. E/MainActivity: ---- onCreate ---- E/MainActivity: ---- onStart ---- E/MainActivity: ---- onResume ---- 2.正常退出 Activity先失去焦点不可交互 E/MainActivity: ---- onPause ---- E/MainActivity: ---- onStop ---- E/MainActivity: ---- onDestroy ---- 2.弹出Dialog MainActivity什么log也没有打印,说明不对Activity造成影响 3.跳转一个透明的Activity页面(1像素的同理) MainActivity只调用了onPause() 因为MainActivity的UI被遮挡了 E/MainActivity: ---- onPause ---- 4.从被遮挡状态恢复 E/MainActivity: ---- onResume ---- 6.锁屏 E/MainActivity: ---- onPause ---- E/MainActivity: ---- onStop ---- 此时,MainActivity已经在后台了. 7.从锁屏恢复 E/MainActivity: ---- onStart ---- E/MainActivity: ---- onResume ---- 可以发现,不仅仅走了onResume() ,还走了一次onStart() 8.横竖屏切换 正常切换 E/MainActivity: ---- onPause ---- E/MainActivity: ---- onStop ---- E/MainActivity: ---- onDestroy ---- E/MainActivity: ---- onCreate ---- E/MainActivity: ---- onStart ---- E/MainActivity: ---- onResume ---- 如果你什么都不设置,直接切换是这样的. 保留Activity的切换 我在manifest.xml文件中,添加了 &lt;activity android:name=&quot;.MainActivity&quot; android:configChanges=&quot;orientation|screenSize&quot;&gt; &lt;intent-filter&gt; &lt;action android:name=&quot;android.intent.action.MAIN&quot; /&gt; &lt;category android:name=&quot;android.intent.category.LAUNCHER&quot; /&gt; &lt;/intent-filter&gt; &lt;/activity&gt; 此时: Activity不会被销毁,从而重新创建,而是调用onConfigurationChanged @Override public void onConfigurationChanged(Configuration newConfig) { super.onConfigurationChanged(newConfig); //do somethings } Fragment生命周期惯例,如图: 回调方法简述其中onAttach() onCreateView() onActivityCreated() onDestroy() onDetach() 和Activity的不一致 onAttach() Fragment与它所依赖的Activity建立关联 onCreateView() 这里是给Fragment创建视图用的,在onCreate()中初始化Fragment,但是视图等还是没有加载上去的 onActivityCreated() 如果调用该方法,说明Fragment依赖的Activity中onCreate()已经执行完毕 onDestroyView() Fragment中的布局销毁,移除 要注意的是,此时Fragment与它所依赖的Activity还是关联的 onDestroy() 此时,Fragment被销毁 onDetach() 解除与Activity的关联 PS: Fragment中的onResume()并不十分准确,所以如果要做懒加载,要判断fragment不能使用onResume判断 经典场景1.正常启动 真的是超级多啊 E/BlankFragment: ---- onAttach ---- 关联Activity E/BlankFragment: ---- onCreate ---- Fragment初始化 E/BlankFragment: ---- onCreateView ---- 创建Fragment的布局 E/BlankFragment: ---- onViewCreated ---- onCreateView执行完后被触发 E/BlankFragment: ---- onActivityCreated ---- 关联的Activity OnCreate()执行完毕后触发 E/BlankFragment: ---- onStart ---- Fragment可见 E/BlankFragment: ---- onResume ---- Fragment可交互,一般不使用它来判断 2.正常退出(或者是它关联的Activity被销毁了) E/BlankFragment: ---- onPause ---- E/BlankFragment: ---- onStop ---- E/BlankFragment: ---- onDestroyView ---- E/BlankFragment: ---- onDestroy ---- E/BlankFragment: ---- onDetach ---- 3.进入后台 E/BlankFragment: ---- onPause ---- E/BlankFragment: ---- onStop ---- 4.从锁屏到解锁 E/BlankFragment: ---- onPause ---- E/BlankFragment: ---- onSaveInstanceState ---- E/BlankFragment: ---- onStop ---- E/BlankFragment: ---- onStart ---- E/BlankFragment: ---- onResume ---- 5.切换到OtherFragment E/BlankFragment: ---- onPause ---- E/BlankFragment: ---- onStop ---- E/BlankFragment: ---- onDestroyView ---- 6.从OtherFragment切换回本Fragment E/BlankFragment: ---- onCreateView ---- E/BlankFragment: ---- onActivityCreated ---- E/BlankFragment: ---- onStart ---- E/BlankFragment: ---- onResume ----","categories":[{"name":"Android","slug":"Android","permalink":"https://www.wangzhumo.com/categories/Android/"}],"tags":[{"name":"Android","slug":"Android","permalink":"https://www.wangzhumo.com/tags/Android/"},{"name":"Fragment","slug":"Fragment","permalink":"https://www.wangzhumo.com/tags/Fragment/"},{"name":"Activity","slug":"Activity","permalink":"https://www.wangzhumo.com/tags/Activity/"}]},{"title":"Android Studio 中使用tools:sample","slug":"Android-Studio-tools-sample","date":"2018-02-26T02:31:28.000Z","updated":"2019-12-22T12:04:17.840Z","comments":true,"path":"2018/02/26/Android-Studio-tools-sample/","link":"","permalink":"https://www.wangzhumo.com/2018/02/26/Android-Studio-tools-sample/","excerpt":"Google 官方文档 https://developer.android.com/studio/write/tool-attributes.html#toolssample_resources 他所能达到的效果就是,提供给你一些数据,并直接在 Preview 或者 Design面板中查看样式","text":"Google 官方文档 https://developer.android.com/studio/write/tool-attributes.html#toolssample_resources 他所能达到的效果就是,提供给你一些数据,并直接在 Preview 或者 Design面板中查看样式 效果不如放一个图来的直观 item中使用 sample资源 将item加入到list中查看效果 准备使用toolsAndroid Studio注意要使用Android Studio 3.0 + 的版本 命名空间xmlns:tools=&quot;http://schemas.android.com/tools&quot; 然后就可以使用tools的相关属性了 在google文档中我们可以看到有很多其他可用的,具体使用效果请自行查阅文档. 如: context showIn layout listitem layoutManager itemCount 使用方式为: &lt;layout xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot; xmlns:tools=&quot;http://schemas.android.com/tools&quot;&gt; &lt;RelativeLayout android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;match_parent&quot; tools:context=&quot;com.wangzhumo.app.tips.page.NearbyFragment&quot;&gt; &lt;com.jcodecraeer.xrecyclerview.XRecyclerView android:id=&quot;@+id/recycleview&quot; android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;match_parent&quot; tools:layoutManager=&quot;GridLayoutManager&quot; tools:itemCount=&quot;5&quot; tools:spanCount=&quot;2&quot; tools:listitem=&quot;@layout/nearby_list_item&quot;&gt; &lt;/com.jcodecraeer.xrecyclerview.XRecyclerView&gt; &lt;/RelativeLayout&gt; &lt;/layout&gt; 可用资源google已提供的资源 这些资源可以在xml中直接使用,也可以在自定义的资源中使用 使用方式为: &lt;!-- 这里面的资源在 Android Studio/Applications/Android Studio.app/Contents/plugins/android/lib/sampleData/backgrounds/scenic--&gt; &lt;ImageView ... tools:src=&quot;@tools:sample/backgrounds/scenic&quot;&gt; &lt;/ImageView&gt; &lt;!-- 这个是一段假文章 --&gt; &lt;TextView ... tools:text=&quot;@tools:sample/lorem/random&quot;/&gt; &lt;/TextView&gt; 自定义的资源 创建一个 sampledata 文件夹 sampledata/images 文件中都是些图片资源 description文件中是描述性文字, 注意每一行为一项个元素 hotels 也是一些文字,不过是一些酒店名字 hotel.json { &quot;data&quot;:[ { &quot;name&quot;:&quot;@sample/hotels&quot;, //这里使用的是自己定义的 hotels 文件中的字段 &quot;img&quot;:&quot;@tools:sample/backgrounds/scenic&quot;, &quot;desc&quot;:&quot;@sample/description&quot; //这里使用的是自己定义的 description 文件中的字段 }, { &quot;name&quot;:&quot;@sample/hotels&quot;, &quot;img&quot;:&quot;@tools:sample/backgrounds/scenic&quot;, //这里的就是自带的资源了 &quot;desc&quot;:&quot;@sample/description&quot; }, { &quot;name&quot;:&quot;@sample/hotels&quot;, &quot;img&quot;:&quot;@sample/images&quot;, //这种就是/images 文件中的资源 &quot;desc&quot;:&quot;@sample/description&quot; }, { &quot;name&quot;:&quot;@sample/hotels&quot;, &quot;img&quot;:&quot;@tools:sample/backgrounds/scenic&quot;, &quot;desc&quot;:&quot;@sample/description&quot; }, { &quot;name&quot;:&quot;@sample/hotels&quot;, &quot;img&quot;:&quot;@tools:sample/backgrounds/scenic&quot;, &quot;desc&quot;:&quot;@sample/description&quot; } ] } 使用方式为: &lt;TextView ... tools:text=&quot;@sample/hotels&quot;/&gt; &lt;ImageView ... tools:src=&quot;@sample/images&quot;/&gt;","categories":[{"name":"Android Studio","slug":"Android-Studio","permalink":"https://www.wangzhumo.com/categories/Android-Studio/"}],"tags":[{"name":"Android","slug":"Android","permalink":"https://www.wangzhumo.com/tags/Android/"},{"name":"Android Studio","slug":"Android-Studio","permalink":"https://www.wangzhumo.com/tags/Android-Studio/"}]},{"title":"Android项目中使用Timber + Logger日志输出","slug":"Android-Timber-Logger","date":"2018-02-07T09:48:58.000Z","updated":"2019-12-22T12:04:27.316Z","comments":true,"path":"2018/02/07/Android-Timber-Logger/","link":"","permalink":"https://www.wangzhumo.com/2018/02/07/Android-Timber-Logger/","excerpt":"不啰嗦了,直接开始. 添加依赖 Logger orhanobut/Logger Timber JakeWharton/timber //logger implementation &#39;com.orhanobut:logger:2.1.1&#39; //timber implementation &#39;com.jakewharton.timber:timber:4.6.0&#39;","text":"不啰嗦了,直接开始. 添加依赖 Logger orhanobut/Logger Timber JakeWharton/timber //logger implementation &#39;com.orhanobut:logger:2.1.1&#39; //timber implementation &#39;com.jakewharton.timber:timber:4.6.0&#39; 初始化我放在了我的Application.java中初始化的 /** * 初始化Timber */ private void initTimber() { //配置Logger FormatStrategy formatStrategy = PrettyFormatStrategy.newBuilder() .showThreadInfo(true) .methodCount(2) .methodOffset(7) .tag(&quot;MY_LOG&quot;) .build(); //配置Logger在Debug时不打印 Logger.addLogAdapter(new AndroidLogAdapter(formatStrategy){ @Override public boolean isLoggable(int priority, String tag) { return BuildConfig.DEBUG; } }); //给Timber一个树...大神这么打比喻的 😆 Timber.plant(new Timber.DebugTree(){ @Override protected void log(int priority, String tag, @NotNull String message, Throwable t) { Logger.log(priority,tag,message,t); } }); } 其中: showThreadInfo(true) 是否显示ThreadInfo methodCount(2) 日志输出时显示几行 methodOffset(7) 方法偏移量,默认是5,这个自己调大,调小看看就明白了 tag(&quot;MY_LOG&quot;) 自定义的Tag,默认值是PRETTY_LOGGER 使用Timber.e(&quot;下载状态发生改变 = %s&quot;, downLoadInfo.status ) Timber.e(&quot;下载进度 = %d&quot;, mBindingView.progressBar.progress ) logger负责生成message的方法 private String createMessage(String message, Object... args) { return args == null || args.length == 0 ? message : String.format(message, args); } String.format(message, args)这就赋予了我们在写信息的时候使用占位符.记得要符合format的格式哦 总结其实按我现在的需求,Logger完全符合我,为什么加上Timber那? Timber可以做到分发,到时候我可以加上 DiskFileTree … 什么的,方便后期有变化的时候修改 然而,我在Logger里发现了一个类 com.orhanobut.logger.DiskLogAdapter 原来它已经支持写到本地了.. 宝宝心里苦","categories":[{"name":"Android","slug":"Android","permalink":"https://www.wangzhumo.com/categories/Android/"}],"tags":[{"name":"Android","slug":"Android","permalink":"https://www.wangzhumo.com/tags/Android/"}]},{"title":"Jenkins搭建Android自动打包","slug":"Jenkins-Android","date":"2018-02-05T01:55:44.000Z","updated":"2019-12-22T12:09:37.553Z","comments":true,"path":"2018/02/05/Jenkins-Android/","link":"","permalink":"https://www.wangzhumo.com/2018/02/05/Jenkins-Android/","excerpt":"下载安装 Jenkins的下载与安装 下载 https://jenkins.io/download/ 下载war包 Generic Java package (.war) 因为打算使用Tomcat来部署,所以需要下载war包,也可以直接下对应版本的安装文件,直接安装 **安装** war包放到`./apache-tomcat-7.0.77/webapps` Tomcat的wabapps包下即可 Tomcat (略) 记得配置一下环境变量,等会方便启动 export TOMCAT_HOME=/Users/phyooos/develop/apache-tomcat-7.0.77 export PATH.....:$TOMCAT/bin","text":"下载安装 Jenkins的下载与安装 下载 https://jenkins.io/download/ 下载war包 Generic Java package (.war) 因为打算使用Tomcat来部署,所以需要下载war包,也可以直接下对应版本的安装文件,直接安装 **安装** war包放到`./apache-tomcat-7.0.77/webapps` Tomcat的wabapps包下即可 Tomcat (略) 记得配置一下环境变量,等会方便启动 export TOMCAT_HOME=/Users/phyooos/develop/apache-tomcat-7.0.77 export PATH.....:$TOMCAT/bin 初始化Jenkins 启动Jenkins,即启动tomcat $ startup.sh Using CATALINA_BASE: /Users/phyooos/develop/apache-tomcat-7.0.77 Using CATALINA_HOME: /Users/phyooos/develop/apache-tomcat-7.0.77 Using CATALINA_TMPDIR: /Users/phyooos/develop/apache-tomcat-7.0.77/temp Using JRE_HOME: /Library/Java/JavaVirtualMachines/jdk1.8.0/Contents/Home Using CLASSPATH: /Users/phyooos/develop/apache-tomcat-7.0.77/bin/bootstrap.jar:/Users/phyooos/develop/apache-tomcat-7.0.77/bin/tomcat-juli.jar Tomcat started. 看到这个就说明,已经正常启动 访问http://localhost:8080/jenkins/ 打开后需要输入一个密钥,mac的在jenkins/secrets/initialAdminPassword ~ ⌚ 10:11:03 $ cat ~/.jenkins/secrets/initialAdminPassword 55ad44431f6d4ebdb53a7c1971d12df4 输入此密钥即可. 创建用户 配置Jenkins1.安装插件 Build Timeout build-name-setter Credentials Binding Plugin description setter plugin Dynamic Parameter Plug-in(这个插件,搜不到了,因为安全问题被屏蔽了) Environment Injector Plugin Git plugin GitHub Branch Source Plugin Gitlab Authentication plugin GitLab Plugin Gradle Plugin Pipeline SSH Slaves plugin SSH plugin Timestamper Upload to pgyer(上传到蒲公英,没有需要的不用安装) Workspace Cleanup Plugin 以上插件,是常用的插件,尽量全部安装 2.配置环境变量系统管理 - 全局工具配置 需要配置 Java Git Gradle 配置好保存即可 系统管理 - 系统设置 记得配置gitlab或者 github账号 3.初始化项目创建项目 General 选择参数化构建过程 IS_JENKINS 是否Jenkins打包,这里肯定是一直true的 PRODUCT_FLAVORS 环境 BUILD_TYPE 构建版本 VERSION_NAME 版本名字 JENKINS_OUTPUT Apk生成目录 JENKINS_TIME 时间戳 这些参数定义完就可以使用了 ${参数名} 的形式,这些参数会写入到 App项目中的 gradle.properties文件 App项目中的 gradle.properties文件 # When configured, Gradle will run in incubating parallel mode. # This option should only be used with decoupled projects. More details, visit # http://www.gradle.org/docs/current/userguide/multi_project_builds.html#sec:decoupled_projects # org.gradle.parallel=true org.gradle.jvmargs=-Xmx4608M VERSION_NAME=1.4.0 VERSION_CODE=12 IS_JENKINS=false JENKINS_OUTPUT=&#39;output/&#39; JENKINS_TIME=&#39;201802021231&#39; 进入下一个配置页面,到源码管理那块 只要你能下载到源码即可,无所谓非要和我这个一致,branch 就是指定分支了,我这儿是 dev 分支 下一个配置构建 选择 Invoke Gradle Tasks 里面的命令,我来解释一下 #清理 clean #打包 assemble${PRODUCT_FLAVORS}${BUILD_TYPE} #这里的意思是 打包指定的一个FLAVOR版本(Release + 版本) #关于assemble ... 的,请搜 gradle 打包命令 #其他参数 -PVERSION_NAME=${VERSION_NAME} -PVERSION_CODE=${VERSION_CODE} -PJENKINS_OUTPUT=${JENKINS_OUTPUT} -PJENKINS_TIME=${JENKINS_TIME} -PIS_JENKINS=${IS_JENKINS} #-P意味着参数 #-P后面是参数名 #=${} 则为参数值,就是上面General里面配置的 构建后操作 参考 https://www.pgyer.com/doc/view/jenkins_plugin 保存即可 改造App ./gradle.properties文件 VERSION_NAME=1.4.0 VERSION_CODE=12 IS_JENKINS=false JENKINS_OUTPUT=&#39;output/&#39; JENKINS_TIME=&#39;201802021231&#39; 以上文件,写完请build一次,便于build.gradle中使用 使用jenkins时,jenkins会把定义的值注入到这里,覆盖这里定义的值 app/build.gradle android{ defaultConfig { ... //此处使用gradle.properties中的值 VERSION_CODE和VERSION_NAME versionCode VERSION_CODE as Integer versionName VERSION_NAME } //自定义apk名字 android.applicationVariants.all { variant -&gt; //获取时间戳 def timeNow = getDate() //如果是IS_JENKINS构建,则修改打包apk的目录 if (&#39;true&#39;.equals(IS_JENKINS)) { //使用JENKINS_OUTPUT的目录 def outputFile = JENKINS_OUTPUT //使用JENKINS_TIME的时间戳 timeNow = JENKINS_TIME //定义apk目录 variant.getPackageApplication().outputDirectory = new File(outputFile) } variant.getPackageApplication().outputScope.apkDatas.forEach { apkData -&gt; //这个修改输出APK的文件名 apkData.outputFileName = &quot;一号车市_${variant.versionName}_${timeNow}.apk&quot; } } flavorDimensions &#39;env&#39; productFlavors { envapp { dimension &#39;env&#39; //此处使用jenkins传的VERSION_NAME versionName VERSION_NAME manifestPlaceholders = [UMENG_CHANNEL_VALUE: &quot;app&quot;] buildConfigField &quot;String&quot;, &quot;SERVER_HOST&quot;, &#39;&quot;https://app.wangzhumo.com/&quot;&#39; } envtest { dimension &#39;env&#39; //为了方便测试看出当前app环境,就不用VERSION_NAME了 versionName &quot;Test&quot; manifestPlaceholders = [UMENG_CHANNEL_VALUE: &quot;app&quot;] buildConfigField &quot;String&quot;, &quot;SERVER_HOST&quot;, &#39;&quot;http://app-test.wangzhumo.com/&quot;&#39; } envpre { dimension &#39;env&#39; versionName &quot;Pre&quot; manifestPlaceholders = [UMENG_CHANNEL_VALUE: &quot;app&quot;] buildConfigField &quot;String&quot;, &quot;SERVER_HOST&quot;, &#39;&quot;https://app-pre.wangzhumo.com/&quot;&#39; } envdev { dimension &#39;env&#39; versionName &quot;Dev&quot; manifestPlaceholders = [UMENG_CHANNEL_VALUE: &quot;app&quot;] buildConfigField &quot;String&quot;, &quot;SERVER_HOST&quot;, &#39;&quot;http://192.168.1.16:8080/app2c/&quot;&#39; } //其实UMENG_CHANNEL_VALUE SERVER_HOST 也都可以使用jenkins定义参数,并使用 } //一个获取时间戳的方法 static def getDate() { def date = new Date() def formattedDate = date.format(&#39;yyyyMMddHHmm&#39;) return formattedDate } } 记得改完app,上传代码哦 Jenkins打包 OK了,可以愉快的打包了,打包完就会自动上传到蒲公英.","categories":[{"name":"Android","slug":"Android","permalink":"https://www.wangzhumo.com/categories/Android/"}],"tags":[{"name":"Android","slug":"Android","permalink":"https://www.wangzhumo.com/tags/Android/"},{"name":"Server","slug":"Server","permalink":"https://www.wangzhumo.com/tags/Server/"},{"name":"Jenkins","slug":"Jenkins","permalink":"https://www.wangzhumo.com/tags/Jenkins/"}]},{"title":"Java中String.format()的使用指北","slug":"Java-String-format","date":"2018-02-04T10:16:12.000Z","updated":"2019-12-22T12:30:26.644Z","comments":true,"path":"2018/02/04/Java-String-format/","link":"","permalink":"https://www.wangzhumo.com/2018/02/04/Java-String-format/","excerpt":"本文非原创,来自http://blog.csdn.net/lonely_fireworks/article/details/7962171/ 这里做一个备份,方便随时查询","text":"本文非原创,来自http://blog.csdn.net/lonely_fireworks/article/details/7962171/ 这里做一个备份,方便随时查询 常规类型的格式化String类的format()方法用于创建格式化的字符串以及连接多个字符串对象,format()方法有两种重载形式。 format(String format, Object… args) 新字符串使用本地语言环境，制定字符串格式和参数生成格式化的新字符串。 format(Locale locale, String format, Object… args) 使用指定的语言环境，制定字符串格式和参数生成格式化的字符串。 显示不同转换符实现不同数据类型到字符串的转换，如图所示。 转 换 符 说 明 示 例 %s 字符串类型 “mingrisoft” %c 字符类型 ‘m’ %b 布尔类型 true %d 整数类型（十进制） 99 %x 整数类型（十六进制） FF %o 整数类型（八进制） 77 %f 浮点类型 99.99 %a 十六进制浮点类型 FF.35AE %e 指数类型 9.38e+5 %g 通用浮点类型（f和e类型中较短的） %h 散列码 %% 百分比类型 ％ %n 换行符 %tx 日期与时间类型（x代表不同的日期与时间转换符 测试用例 public static void main(String[] args) { String str=null; str=String.format(&quot;Hi,%s&quot;, &quot;王力&quot;); System.out.println(str); str=String.format(&quot;Hi,%s:%s.%s&quot;, &quot;王南&quot;,&quot;王力&quot;,&quot;王张&quot;); System.out.println(str); System.out.printf(&quot;字母a的大写是：%c %n&quot;, &#39;A&#39;); System.out.printf(&quot;3&gt;7的结果是：%b %n&quot;, 3&gt;7); System.out.printf(&quot;100的一半是：%d %n&quot;, 100/2); System.out.printf(&quot;100的16进制数是：%x %n&quot;, 100); System.out.printf(&quot;100的8进制数是：%o %n&quot;, 100); System.out.printf(&quot;50元的书打8.5折扣是：%f 元%n&quot;, 50*0.85); System.out.printf(&quot;上面价格的16进制数是：%a %n&quot;, 50*0.85); System.out.printf(&quot;上面价格的指数表示：%e %n&quot;, 50*0.85); System.out.printf(&quot;上面价格的指数和浮点数结果的长度较短的是：%g %n&quot;, 50*0.85); System.out.printf(&quot;上面的折扣是%d%% %n&quot;, 85); System.out.printf(&quot;字母A的散列码是：%h %n&quot;, &#39;A&#39;); } 输出结果 Hi,王力 Hi,王南:王力.王张 字母a的大写是：A 3&gt;7的结果是：false 100的一半是：50 100的16进制数是：64 100的8进制数是：144 50元的书打8.5折扣是：42.500000 元 上面价格的16进制数是：0x1.54p5 上面价格的指数表示：4.250000e+01 上面价格的指数和浮点数结果的长度较短的是：42.5000 上面的折扣是85% 字母A的散列码是：41 搭配转换符的标志 标 志 说 明 示 例 结 果 + 为正数或者负数添加符号 (“%+d”,15) +15 − 左对齐 (“%-5d”,15) \\ 15 \\ 0 数字前面补0 (“%04d”, 99) 0099 空格 在整数之前添加指定数量的空格 (“% 4d”, 99) \\ 99\\ , 以“,”对数字分组 (“%,f”, 9999.99) 9,999.990000 ( 使用括号包含负数 (“%(f”, -99.99) (99.990000) # 如果是浮点数则包含小数点，如果是16进制或8进制则添加0x或0 (“%#x”, 99)(“%#o”, 99) 0x630143 &lt; 格式化前一个转换符所描述的参数 (“%f和%&lt;3.2f”, 99.45) 99.450000和99.45 $ 被格式化的参数索引 (“%1$d,%2$s”, 99,”abc”) 99,abc 测试用例 public static void main(String[] args) { String str=null; //$使用 str=String.format(&quot;格式参数的使用：%1d,%2$s&quot;, 99,&quot;abc&quot;); System.out.println(str); //+使用 System.out.printf(&quot;显示正负数的符号：%+d与%d%n&quot;, 99,-99); //补O使用 System.out.printf(&quot;最牛的编号是：%03d%n&quot;, 7); //空格使用 System.out.printf(&quot;Tab键的效果是：% 8d%n&quot;, 7); //.使用 System.out.printf(&quot;整数分组的效果是：%,d%n&quot;, 9989997); //空格和小数点后面个数 System.out.printf(&quot;一本书的价格是：% 50.5f元%n&quot;, 49.8); } 输出结果 格式参数$的使用：99,abc 显示正负数的符号：+99与-99 最牛的编号是：007 Tab键的效果是： 7 整数分组的效果是：9,989,997 一本书的价格是： 49.80000元 日期和事件字符串格式化字符串格式中还有%tx转换符没有详细介绍，它是专门用来格式化日期和时 间的。%tx转换符中的x代表另外的处理日期和时间格式的转换符，它们的组合能够将日期和时间格式化成多种格式。 常见日期和时间组合的格式 转 换 符 说 明 示 例 c 包括全部日期和时间信息 星期六 十月 27 14:21:20 CST 2007 F “年-月-日”格式 2007-10-27 D “月/日/年”格式 10/27/07 r “HH:MM:SS PM”格式（12时制） 02:25:51 下午 T “HH:MM:SS”格式（24时制） 14:28:16 R “HH:MM”格式（24时制） 14:28 测试用例 public static void main(String[] args) { Date date=new Date(); //c的使用 System.out.printf(&quot;全部日期和时间信息：%tc%n&quot;,date); //f的使用 System.out.printf(&quot;年-月-日格式：%tF%n&quot;,date); //d的使用 System.out.printf(&quot;月/日/年格式：%tD%n&quot;,date); //r的使用 System.out.printf(&quot;HH:MM:SS PM格式（12时制）：%tr%n&quot;,date); //t的使用 System.out.printf(&quot;HH:MM:SS格式（24时制）：%tT%n&quot;,date); //R的使用 System.out.printf(&quot;HH:MM格式（24时制）：%tR&quot;,date); } 输出结果 全部日期和时间信息：星期一 九月 10 10:43:36 CST 2012 年-月-日格式：2012-09-10 月/日/年格式：09/10/12 HH:MM:SS PM格式（12时制）：10:43:36 上午 HH:MM:SS格式（24时制）：10:43:36 HH:MM格式（24时制）：10:43 定义日期格式的转换符可以使日期通过指定的转换符生成新字符串。这些日期转换符如图所示。 public static void main(String[] args) { Date date=new Date(); //b的使用，月份简称 String str=String.format(Locale.US,&quot;英文月份简称：%tb&quot;,date); System.out.println(str); System.out.printf(&quot;本地月份简称：%tb%n&quot;,date); //B的使用，月份全称 str=String.format(Locale.US,&quot;英文月份全称：%tB&quot;,date); System.out.println(str); System.out.printf(&quot;本地月份全称：%tB%n&quot;,date); //a的使用，星期简称 str=String.format(Locale.US,&quot;英文星期的简称：%ta&quot;,date); System.out.println(str); //A的使用，星期全称 System.out.printf(&quot;本地星期的简称：%tA%n&quot;,date); //C的使用，年前两位 System.out.printf(&quot;年的前两位数字（不足两位前面补0）：%tC%n&quot;,date); //y的使用，年后两位 System.out.printf(&quot;年的后两位数字（不足两位前面补0）：%ty%n&quot;,date); //j的使用，一年的天数 System.out.printf(&quot;一年中的天数（即年的第几天）：%tj%n&quot;,date); //m的使用，月份 System.out.printf(&quot;两位数字的月份（不足两位前面补0）：%tm%n&quot;,date); //d的使用，日（二位，不够补零） System.out.printf(&quot;两位数字的日（不足两位前面补0）：%td%n&quot;,date); //e的使用，日（一位不补零） System.out.printf(&quot;月份的日（前面不补0）：%te&quot;,date); } 输出结果 英文月份简称：Sep 本地月份简称：九月 英文月份全称：September 本地月份全称：九月 英文星期的简称：Mon 本地星期的简称：星期一 年的前两位数字（不足两位前面补0）：20 年的后两位数字（不足两位前面补0）：12 一年中的天数（即年的第几天）：254 两位数字的月份（不足两位前面补0）：09 两位数字的日（不足两位前面补0）：10 月份的日（前面不补0）：10 和日期格式转换符相比，时间格式的转换符要更多、更精确。它可以将时间格式化成时、分、秒甚至时毫秒等单位。格式化时间字符串的转换符如图所示。 转 换 符 说 明 示 例 H 2位数字24时制的小时（不足2位前面补0） 15 I 2位数字12时制的小时（不足2位前面补0） 03 k 2位数字24时制的小时（前面不补0） 15 l 2位数字12时制的小时（前面不补0） 3 M 2位数字的分钟（不足2位前面补0） 03 S 2位数字的秒（不足2位前面补0） 09 L 3位数字的毫秒（不足3位前面补0） 015 N 9位数字的毫秒数（不足9位前面补0） 562000000 p 小写字母的上午或下午标记 中：下午英：pm z 相对于GMT的RFC822时区的偏移量 +0800 Z 时区缩写字符串 CST s 1970-1-1 00:00:00 到现在所经过的秒数 1193468128 Q 1970-1-1 00:00:00 到现在所经过的毫秒数 1193468128984 测试代码 public static void main(String[] args) { Date date = new Date(); //H的使用 System.out.printf(&quot;2位数字24时制的小时（不足2位前面补0）:%tH%n&quot;, date); //I的使用 System.out.printf(&quot;2位数字12时制的小时（不足2位前面补0）:%tI%n&quot;, date); //k的使用 System.out.printf(&quot;2位数字24时制的小时（前面不补0）:%tk%n&quot;, date); //l的使用 System.out.printf(&quot;2位数字12时制的小时（前面不补0）:%tl%n&quot;, date); //M的使用 System.out.printf(&quot;2位数字的分钟（不足2位前面补0）:%tM%n&quot;, date); //S的使用 System.out.printf(&quot;2位数字的秒（不足2位前面补0）:%tS%n&quot;, date); //L的使用 System.out.printf(&quot;3位数字的毫秒（不足3位前面补0）:%tL%n&quot;, date); //N的使用 System.out.printf(&quot;9位数字的毫秒数（不足9位前面补0）:%tN%n&quot;, date); //p的使用 String str = String.format(Locale.US, &quot;小写字母的上午或下午标记(英)：%tp&quot;, date); System.out.println(str); System.out.printf(&quot;小写字母的上午或下午标记（中）：%tp%n&quot;, date); //z的使用 System.out.printf(&quot;相对于GMT的RFC822时区的偏移量:%tz%n&quot;, date); //Z的使用 System.out.printf(&quot;时区缩写字符串:%tZ%n&quot;, date); //s的使用 System.out.printf(&quot;1970-1-1 00:00:00 到现在所经过的秒数：%ts%n&quot;, date); //Q的使用 System.out.printf(&quot;1970-1-1 00:00:00 到现在所经过的毫秒数：%tQ%n&quot;, date); } 输出结果 2位数字24时制的小时（不足2位前面补0）:11 2位数字12时制的小时（不足2位前面补0）:11 2位数字24时制的小时（前面不补0）:11 2位数字12时制的小时（前面不补0）:11 2位数字的分钟（不足2位前面补0）:03 2位数字的秒（不足2位前面补0）:52 3位数字的毫秒（不足3位前面补0）:773 9位数字的毫秒数（不足9位前面补0）:773000000 小写字母的上午或下午标记(英)：am 小写字母的上午或下午标记（中）：上午 相对于GMT的RFC822时区的偏移量:+0800 时区缩写字符串:CST 1970-1-1 00:00:00 到现在所经过的秒数：1347246232 1970-1-1 00:00:00 到现在所经过的毫秒数：1347246232773","categories":[{"name":"Java","slug":"Java","permalink":"https://www.wangzhumo.com/categories/Java/"}],"tags":[{"name":"Java","slug":"Java","permalink":"https://www.wangzhumo.com/tags/Java/"}]},{"title":"Room --AppDatabase_Impl does not exist的异常解决","slug":"Room-AppDatabase-Impl-does-not-exist","date":"2018-01-17T09:08:28.000Z","updated":"2019-12-22T12:07:03.590Z","comments":true,"path":"2018/01/17/Room-AppDatabase-Impl-does-not-exist/","link":"","permalink":"https://www.wangzhumo.com/2018/01/17/Room-AppDatabase-Impl-does-not-exist/","excerpt":"Bug如下: Caused by: java.lang.RuntimeException: cannot find implementation for com.wangzhumo.app.datasource.database.AppDB. AppDB_Impl does not exist","text":"Bug如下: Caused by: java.lang.RuntimeException: cannot find implementation for com.wangzhumo.app.datasource.database.AppDB. AppDB_Impl does not exist 寻找原因debug依次发现: getInstance()为空 public static AppDB getInstance(Context context) { if (sInstance == null) { synchronized (AppDB.class) { if (sInstance == null) { //此处返回为空 sInstance = buildDatabase(context); sInstance.updateDatabaseCreated(context); } } } return sInstance; } buildDatabase(context) 返回为空 /** * Build the database. * creates a new instance of the database. */ private static AppDB buildDatabase(final Context appContext) { AppDB appDB = Room.databaseBuilder(appContext, AppDB.class, DATABASE_NAME) .addCallback(new Callback() { @Override public void onCreate(@NonNull SupportSQLiteDatabase db) { super.onCreate(db); AppDB database = AppDB.getInstance(appContext); database.setDatabaseCreated(); } @Override public void onOpen(@NonNull SupportSQLiteDatabase db) { super.onOpen(db); Log.e(TAG, &quot;onOpen: &quot; + db.getPath()); } }).build(); return appDB; } databaseBuilder是创建数据库的方法,但是它构建失败了,那么剩下的就是源码了 Debug源码 databaseBuilder 方法 @SuppressWarnings(&quot;WeakerAccess&quot;) @NonNull public static &lt;T extends RoomDatabase&gt; RoomDatabase.Builder&lt;T&gt; databaseBuilder( @NonNull Context context, @NonNull Class&lt;T&gt; klass, @NonNull String name) { //noinspection ConstantConditions if (name == null || name.trim().length() == 0) { throw new IllegalArgumentException (&quot;Cannot build a database with null or empty name.&quot; + &quot; If you are trying to create an in memory database, use Room&quot; + &quot;.inMemoryDatabaseBuilder&quot;); } return new RoomDatabase.Builder&lt;&gt;(context, klass, name); } 我们可以明显的看出,此处抛出的异常不是AppDB_Impl does not exist 的提示,可以肯定并不是此处的问题 应该是正常返回的 return new RoomDatabase.Builder&lt;&gt;(context, klass, name); RoomDatabase.Builder 那么出问题的就可以肯定是 build()方法 @NonNull public T build() { //noinspection ConstantConditions if (mContext == null) { throw new IllegalArgumentException (&quot;Cannot provide null context for the database.&quot;); } //noinspection ConstantConditions if (mDatabaseClass == null) { throw new IllegalArgumentException (&quot;Must provide an abstract class that&quot; + &quot; extends RoomDatabase&quot;); } if (mFactory == null) { mFactory = new FrameworkSQLiteOpenHelperFactory(); } DatabaseConfiguration configuration = new DatabaseConfiguration(mContext, mName, mFactory, mMigrationContainer, mCallbacks, mAllowMainThreadQueries, mRequireMigration); T db = Room.getGeneratedImplementation(mDatabaseClass, DB_IMPL_SUFFIX); db.init(configuration); return db; } 此处,debug发现,是到 T db = Room.getGeneratedImplementation(mDatabaseClass, DB_IMPL_SUFFIX); 抛出异常的. 锁定问题getGeneratedImplementation @NonNull static &lt;T, C&gt; T getGeneratedImplementation(Class&lt;C&gt; klass, String suffix) { final String fullPackage = klass.getPackage().getName(); String name = klass.getCanonicalName(); final String postPackageName = fullPackage.isEmpty() ? name : (name.substring(fullPackage.length() + 1)); final String implName = postPackageName.replace(&#39;.&#39;, &#39;_&#39;) + suffix; //noinspection TryWithIdenticalCatches try { @SuppressWarnings(&quot;unchecked&quot;) final Class&lt;T&gt; aClass = (Class&lt;T&gt;) Class.forName( fullPackage.isEmpty() ? implName : fullPackage + &quot;.&quot; + implName); return aClass.newInstance(); } catch (ClassNotFoundException e) { //**很明显,就是这个地方了** throw new RuntimeException(&quot;cannot find implementation for &quot; + klass.getCanonicalName() + &quot;. &quot; + implName + &quot; does not exist&quot;); } catch (IllegalAccessException e) { throw new RuntimeException(&quot;Cannot access the constructor&quot; + klass.getCanonicalName()); } catch (InstantiationException e) { throw new RuntimeException(&quot;Failed to create an instance of &quot; + klass.getCanonicalName()); } } 其实就是,生成类失败了 其他参数都正常,偏偏生成失败,所以就怀疑到 Java -&gt; apt 的问题 Kotlin -&gt; kapt的问题 这两个就是用来生成代码的,这里的生成失败,有很大概率是这个问题 解决问题查看项目的依赖 lib_opensource -&gt; build.gradle //arch api deps.archLibs.archExtensions api deps.archLibs.archLifecycleCommon api deps.archLibs.archRoomRuntime kapt deps.archLibs.archRoomCompiler 查看发现,我已经添加了,那么什么鬼问题呢? 怀疑是library的问题,打开我使用Room的library ,查看 lib_datasource -&gt; build.gradle apply plugin: &#39;com.android.library&#39; ... dependencies { implementation fileTree(dir: &#39;libs&#39;, include: [&#39;*.jar&#39;]) api project(&#39;:lib_opensource&#39;) // kapt deps.archLibs.archRoomCompiler } 果然忘了加 apply plugin: &#39;com.android.library&#39; apply plugin: &#39;kotlin-android&#39; apply plugin: &#39;kotlin-kapt&#39; ... dependencies { implementation fileTree(dir: &#39;libs&#39;, include: [&#39;*.jar&#39;]) api project(&#39;:lib_opensource&#39;) // kapt deps.archLibs.archRoomCompiler } 就Ok了,我又可以愉快的玩耍了 记得: kapt","categories":[{"name":"Bug","slug":"Bug","permalink":"https://www.wangzhumo.com/categories/Bug/"}],"tags":[{"name":"Android","slug":"Android","permalink":"https://www.wangzhumo.com/tags/Android/"},{"name":"Bug","slug":"Bug","permalink":"https://www.wangzhumo.com/tags/Bug/"},{"name":"Room","slug":"Room","permalink":"https://www.wangzhumo.com/tags/Room/"}]},{"title":"使用Charles抓Https的数据请求","slug":"Charles-Https","date":"2018-01-11T08:09:46.000Z","updated":"2019-12-22T12:11:44.185Z","comments":true,"path":"2018/01/11/Charles-Https/","link":"","permalink":"https://www.wangzhumo.com/2018/01/11/Charles-Https/","excerpt":"之前的文章中给项目中加入了Https,此时使用charles抓包就是一堆乱码, 但是我们还需要常常使用Charles,调试接口,查找问题等,所以就要让Charles作为一个中间人,帮我们接收转发请求 以达到抓包的效果,其实此时已经完全是Charles与服务器之间的事了.","text":"之前的文章中给项目中加入了Https,此时使用charles抓包就是一堆乱码, 但是我们还需要常常使用Charles,调试接口,查找问题等,所以就要让Charles作为一个中间人,帮我们接收转发请求 以达到抓包的效果,其实此时已经完全是Charles与服务器之间的事了. 导出证书1.打开Charles 2.Help -&gt; SSL Proxying -&gt; Save Charles Root Certificate… 3.保存到~/Downloads/charles-ssl-proxying-certificate.pem 安装证书到设备1.把证书推送到设备 $ adb push charles-ssl-proxying-certificate.pem /sdcard/Download/ charles-ssl-proxying-certificate.pem: 1 file pushed. 0.1 MB/s (1921 bytes in 0.012s) 2.安装证书 设置 -&gt; 安全 -&gt; 设备管理与凭证 -&gt; 从存储安装 -&gt; charles-ssl-proxying-certificate.pem’ 设置Charles1.Proxy -&gt; SSL Proxying Settings 2.打开手机,开始请求","categories":[],"tags":[{"name":"Android","slug":"Android","permalink":"https://www.wangzhumo.com/tags/Android/"},{"name":"Https","slug":"Https","permalink":"https://www.wangzhumo.com/tags/Https/"}]},{"title":"Android开发中常用的Adb命令","slug":"Android-shell-Adb","date":"2018-01-11T04:07:40.000Z","updated":"2019-12-22T12:12:27.503Z","comments":true,"path":"2018/01/11/Android-shell-Adb/","link":"","permalink":"https://www.wangzhumo.com/2018/01/11/Android-shell-Adb/","excerpt":"在做这些之前,先配置好adb环境变量,以我的配置为例 $ vim ~/.bash_profile export ANDROID_HOME=/Users/phyooos/Library/Android/sdk ... export PATH={省略}:$ANDROID_HOME/tools:$ANDROID_HOME/platform-tools $ source ~/.bas $ adb Android Debug Bridge version 1.0.39 Version 0.0.1-4500957 Installed as /Users/phyooos/Library/Android/sdk/platform-tools/adb ... 补充 adb shell pm list packages 当前手机安装的所有app包名adb shell pm list packages | grep ‘google’ 在所有包名中查找带’google’的","text":"在做这些之前,先配置好adb环境变量,以我的配置为例 $ vim ~/.bash_profile export ANDROID_HOME=/Users/phyooos/Library/Android/sdk ... export PATH={省略}:$ANDROID_HOME/tools:$ANDROID_HOME/platform-tools $ source ~/.bas $ adb Android Debug Bridge version 1.0.39 Version 0.0.1-4500957 Installed as /Users/phyooos/Library/Android/sdk/platform-tools/adb ... 补充 adb shell pm list packages 当前手机安装的所有app包名adb shell pm list packages | grep ‘google’ 在所有包名中查找带’google’的 连接设备打开开发者 -&gt; 打开调试 -&gt; 允许调试 通过usb连接 通过wifi连接 保证Android设备与电脑在局域网中,网段好像也要一致 eg: 192.168.2.98 , 192.168.2.111 ~ ⌚ 9:44:55 $ adb connect 192.168.6.51 unable to connect to 192.168.6.51:5555: Connection refused 此时是连接不上的,要先tcpip 5555,如下: #使用Tcp并监听端口5555 adb tcpip 5555 #连接设备 adb connect 192.168.6.51 如果你想用usb调试 #使用usb调试 adb usb PS:有的设备直接adb connect 即可,所以不妨先试试 查看设备 查看所有连接的设备 $ adb devices List of devices attached 3080b82d device 860BCML228J8 device 指定\b设备(adb 命令必须指定一个设备使用) abd -s 编号 命令 比如我要连接3080b82d device 这个设备,安装一个apk eg: $ adb -s 3080b82d install Test.apk Success 安装,卸载apk 安装$ adb -s 3080b82d install Users/phyooos/develop/Test.apk Success install 跟上apk的path即可 install 可以搭配几个参数使用,比较常用的是 install -r 替换掉原来的apk.(被称为强制安装) 至于其他的参数去google官网看吧 install -t 可以安装测试包 卸载 adb uninstall [软件包名] adb uninstall -k [软件包名] -k 参数,卸载软件但是保留配置和缓存文件. 包名使用文章开始的命令查找即可(当前有两个手机,还要指定设备) $ adb -s 3080b82d shell pm list packages | grep &#39;miui&#39; package:com.miui.screenrecorder package:com.miui.contentextension package:com.miui.powerkeeper ... 拉取,推送文件 发送文件到Android设备 adb push [本地路径] [远程路径] 从Android设备中下载文件 adb pull [远程路径] [本地路径] 截图录屏 截图adb shell screencap [path] adb shell screencap /sdcard/screen.png #截图并保存到/sdcard/screen.png 录屏adb shell screenrecord [path] adb shell screenrecord /sdcard/demo.mp4 #录屏 注意: 按Ctrl-C 结束录制 adb shell screenrecord --size &lt;WIDTHxHEIGHT&gt; adb shell screenrecord --bit-rate &lt;RATE&gt; adb shell screenrecord --bit-rate 5000000 /sdcard/demo.mp4 adb shell screenrecord --time-limit &lt;TIME&gt; adb shell screenrecord --rotate adb shell screenrecord --verbose Package 查看系统内app信息 adb shell pm list packages 查看当前所有包 adb shell pm list packages $ adb shell pm list packages package:com.flyme.roamingpay package:com.android.cts.priv.ctsshim package:com.meizu.pps package:com.meizu.net.pedometer package:com.android.providers.telephony 系统应用 adb shell pm list packages -s $ adb shell pm list packages -s package:com.miui.screenrecorder package:com.android.cts.priv.ctsshim package:com.qualcomm.qti.auth.sampleextauthservice package:com.qualcomm.qti.perfdump ... 普通外来应用 adb shell pm list packages -3 $ adb shell pm list packages -3 package:com.google.android.youtube package:com.hpbr.bosszhipin package:de.blinkt.openvpn package:org.iggymedia.periodtracker package:com.daimajia.gold 其他参数 #See their associated file. adb shell pm list packages -f #Filter to only show disabled packages. adb shell pm list packages -d #Filter to only show enabled packages. adb shell pm list packages -e #See the installer for the packages. adb shell pm list packages -i #Also include uninstalled packages. adb shell pm list packages -u 通过包名查找app位置 adb shell pm path [packagename] $ adb shell pm path com.miui.screenrecorder package:/system/app/MiuiScreenRecorder/MiuiScreenRecorder.apk 清除缓存adb shell pm clear [packageName] 清除了该app的 data cache $ adb shell pm clear com.yhcs.carmart Success shell我们知道android其实精简了linux的命令,有一大部分linux命令没法用的 $ adb shell #即可进入 如果要root权限,国内手机好像不一致,我是用过的为 $ adb root $ adb shell 此时权限就是root 进入shell后,就可以为所欲为,一般和linux一致 不过这些,还是管用的 ls , cd , rm , mkdir , touch , pwd ,cp , mv ,netstat , ping, ip 举一个例子,我想查看当前wifi的ip是多少. $ adb shell sagit:/ $ ip -f inet addr show wlan0 23: wlan0: &lt;BROADCAST,MULTICAST,UP,LOWER_UP&gt; mtu 1500 qdisc mq state UP group default qlen 3000 inet 192.168.6.51/23 brd 192.168.7.255 scope global wlan0 valid_lft forever preferred_lft forever sagit:/ $ #ip inet 192.168.6.51 这个就是 Logcatadb logcat [option] [filter] 查看log adb logcat 通过 control + c 退出 查看Debug的log adb logcat *:D Logcat,还是Android studio 看起来方便,所以没有继续去看,也就不说了 dumpsys这是一个很强大的命令 电量 adb shell dumpsys battery 服务列表 adb shell dumpsys 下面的命令 | more 是为了显示所有的数据 $ adb shell dumpsys | more Currently running services: DockObserver MiuiBackup MiuiInit SurfaceFlinger accessibility account activity alarm ... 这个Currently running services 所有的项目,都可以详细查询 查询单个service adb shell dumpsys [service name] 搞几个例子看看: 屏幕分辨率adb shell dumpsys window displays $ adb shell dumpsys window displays WINDOW MANAGER DISPLAY CONTENTS (dumpsys window displays) Display: mDisplayId=0 init=1080x1920 480dpi cur=1080x1920 app=1080x1920 rng=1080x1020-1920x1860 deferred=false mLayoutNeeded=false 其中: init=1080x1920 分辨率 480dpi dpi值 activity信息adb shell dumpsys activity 比如我想看看我activity的信息adb shell dumpsys activity | grep &#39;com.yhcs.carmart&#39; $ adb shell dumpsys activity | grep &quot;com.yhcs.carmart&quot; * com.yhcs.carmart: 2 items #0: PendingIntentRecord{c526be3 com.yhcs.carmart startService} #1: PendingIntentRecord{8949e0 com.yhcs.carmart broadcastIntent} -&gt; 8161:com.yhcs.carmart/u0a460 s1/1 u0/0 +44s372ms -&gt; 8556:com.yhcs.carmart:channel/u0a460 s1/1 u0/0 +33s684ms ... * Recent #0: TaskRecord{6019b81 #14799 A=com.yhcs.carmart U=0 StackId=1 sz=1} packageName=com.yhcs.carmart processName=com.yhcs.carmart launchedFromUid=10460 launchedFromPackage=com.yhcs.carmart userId=0 app=ProcessRecord{3c52934 8161:com.yhcs.carmart/u0a460} Intent { cmp=com.yhcs.carmart/.ui.main.MainActivity } frontOfTask=true task=TaskRecord{6019b81 #14799 A=com.yhcs.carmart U=0 StackId=1 sz=1} taskAffinity=com.yhcs.carmart realActivity=com.yhcs.carmart/.ui.main.MainActivity 现在指定查看这个activity $ adb shell dumpsys activity com.yhcs.carmart/.ui.main.MainActivity TASK com.yhcs.carmart id=14799 userId=0 ACTIVITY com.yhcs.carmart/.ui.main.MainActivity a99200b pid=8161 Local Activity 90efa41 State: mResumed=false mStopped=true mFinished=false mChangingConfigurations=false mCurrentConfig={1.0 460mcc11mnc [zh_CN] ldltr sw360dp w360dp h620dp 480dpi nrml long port finger -keyb/v/h -nav/h appBounds=Rect(0, 0 - 1080, 1920) s.12 themeChanged=0 themeChangedFlags=0} ... View Hierarchy: DecorView@ce71c9e[MainActivity] android.widget.LinearLayout{6106377 V.E...... ......ID 0,0-1080,1920} ... Active Fragments ... 里面有很多信息","categories":[{"name":"Android","slug":"Android","permalink":"https://www.wangzhumo.com/categories/Android/"}],"tags":[{"name":"Android","slug":"Android","permalink":"https://www.wangzhumo.com/tags/Android/"}]},{"title":"OkHttp中添加https支持","slug":"OkHttp-support-https","date":"2018-01-10T08:43:57.000Z","updated":"2019-12-22T12:08:02.765Z","comments":true,"path":"2018/01/10/OkHttp-support-https/","link":"","permalink":"https://www.wangzhumo.com/2018/01/10/OkHttp-support-https/","excerpt":"基础知识 感觉就是一堆有信誉的机构,说: 我们这些机构的公钥是可信的,我们下面的小弟当然也是可以信任的啦 然后大家就去当人家小弟,就是可信的了…. 当然这里面有的大佬不高兴,就自己搞一套证书,比如12306","text":"基础知识 感觉就是一堆有信誉的机构,说: 我们这些机构的公钥是可信的,我们下面的小弟当然也是可以信任的啦 然后大家就去当人家小弟,就是可信的了…. 当然这里面有的大佬不高兴,就自己搞一套证书,比如12306 Https中,值得注意的密钥有: 服务器端的公钥和私钥 客户端的随机密钥 值得注意的是一个HTTPS请求实际上就是两次HTTP传输. 1.客户端向服务器发起HTTPS请求，连接到服务器的443端口。 2.服务端收到请求,向客户端发送自己的公钥 3.客户端收到服务器公钥,开始验证证书的合法性,我们知道系统内置了一些证书,应该是叫顶级证书吧 我们的证书并不是啥大机构发的,肯定不在里面,那么就没法验证合法. 合法 &gt; 继续 不合法 &gt; 此次Https请求终止 4.客户端验证公钥合格后(也就是给你发消息的服务器是正经服务器)，那么客户端会生成一个 随机密码,客户端会拿着这个随机密码和刚才收到的服务器密钥做非对称加密 &gt;&gt; 得到密文的密码 ——–以上第一次http请求结束了——– 5.客户端会发起HTTPS中的第二个HTTP请求,发送客户端密钥(密文)给服务器。 6.服务器收到密文，会用自己的私钥对其进行非对称解密,得到客户端刚才生成的客户端随机密码. 此时服务器使用客户端随机密码,对数据进行对称加密 7.把对称加密后的数据返回给客户端,客户端对称解密,OK 此次Https完美结束 ——–整个https请求结束了——– 其中 , 对称加密和非对称加密, 各司其职,共同完成整个请求. 对称加密: 最快速,最简单 非对称加密:速度慢,很安全,不需要把秘钥分发,客户端利用公钥加密的数据,只能是拥有秘钥的服务器解密 利用非对称加密的特性传递 客户端生成的随机密钥 ,达到只有服务器和客户端互相知道的密钥,从而使用密钥进行(高速简单的)对称加密数据. 第一部分:信任所有 这就是,我不管是谁传递的消息,不是你家服务器传递的消息,你也会信 Api.java (提供okhttp实例,并创建Retroit服务) OkHttpClient okHttpClient = new OkHttpClient.Builder() .hostnameVerifier(new HostnameVerifier() { @Override public boolean verify(String hostname, SSLSession session) { return true; } }) .sslSocketFactory(createSSLSocketFactory()) .build(); ... //这里是创建一个SSLSocketFactory,提供给上面的 .sslSocketFactory() private SSLSocketFactory createSSLSocketFactory() { SSLSocketFactory ssfFactory = null; try { SSLContext sc = SSLContext.getInstance(&quot;TLS&quot;); sc.init(null, new TrustManager[]{new TrustAllCerts()}, new SecureRandom()); ssfFactory = sc.getSocketFactory(); } catch (Exception e) { } return ssfFactory; } 其中涉及到TrustAllCerts.java,可以看到只是实现X509TrustManager,所有方法都是默认实现 /** * If you have any questions, you can contact by email { wangzhumoo@gmail.com} * @author 王诛魔 2018/1/8 下午2:25 */ public class TrustAllCerts implements X509TrustManager { @Override public void checkClientTrusted(X509Certificate[] chain, String authType) throws CertificateException {} @Override public void checkServerTrusted(X509Certificate[] chain, String authType) throws CertificateException {} @Override public X509Certificate[] getAcceptedIssuers() { return new X509Certificate[0]; } } 这里就以及可以了,信任所有的连接 第二部分:(强验证) 我只信任证书合法的服务器传递的数据. 查看Https的证书 在浏览器上看到这个,这个已经是我把证书添加为信任了,所以他是一个 安全 的标志 分析 这里是我查看当前网站证书的结构 最顶—是根证书,到期时间是2028年 最底—是我司证书,到期时间是2018.12.9日 这里我们可以发现,我们网站的证书是有时间限制的,那么就会有一个问题,到了2018.12.9这一天怎么办. 我也不知道会怎么样,应该是续签吧!那么万一这个证书变化了怎么办? 所以,我们应该把根证书置为信任. 下载保存 Mac的在 钥匙串访问 中 Windows 没法放图,在chrome上查看证书的时候应该就能保存. HttpsUtils.java /** * If you have any questions, you can contact by email { wangzhumoo@gmail.com} * @author 王诛魔 2018/1/10 下午5:07 * 支持https的工具类 */ public class HttpsUtils { private static final String TAG = &quot;OkHttp&quot;; /** * 创建一个空白的KeyStore * @return KeyStore * @throws GeneralSecurityException */ private static KeyStore createEmptyKeyStore() throws GeneralSecurityException { try { KeyStore keystore = KeyStore.getInstance(KeyStore.getDefaultType()); //此处密码随意,不会产生问题 keystore.load(null, &quot;password&quot;.toCharArray()); return keystore; } catch (IOException e) { return null; } } /** * TrustManager 生成 * @return * @throws GeneralSecurityException */ private static TrustManager[] generateTrustManager() throws GeneralSecurityException { //创建一个X.509格式的CertificateFactory CertificateFactory certificateFactory = CertificateFactory.getInstance(&quot;X.509&quot;); Certificate ca; //证书工厂根据证书文件的流生成证书Certificate InputStream assets = App.getContext().getResources().openRawResource(R.raw.rootca); ca = certificateFactory.generateCertificate(assets); Log.e(TAG, &quot;trustManager: ca = &quot; + ((X509Certificate) ca).getSubjectDN() ); //创建KeyStore，用来存储信任证书 KeyStore keyStor = createEmptyKeyStore(); keyStor.setCertificateEntry(&quot;ca&quot;,ca); //创建一个默认类型的TrustManagerFactory String defaultAlgorithm = TrustManagerFactory.getDefaultAlgorithm(); TrustManagerFactory tmf = TrustManagerFactory.getInstance(defaultAlgorithm); //用keyStore实例初始化TrustManagerFactory,此时TrustManagerFactory会信任我们保存的证书 tmf.init(keyStor); //通过tmf获取TrustManager数组，TrustManager也会信任keyStor中的证书 return tmf.getTrustManagers(); } /** * 提供一个一个SSLSocketFactory * @return SSLSocketFactory实例 */ public static SSLSocketFactory generateSSLSocketFactory() { try { SSLContext sc = SSLContext.getInstance(&quot;TLS&quot;); sc.init(null, generateTrustManager(), new SecureRandom()); Log.e(TAG, &quot;generateSSLSocketFactory &quot;); return sc.getSocketFactory(); } catch (GeneralSecurityException e) { return null; } } } 注释很清楚了. 关键: 1.拿到帧数的流 InputStream assets = App.getContext().getResources().openRawResource(R.raw.rootca); 2.保存到keystore KeyStore keyStor = createEmptyKeyStore(); keyStor.setCertificateEntry(&quot;ca&quot;,ca); 3.初始化并拿到TrustManager[] tmf.init(keyStor); tmf.getTrustManagers() 使用即可: //这样就Ok OkHttpClient okHttpClient = new OkHttpClient.Builder() .hostnameVerifier((hostname, session) -&gt; true) .sslSocketFactory(HttpsUtils.generateSSLSocketFactory()) .build(); 超好的两篇 http://blog.csdn.net/lmj623565791/article/details/48129405 http://blog.csdn.net/iispring/article/details/51615631","categories":[],"tags":[{"name":"Android","slug":"Android","permalink":"https://www.wangzhumo.com/tags/Android/"}]},{"title":"WebView播放H5视屏没有画面,只有声音","slug":"webview-video-without-image","date":"2018-01-04T03:03:45.000Z","updated":"2019-12-22T12:05:35.253Z","comments":true,"path":"2018/01/04/webview-video-without-image/","link":"","permalink":"https://www.wangzhumo.com/2018/01/04/webview-video-without-image/","excerpt":"","text":"描述:点击播放按钮后,只能听到声音,而画面是白的….一直白…想到应该是硬件加速的问题 1.确认硬件加速(非此因素) 在WebViewActivity.java中发现 webView.setLayerType(View.LAYER_TYPE_HARDWARE, null); 2.确认AndroidManifest.xml(非此因素) application节点下并没有发现 android:hardwareAccelerated=&quot;true&quot; 在WebViewActivity中,也无该配置 尝试: WebViewActivity.java中,注释 #webView.setLayerType(View.LAYER_TYPE_HARDWARE, null); 在AndroidManifest.xml节点下加入android:hardwareAccelerated=&quot;true&quot; 结果……没用 3.检查activity_web_view.xml &lt;WebView android:id=&quot;@+id/webView&quot; android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;match_parent&quot; android:scrollbars=&quot;none&quot; android:visibility=&quot;@{showError?View.GONE:View.VISIBLE}&quot; /&gt; 没问题. BUT…. &lt;LinearLayout android:layerType=&quot;software&quot; android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;match_parent&quot; android:orientation=&quot;vertical&quot;&gt; &lt;include layout=&quot;@layout/layout_toolbar&quot; /&gt; &lt;ProgressBar android:id=&quot;@+id/web_load_progress&quot; style=&quot;?android:attr/progressBarStyleHorizontal&quot; android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;2dp&quot; android:indeterminateOnly=&quot;false&quot; android:max=&quot;100&quot; android:progress=&quot;@{progress}&quot; android:progressDrawable=&quot;@drawable/progress_bar_states&quot; android:visibility=&quot;gone&quot; /&gt; &lt;WebView android:id=&quot;@+id/webView&quot; android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;match_parent&quot; android:scrollbars=&quot;none&quot; android:visibility=&quot;@{showError?View.GONE:View.VISIBLE}&quot; /&gt; &lt;/LinearLayout&gt; ####父布局竟然android:layerType=&quot;software&quot; 解决,删掉该属性即可","categories":[{"name":"Bug","slug":"Bug","permalink":"https://www.wangzhumo.com/categories/Bug/"}],"tags":[{"name":"Android","slug":"Android","permalink":"https://www.wangzhumo.com/tags/Android/"},{"name":"Bug","slug":"Bug","permalink":"https://www.wangzhumo.com/tags/Bug/"}]},{"title":"Room中List<>使用详解","slug":"room-list","date":"2018-01-03T07:03:38.000Z","updated":"2019-12-22T12:06:54.087Z","comments":true,"path":"2018/01/03/room-list/","link":"","permalink":"https://www.wangzhumo.com/2018/01/03/room-list/","excerpt":"手摸手教你在Room中使用List. 实际项目有很多这样的结构: { &quot;id&quot;: &quot;001&quot;, &quot;name&quot;: &quot;王诛魔&quot;, &quot;age&quot;: 2018, &quot;books&quot;: [ { &quot;bookId&quot;: 10081, &quot;userId&quot;: 1, &quot;book&quot;: &quot;断罪小学&quot;, &quot;desc&quot;: &quot;漫画讲述了李杀神、王诛魔和刘斩仙三位少年，为了十万小学生的未来、为了改变被诅咒的命运，相聚在狼牙区飞虎路私立断罪小学，誓死打败四年级的魔神赵日天的故事。&quot; }, { &quot;bookId&quot;: 10088, &quot;userId&quot;: 1, &quot;book&quot;: &quot;狂霸天下之断罪学园&quot;, &quot;desc&quot;: &quot;《狂霸天下之断罪学园》，后来因为名字太长，而且“学园”和“学院”容易混淆的原因而改名。&quot; } ] }","text":"手摸手教你在Room中使用List. 实际项目有很多这样的结构: { &quot;id&quot;: &quot;001&quot;, &quot;name&quot;: &quot;王诛魔&quot;, &quot;age&quot;: 2018, &quot;books&quot;: [ { &quot;bookId&quot;: 10081, &quot;userId&quot;: 1, &quot;book&quot;: &quot;断罪小学&quot;, &quot;desc&quot;: &quot;漫画讲述了李杀神、王诛魔和刘斩仙三位少年，为了十万小学生的未来、为了改变被诅咒的命运，相聚在狼牙区飞虎路私立断罪小学，誓死打败四年级的魔神赵日天的故事。&quot; }, { &quot;bookId&quot;: 10088, &quot;userId&quot;: 1, &quot;book&quot;: &quot;狂霸天下之断罪学园&quot;, &quot;desc&quot;: &quot;《狂霸天下之断罪学园》，后来因为名字太长，而且“学园”和“学院”容易混淆的原因而改名。&quot; } ] } 也就是,类似books这样的,List作为一个元素存在. 下面就以上面的结构为例,做一个简单的演示,按照最简答的方法实现. 1.添加依赖 https://developer.android.google.cn/topic/libraries/architecture/adding-components.html 值得注意的是,如果你在kotlin中使用 apply plugin: &#39;kotlin-kapt&#39; ... dependencies{ ... //这个无法生成代码,要用下面的那一条,不要疏忽忘掉了. //annotationProcessor &quot;android.arch.persistence.room:compiler:1.0.0&quot; kapt &quot;android.arch.persistence.room:compiler:1.0.0&quot; } 一定记得使用kapt,要不然就会遇到这个BUG. 2.创建表 User.java表 /** * If you have any questions, you can contact by email { wangzhumoo@gmail.com} * @author 王诛魔 2018/1/3 下午1:31 */ @Entity(tableName = &quot;users&quot;) public class User { @PrimaryKey public int id; public String name; public int age; } @Entity 中指定了表名 @PrimaryKey 主键 这张表users 用于保存用户数据 Book.java表 /** * If you have any questions, you can contact by email { wangzhumoo@gmail.com} * @author 王诛魔 2018/1/3 下午1:30 */ @Entity(foreignKeys = { @ForeignKey( entity = User.class, parentColumns ={&quot;id&quot;}, childColumns = {&quot;userId&quot;}) },tableName = &quot;books&quot;) public class Book { @PrimaryKey public int bookId; public int userId;//同User.java中的id public String book; public String desc; } @Entity 中 foreignKeys = {} 中外键,可以是多个,这里只关联了User表 tableName = “books” 指定了表名 @PrimaryKey 该表主键 UserAndBook.java表 —-UserAndBook只是辅助,不作为一张表存在. /** * If you have any questions, you can contact by email { wangzhumoo@gmail.com} * @author 王诛魔 2018/1/3 下午1:43 */ public class UserAndBook { @Embedded //请看之前的文章,这是指把User中所有元素带入到这里作为元素存在 public User userEntity; //@Relation @Relation(parentColumn = &quot;id&quot;,entityColumn = &quot;userId&quot;,entity = Book.class) public List&lt;Book&gt; books; } @Embedded 请看另一篇,有解释 @Relation 点这里去看官方文档 A convenience annotation which can be used in a Pojo to automatically fetch relation entities. When the Pojo is returned from a query, all of its relations are also fetched by Room. 个人以为就是一注解,指明关系,可以把实体关联起来,然后自动组装起来. 并且在文档中还展示了一种高端的功能,用上面做例 //@Relation @Relation(parentColumn = &quot;id&quot;,entityColumn = &quot;userId&quot;, entity = Book.class ,projection = {&quot;book&quot;}) public List&lt;String&gt; bookNames; 解释一下,projection指定了要取出的值,当前指明要在 books表中寻找符合条件parentColumn = “id”,entityColumn = “userId” 的项,找到之后会拿到book这个值并返回. 3.Dao实现 /** * If you have any questions, you can contact by email { wangzhumoo@gmail.com} * @author 王诛魔 2018/1/3 下午4:20 */ @Dao public abstract class UserAndBookDao { @Insert(onConflict = OnConflictStrategy.REPLACE) public abstract void insert(User user); @Insert(onConflict = OnConflictStrategy.REPLACE) public abstract void insert(List&lt;Book&gt; books); @Transaction public void insert(UserAndBook userAndBook){ insert(userAndBook.userEntity); insert(userAndBook.books); } @Query(&quot;SELECT * FROM users&quot;) public abstract List&lt;UserAndBook&gt; getAll(); } insert(User user); ,insert(List&lt;Book&gt; books); 两个方法,也可以私有化,只对外提供insert(UserAndBook userAndBook) 最近换公司项目的数据库,用sql,真的有意思,可以很方便的实现很多功能 4.建立数据库 /** * If you have any questions, you can contact by email { wangzhumoo@gmail.com} * @author 王诛魔 2017/10/24 上午10:13 * 数据库 */ @Database(entities = {Book.class, User.class}, version = 1, exportSchema = false) public abstract class AppDB extends RoomDatabase { private static final String TAG = &quot;AppDB&quot;; /** * 数据库实例 */ private static AppDB sInstance; private static String DATABASE_NAME = &quot;developer.db&quot;; private ObservableBoolean mIsDatabaseCreated = new ObservableBoolean(false); public abstract UserAndBookDao userbook(); /** * 单例 * @param context * @return */ public static AppDB getInstance(Context context) { if (sInstance == null) { synchronized (AppDB.class) { if (sInstance == null) { sInstance = buildDatabase(context); sInstance.updateDatabaseCreated(context); } } } return sInstance; } /** * Build the database. * creates a new instance of the database. */ private static AppDB buildDatabase(Context appContext) { AppDB appDB = Room.databaseBuilder(appContext, AppDB.class, DATABASE_NAME) .addCallback(new Callback() { @Override public void onCreate(@NonNull SupportSQLiteDatabase db) { super.onCreate(db); AppDB database = AppDB.getInstance(appContext); database.setDatabaseCreated(); } @Override public void onOpen(@NonNull SupportSQLiteDatabase db) { super.onOpen(db); Log.e(TAG, &quot;onOpen: &quot; + db.getPath()); } }).build(); return appDB; } /** * Check whether the database already exists and expose it via */ private void updateDatabaseCreated(final Context context) { if (context.getDatabasePath(DATABASE_NAME).exists()) { setDatabaseCreated(); } } private void setDatabaseCreated() { mIsDatabaseCreated.set(true); } public ObservableBoolean getDatabaseCreated() { return mIsDatabaseCreated; } } 为了方便使用,在Application中添加了 public static AppDB getDatabase() { return AppDB.getInstance(context); } 5.使用 这里的使用方式,不建议使用,太粗暴了. 可以学学Demo,Google出的googlesamples/android-architecture-components class RoomActivity : BindingActivity&lt;ActivityRoomBinding, RoomViewModel&gt;() { val gson = Gson() override fun getBundle(extras: Bundle) { } override fun layoutID(): Int = R.layout.activity_room override fun initViews(savedInstanceState: Bundle?) { //点击事件 ADD按钮,添加数据到数据库 mBindingView.button.setOnClickListener({ val userBook = UserAndBook() val jsonStr = FileUtils.getJson(this, &quot;data.txt&quot;) val objectJson = JsonParser().parse(jsonStr).asJsonObject //获取用户 val user = objectJson.get(&quot;user&quot;) userBook.userEntity = gson.fromJson&lt;User&gt;(user, User::class.java) //保存用户 Observable .empty&lt;Any&gt;() .observeOn(Schedulers.io()) .subscribe(object : EmptyObserver&lt;Any?&gt;() { override fun onComplete() { App.getDatabase().userbook().insert(userBook.userEntity) } }) //获取书籍 val books = objectJson.get(&quot;books&quot;) userBook.books = gson.fromJson&lt;ArrayList&lt;Book&gt;&gt; (books, object : TypeToken&lt;List&lt;Book&gt;&gt;() {}.type) //保存书籍 Observable .empty&lt;Any&gt;() .observeOn(Schedulers.io()) .subscribe(object : EmptyObserver&lt;Any?&gt;() { override fun onComplete() { App.getDatabase().userbook().insert(userBook.books) } }) }) //点击事件,按钮QUERY 查询数据 mBindingView.button2.setOnClickListener { Flowable.create(FlowableOnSubscribe&lt;List&lt;UserAndBook&gt;&gt; { e -&gt; val userBook = App.getDatabase().userbook().all e.onNext(userBook) e.onComplete() }, BackpressureStrategy.DROP) .compose(DatabaseTransformer()) .subscribe(object : DatabaseSubscriber&lt;List&lt;UserAndBook&gt;&gt;() { override fun onNext(userAndBooks: List&lt;UserAndBook&gt;) { mBindingView.data = userAndBooks[0] } }) } } } &lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt; &lt;layout xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;&gt; &lt;data&gt; &lt;import type=&quot;com.wangzhumo.app.data.UserAndBook&quot;/&gt; &lt;import type=&quot;com.wangzhumo.app.data.User&quot;/&gt; &lt;import type=&quot;com.wangzhumo.app.data.Book&quot;/&gt; &lt;variable name=&quot;data&quot; type=&quot;com.wangzhumo.app.data.UserAndBook&quot;/&gt; &lt;/data&gt; &lt;RelativeLayout android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;match_parent&quot;&gt; &lt;Button android:id=&quot;@+id/button&quot; android:layout_width=&quot;wrap_content&quot; android:layout_height=&quot;wrap_content&quot; android:layout_alignParentLeft=&quot;true&quot; android:layout_alignParentStart=&quot;true&quot; android:layout_alignParentTop=&quot;true&quot; android:layout_marginLeft=&quot;57dp&quot; android:layout_marginStart=&quot;57dp&quot; android:layout_marginTop=&quot;125dp&quot; android:text=&quot;Add&quot; /&gt; &lt;Button android:id=&quot;@+id/button2&quot; android:layout_width=&quot;wrap_content&quot; android:layout_height=&quot;wrap_content&quot; android:layout_alignBaseline=&quot;@+id/button&quot; android:layout_alignBottom=&quot;@+id/button&quot; android:layout_alignParentEnd=&quot;true&quot; android:layout_alignParentRight=&quot;true&quot; android:layout_marginEnd=&quot;56dp&quot; android:layout_marginRight=&quot;56dp&quot; android:text=&quot;Query&quot; /&gt; &lt;RelativeLayout android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;match_parent&quot; android:layout_alignParentLeft=&quot;true&quot; android:layout_alignParentStart=&quot;true&quot; android:layout_below=&quot;@+id/button&quot; android:layout_marginTop=&quot;68dp&quot;&gt; &lt;TextView android:id=&quot;@+id/textView&quot; android:layout_width=&quot;wrap_content&quot; android:layout_height=&quot;wrap_content&quot; android:layout_alignParentLeft=&quot;true&quot; android:layout_alignParentStart=&quot;true&quot; android:layout_alignParentTop=&quot;true&quot; android:layout_marginLeft=&quot;36dp&quot; android:layout_marginStart=&quot;36dp&quot; android:layout_marginTop=&quot;32dp&quot; android:text=&quot;@{data.userEntity.name}&quot; /&gt; &lt;TextView android:id=&quot;@+id/textView2&quot; android:layout_width=&quot;wrap_content&quot; android:layout_height=&quot;wrap_content&quot; android:layout_alignLeft=&quot;@+id/textView&quot; android:layout_alignStart=&quot;@+id/textView&quot; android:layout_below=&quot;@+id/textView&quot; android:layout_marginTop=&quot;41dp&quot; android:text=&quot;@{data.books.get(0).book}&quot; /&gt; &lt;TextView android:id=&quot;@+id/textView3&quot; android:layout_width=&quot;wrap_content&quot; android:layout_height=&quot;wrap_content&quot; android:layout_alignLeft=&quot;@+id/textView2&quot; android:layout_alignStart=&quot;@+id/textView2&quot; android:layout_centerVertical=&quot;true&quot; android:text=&quot;@{data.books.get(0).desc}&quot; /&gt; &lt;/RelativeLayout&gt; &lt;/RelativeLayout&gt; &lt;/layout&gt; ​ ​","categories":[{"name":"Android","slug":"Android","permalink":"https://www.wangzhumo.com/categories/Android/"}],"tags":[{"name":"Android","slug":"Android","permalink":"https://www.wangzhumo.com/tags/Android/"},{"name":"Room","slug":"Room","permalink":"https://www.wangzhumo.com/tags/Room/"}]},{"title":"Android字体不跟随系统变化","slug":"Android-Font-Size","date":"2017-12-28T07:30:11.000Z","updated":"2019-12-22T12:03:29.720Z","comments":true,"path":"2017/12/28/Android-Font-Size/","link":"","permalink":"https://www.wangzhumo.com/2017/12/28/Android-Font-Size/","excerpt":"","text":"已知的方法有两种: 第一种 不使用sp 而使用 dp 第二种 在Application中加入 @Override public void onConfigurationChanged(Configuration newConfig) { if (newConfig.fontScale != 1) getResources(); super.onConfigurationChanged(newConfig); } @Override public Resources getResources() { Resources res = super.getResources(); if (res.getConfiguration().fontScale != 1) { Configuration newConfig = new Configuration(); newConfig.setToDefaults(); res.updateConfiguration(newConfig, res.getDisplayMetrics()); } return res; }","categories":[{"name":"Android","slug":"Android","permalink":"https://www.wangzhumo.com/categories/Android/"}],"tags":[{"name":"Android","slug":"Android","permalink":"https://www.wangzhumo.com/tags/Android/"}]},{"title":"Apk Install 的各种问题","slug":"Apk-Install-Error","date":"2017-12-28T06:48:09.000Z","updated":"2019-12-22T12:04:38.048Z","comments":true,"path":"2017/12/28/Apk-Install-Error/","link":"","permalink":"https://www.wangzhumo.com/2017/12/28/Apk-Install-Error/","excerpt":"","text":"[INSTALL_FAILED_TEST_ONLY: installPackageLI] 方法1：AndroidManifest.xml 加入android:testOnly=”false”。 方法2：adb install -t *.apk","categories":[{"name":"Bug","slug":"Bug","permalink":"https://www.wangzhumo.com/categories/Bug/"}],"tags":[{"name":"Android","slug":"Android","permalink":"https://www.wangzhumo.com/tags/Android/"},{"name":"Bug","slug":"Bug","permalink":"https://www.wangzhumo.com/tags/Bug/"}]},{"title":"Android Studio报错 cannot debug application","slug":"cannot-debug-application","date":"2017-12-26T07:26:29.000Z","updated":"2019-12-22T12:23:38.234Z","comments":true,"path":"2017/12/26/cannot-debug-application/","link":"","permalink":"https://www.wangzhumo.com/2017/12/26/cannot-debug-application/","excerpt":"Android Studio报错Error Running app: cannot debug application","text":"Android Studio报错Error Running app: cannot debug application 这里有一位仁兄帮忙翻译了. http://blog.csdn.net/yishichangan1/article/details/77451486 Cannot debug application xx.xxx.xxx.app on device lge_nexus_5x(此处表示你的手机型号). 你的xxxapp不能在型号为Nexus 5x的LGE手机上调试。 This application does not have the debuggable attribute enabled in its manifest. 这个项目在清单文件（AndroidManifest.xml）中没有设置可以调试的参数。 If you have manually set it in the manifest, then remove it and let the IDE automatically assign it. 如果你已经手动在清单文件种设置了这个属性，请remove掉，让IDE自动生成。 If you are using Gradle, make sure that your current variant is debuggable. 如果你使用Gradle，确认你现在的变体是可调试的。 ####我就知道是我自己选了release….果然","categories":[{"name":"Bug","slug":"Bug","permalink":"https://www.wangzhumo.com/categories/Bug/"}],"tags":[{"name":"Android","slug":"Android","permalink":"https://www.wangzhumo.com/tags/Android/"},{"name":"Bug","slug":"Bug","permalink":"https://www.wangzhumo.com/tags/Bug/"}]},{"title":"Centos 创建用户并实现免密码登录","slug":"Centos-Login-SSH","date":"2017-12-25T08:25:04.000Z","updated":"2019-12-22T12:11:50.315Z","comments":true,"path":"2017/12/25/Centos-Login-SSH/","link":"","permalink":"https://www.wangzhumo.com/2017/12/25/Centos-Login-SSH/","excerpt":"比如,创建一个名为wzm的账号 ####创建账号 1.创建 [root@localhost ~]# adduser wzm [root@localhost ~]# passwd wzm #此时,输入两次密码即可","text":"比如,创建一个名为wzm的账号 ####创建账号 1.创建 [root@localhost ~]# adduser wzm [root@localhost ~]# passwd wzm #此时,输入两次密码即可 2.赋予sudo #找到sudoers [root@localhost ~]# whereis sudoers #修改sudoers的读写权限 [root@localhost ~]# chmod -v u+w /etc/sudoers #加入新用户 ## Allow root to run any commands anywher root ALL=(ALL) ALL linuxidc ALL=(ALL) ALL #这个是新增的用户 #把sudoers权限还给他 [root@localhost ~]# chmod -v u-w /etc/sudoers 3.尽情享用吧 ####ssh免密码登录 1.修改配置文件sudo vim /etc/ssh/sshd_config 2.重启ssh服务service sshd restart 3.生成密钥 ssh-keygen -t rsa 默认在 ~/.ssh目录生成两个文件： id_rsa ：私钥 id_rsa.pub ：公钥 4.导入本机cat ~/.ssh/id_rsa.pub &gt;&gt; ~/.ssh/authorized_keys 5.下载到客户端并设置 scp [-r] 用户名@ip:文件路径 本地路径 #下载文件 scp [-r] 本地文件 用户名@ip:上传路径 eg: ~/.ssh ⌚ 16:27:33 $ scp id_rsa.pub root@45.XX.XX.XX:/home/ id_rsa.pub 6.改权限如果希望ssh公钥生效需满足至少下面两个条件： 1) .ssh目录的权限必须是7002) .ssh/authorized_keys文件权限必须是600 eg: ~ ⌚ 16:33:21 $ ssh wzm@45.XX.XX.XX Last login: Mon Dec 25 16:21:11 2017 from 118.102.XXX.XXX [wzm@wangzhumo ~]$","categories":[{"name":"Server","slug":"Server","permalink":"https://www.wangzhumo.com/categories/Server/"}],"tags":[{"name":"Server","slug":"Server","permalink":"https://www.wangzhumo.com/tags/Server/"},{"name":"Linux","slug":"Linux","permalink":"https://www.wangzhumo.com/tags/Linux/"}]},{"title":"Android项目中使用RxBus进行通讯","slug":"Android-RxBus","date":"2017-12-25T06:50:16.000Z","updated":"2019-12-22T12:03:46.403Z","comments":true,"path":"2017/12/25/Android-RxBus/","link":"","permalink":"https://www.wangzhumo.com/2017/12/25/Android-RxBus/","excerpt":"加入JakeWharton大神的RxRelay JakeWharton/RxRelay compile &#39;com.jakewharton.rxrelay2:rxrelay:2.0.0&#39;","text":"加入JakeWharton大神的RxRelay JakeWharton/RxRelay compile &#39;com.jakewharton.rxrelay2:rxrelay:2.0.0&#39; RxBus.java /** * If you have any questions, you can contact by email {wangzhumoo@gmail.com} * @author 王诛魔 2017/11/30 下午6:09 * */ public class RxBus { private Relay&lt;Object&gt; mBus = null; private static volatile RxBus mDefaultInstance; public RxBus() { mBus = PublishRelay.create().toSerialized(); } public static RxBus getDefault() { if (mDefaultInstance == null) { synchronized (RxBus.class) { if (mDefaultInstance == null) { mDefaultInstance = new RxBus(); } } } return mDefaultInstance; } /** * 发送事件 */ public void post(Object event) { mBus.accept(event); } /** * 根据传递的 eventType 类型返回特定类型(eventType)的 被观察者 */ public &lt;T&gt; Observable&lt;T&gt; toObservable(Class&lt;T&gt; eventType) { return mBus.ofType(eventType); } /** * 判断是否有订阅者 */ public boolean hasObservers() { return mBus.hasObservers(); } /** * 取消订阅 * @param disposable */ public void unregister(Disposable disposable) { if (disposable != null &amp;&amp; !disposable.isDisposed()) { disposable.dispose(); } } public &lt;T&gt; Disposable register(Class&lt;T&gt; eventType, Scheduler scheduler, Consumer&lt;T&gt; onNext) { return toObservable(eventType).observeOn(scheduler).subscribe(onNext); } public &lt;T&gt; Disposable register(Class&lt;T&gt; eventType, Scheduler scheduler, Consumer&lt;T&gt; onNext, Consumer onError, Action onComplete, Consumer onSubscribe) { return toObservable(eventType).observeOn(scheduler).subscribe(onNext, onError, onComplete, onSubscribe); } public &lt;T&gt; Disposable register(Class&lt;T&gt; eventType, Scheduler scheduler, Consumer&lt;T&gt; onNext, Consumer onError, Action onComplete) { return toObservable(eventType).observeOn(scheduler).subscribe(onNext, onError, onComplete); } public &lt;T&gt; Disposable register(Class&lt;T&gt; eventType, Scheduler scheduler, Consumer&lt;T&gt; onNext, Consumer onError) { return toObservable(eventType).observeOn(scheduler).subscribe(onNext, onError); } public &lt;T&gt; Disposable register(Class&lt;T&gt; eventType, Consumer&lt;T&gt; onNext) { return toObservable(eventType).observeOn(AndroidSchedulers.mainThread()).subscribe(onNext); } public &lt;T&gt; Disposable register(Class&lt;T&gt; eventType, Consumer&lt;T&gt; onNext, Consumer onError, Action onComplete, Consumer onSubscribe) { return toObservable(eventType).observeOn(AndroidSchedulers.mainThread()).subscribe(onNext, onError, onComplete, onSubscribe); } public &lt;T&gt; Disposable register(Class&lt;T&gt; eventType, Consumer&lt;T&gt; onNext, Consumer onError, Action onComplete) { return toObservable(eventType).observeOn(AndroidSchedulers.mainThread()).subscribe(onNext, onError, onComplete); } public &lt;T&gt; Disposable register(Class&lt;T&gt; eventType, Consumer&lt;T&gt; onNext, Consumer onError) { return toObservable(eventType).observeOn(AndroidSchedulers.mainThread()).subscribe(onNext, onError); } } 还有一个通用的Event.java依据自己的需要制定即可 /** * If you have any questions, you can contact by email {wangzhumoo@gmail.com} * @author 王诛魔 2017/10/19 下午5:38 * * 发送事件包装类 */ public class Event&lt;T&gt; { public static final int EVENT_CLOSE_ALL_ACTIVITY = 10001; /** * reserved data */ private T data; /** * this code distinguish between different events */ private int eventCode = -1; public Event(int eventCode) { this(eventCode, null); } public Event(int eventCode, T data) { this.eventCode = eventCode; this.data = data; } /** * get event code * * @return */ public int getCode() { return this.eventCode; } /** * get event reserved data * * @return */ public T getData() { return this.data; } } RxBus的使用 注册 最好是再基类中,加上. if (useEventBus()) { //注册eventbus Disposable disposable = RxBus.getDefault() .register(Event.class, new Consumer&lt;Event&gt;() { @Override public void accept(Event event) { int eventCode = event.getCode(); Log.e(&quot;RxBus&quot;, event.toString()); switch (eventCode) { case Event.EVENT_CLOSE_ALL_ACTIVITY: break; default: onEvent(event); break; } } }); addDispose(disposable); } 其中: useEventBus()由子类实现,是否开启RxBus,避免浪费 addDispose(disposable);addDispose 是基类的方法 /** * RxJava 添加订阅 */ protected void addDispose(Disposable disposable) { if (mDisposables == null) { mDisposables = new CompositeDisposable(); } //将所有disposable放入,集中处理 mDisposables.add(disposable); } 统一管理,销毁时一起销毁,避免爆内存 onEvent(event);是一个空方法,如果子类重写就把事件交给子类处理 发送 RxBus.getDefault().post(new Event(100,&quot;message&quot;)) //code最好在Event.java中统一定义,方便管理 处理 override fun onEvent(event: Event&lt;*&gt;?) { super.onEvent(event) } 这一部分,其实在 注册 中已经完成,只要子类自己重写方法,就能取到数据","categories":[{"name":"Android","slug":"Android","permalink":"https://www.wangzhumo.com/categories/Android/"}],"tags":[{"name":"Rxjava","slug":"Rxjava","permalink":"https://www.wangzhumo.com/tags/Rxjava/"}]},{"title":"Nginx安装及其简单配置","slug":"Nginx-install-config","date":"2017-12-25T05:39:40.000Z","updated":"2019-12-22T12:08:11.438Z","comments":true,"path":"2017/12/25/Nginx-install-config/","link":"","permalink":"https://www.wangzhumo.com/2017/12/25/Nginx-install-config/","excerpt":"环境: centos7 1.下载安装 下载nginx-1.12.0,官网sudo wget http://nginx.org/download/nginx-1.12.0.tar.gz 解压sudo tar -zxvf nginx-1.12.0.tar.gz 其他的库,nginx依赖的库 安装gccyum -y install gcc 安装pcreyum -y install pcre pcre-devel 安装zlibyum -y install zlib zlib-devel 安装opensslyum -y install openssl openssl-devel 安装 sudo ./configure sudo make sudo make install 默认位置 /usr/local/nginx 如果安装过程中出现文件目录权限问题,百度即可解决.","text":"环境: centos7 1.下载安装 下载nginx-1.12.0,官网sudo wget http://nginx.org/download/nginx-1.12.0.tar.gz 解压sudo tar -zxvf nginx-1.12.0.tar.gz 其他的库,nginx依赖的库 安装gccyum -y install gcc 安装pcreyum -y install pcre pcre-devel 安装zlibyum -y install zlib zlib-devel 安装opensslyum -y install openssl openssl-devel 安装 sudo ./configure sudo make sudo make install 默认位置 /usr/local/nginx 如果安装过程中出现文件目录权限问题,百度即可解决. 2.系统中配置 1.在系统服务目录里创建nginx.service文件 vim /lib/systemd/system/nginx.service [Unit] Description=nginx After=network.target [Service] Type=forking ExecStart=/usr/local/nginx/sbin/nginx ExecReload=/usr/local/nginx/sbin/nginx -s reload ExecStop=/usr/local/nginx/sbin/nginx -s quit PrivateTmp=true [Install] WantedBy=multi-user.target 2.设置开机启动 systemctl enable nginx.service 3.其他命令 启动nginx服务systemctl start nginx.service 设置开机自启动systemctl enable nginx.service 停止开机自启动systemctl disable nginx.service 查看服务当前状态systemctl status nginx.service 重新启动服务systemctl restart nginx.service 查看所有已启动的服务 systemctl list-units --type=service 3.nginx.conf的配置 [root@wangzhumo hooks]# cd /usr/local/nginx/ [root@wangzhumo nginx]# ll total 96 drwx------ 2 root root 4096 Dec 24 20:57 client_body_temp drwxr-xr-x 3 root root 4096 Dec 24 23:24 conf drwx------ 2 root root 4096 Dec 24 20:57 fastcgi_temp drwxr-xr-x 2 root root 4096 Dec 23 10:38 html drwxr-xr-x 2 root root 4096 Dec 24 22:43 logs -rw-r--r-- 1 root root 53861 Dec 25 13:37 on drwx------ 2 root root 4096 Dec 24 20:57 proxy_temp drwxr-xr-x 2 root root 4096 Dec 23 10:38 sbin drwx------ 2 root root 4096 Dec 24 20:57 scgi_temp drwx------ 2 root root 4096 Dec 24 20:57 uwsgi_temp 其中/conf存放配置文件/conf/nginx.confvim /conf/nginx.conf 什么都不要动,在nginx.conf第一条server配置下面写入:include vhost/*.conf; } #此处是第一条可用的server的结束 #加入这句,其实是把其他地方配置的配置文件加载到里面来 #主要是为了方便管理,修改 include vhost/*.conf; # another virtual host using mix of IP-, name-, and port-based configuration # #server { # listen 8000; # listen somename:8080; # server_name somename alias another.alias; # location / { # root html; # index index.html index.htm; # } #} 3.1 /vhost/*.conf的配置 当前目录到cd /usr/local/nginx/conf 创建目录vhostmkdir /usr/local/nginx/conf/vhost 创建.conf文件(我只用到hexo的配置,所以只有一个配置文件)vim /usr/local/nginx/conf/vhost/hexo.conf server { listen 80; #listen [::]:80; server_name www.phyooos.top phyooos.top; index index.html index.htm index.php default.html default.htm default.php; #web root path root /home/wzm/hexo; #error_page 404 /404.html; location ~ .*\\.(ico|gif|jpg|jpeg|png|bmp|swf)$ { access_log on; expires 1d; } location ~ .*\\.(js|css|txt|xml)?$ { access_log on; expires 12h; } location / { try_files $uri $uri/ =404; } access_log /usr/local/nginx/logs/hexo.log combined; } 4.重启systemctl reload nginx 在外面访问即可","categories":[{"name":"Server","slug":"Server","permalink":"https://www.wangzhumo.com/categories/Server/"}],"tags":[{"name":"Server","slug":"Server","permalink":"https://www.wangzhumo.com/tags/Server/"},{"name":"Linux","slug":"Linux","permalink":"https://www.wangzhumo.com/tags/Linux/"}]},{"title":"Room数据库使用指北List<>的问题","slug":"room-list-object","date":"2017-12-25T05:08:10.000Z","updated":"2019-12-22T12:06:58.015Z","comments":true,"path":"2017/12/25/room-list-object/","link":"","permalink":"https://www.wangzhumo.com/2017/12/25/room-list-object/","excerpt":"Room依赖 implementation &quot;android.arch.persistence.room:runtime:1.0.0&quot; annotationProcessor &quot;android.arch.persistence.room:compiler:1.0.0&quot;","text":"Room依赖 implementation &quot;android.arch.persistence.room:runtime:1.0.0&quot; annotationProcessor &quot;android.arch.persistence.room:compiler:1.0.0&quot; 查找** 查找表中所有数据 /** * 查找user * @return */ @Query(&quot;SELECT * FROM banners&quot;) List&lt;BannerModel&gt; findBanners(); 按条件查找 /** * filters * @return * @param typeSort */ @Query(&quot;SELECT * FROM filters WHERE type != :typeSort&quot;) List&lt;FilterItemModel&gt; findFilters(String typeSort); 限制条数的条件查找 /** * 获取排序 * @return */ @Query(&quot;SELECT * FROM filters WHERE type = :name LIMIT 0,1&quot;) FilterItemModel findSort(String name); 现在获取的是第一条数据 //文档中的例子 @Dao public interface MyDao { @Query(&quot;SELECT first_name, last_name FROM user WHERE region IN (:regions)&quot;) public List&lt;NameTuple&gt; loadUsersFromRegions(List&lt;String&gt; regions); } 在user表中查找满足集合List regions中条件的元素 获取总行数 /** * 获取数据库表中总条数 * @return */ @Query(&quot;SELECT count(*) FROM search_history&quot;) long findHistoryCount(); 获取某一列的和 /** * 求和 * @return */ @Query(&quot;SELECT sum(count) FROM status_stock&quot;) long findStatusStockCount(); 按照降序排列(ASC升序 DESC降序) /** * 查找user * @return */ @Query(&quot;SELECT * FROM search_history ORDER BY time DESC&quot;) List&lt;SearchHistoryModel&gt; findSearchHistory(); 文档中的例子: @Dao public interface MyDao { //正常的查询 @Query(&quot;SELECT * FROM user WHERE age != :minAge&quot;) public User[] loadAllUsersOlderThan(int minAge); } @Dao public interface MyDao { //区间中的值 @Query(&quot;SELECT * FROM user WHERE age BETWEEN :minAge AND :maxAge&quot;) public User[] loadAllUsersBetweenAges(int minAge, int maxAge); //或关系的查询 @Query(&quot;SELECT * FROM user WHERE first_name LIKE :search &quot; + &quot;OR last_name LIKE :search&quot;) public List&lt;User&gt; findUserWithName(String search); } 如果,你不想查到表 行中所有字段,则1.定义一个实体 public class NameTuple { @ColumnInfo(name=&quot;first_name&quot;) public String firstName; @ColumnInfo(name=&quot;last_name&quot;) public String lastName; } 2.查询 @Dao public interface MyDao { @Query(&quot;SELECT first_name, last_name FROM user&quot;) public List&lt;NameTuple&gt; loadFullName(); } 多表查询Querying multiple tables @Dao public interface MyDao { @Query(&quot;SELECT user.name AS userName, pet.name AS petName &quot; + &quot;FROM user, pet &quot; + &quot;WHERE user.id = pet.user_id&quot;) public LiveData&lt;List&lt;UserPet&gt;&gt; loadUserAndPetNames(); // You can also define this class in a separate file, as long as you add the // &quot;public&quot; access modifier. //注意 public static class UserPet { public String userName; public String petName; } } 更新 更新指定条目 /** * 更新时间 * @param time */ @Query(&quot;UPDATE search_history SET time = :time WHERE content = :content&quot;) void updateSearchHistory(String content,long time); 删除数据 删除所有数据 /** * 删除表 * @return */ @Query(&quot;DELETE FROM filters&quot;) void delectFilters(); 删除最后一条 /** * 删除最后一个 * @return */ @Query(&quot;DELETE FROM search_history WHERE time in(SELECT time FROM search_history ORDER BY time ASC LIMIT 1 )&quot;) void delectLastHistory(); 按条件删除 /** * 删除表by listtype * @return */ @Query(&quot;DELETE FROM vehicle_model WHERE listType = :type&quot;) void delectVehicleByType(String type); ####补充 1.List&lt;String&gt;这样的元素 private ArrayList&lt;String&gt; tags; 这样的元素,可以通过Converter搞定 /** * If you have any questions, you can contact by email { wangzhumoo@gmail.com} * * @author 王诛魔 2017/12/27 上午11:51 */ public class TagsConverter { @TypeConverter public static ArrayList&lt;String&gt; fromString(String value) { Type listType = new TypeToken&lt;ArrayList&lt;String&gt;&gt;() {}.getType(); return new Gson().fromJson(value, listType); } @TypeConverter public static String fromArrayList(ArrayList&lt;String&gt; list) { Gson gson = new Gson(); String json = gson.toJson(list); return json; } } 在db中,会存为 [&quot;精选&quot;] [&quot;精选&quot;,&quot;急售&quot;] [&quot;准新&quot;,&quot;SUV&quot;] 3.@Embedded 作用是,把已经写好的普通的类添加到数据表中.用Room的文档做说明: //这是一个标准的数据表 @Entity class User { @PrimaryKey public int id; public String firstName; } 其中只有id , firstName 而我想添加 street; state; city; postCode;刚好之前写了一个类叫Address class Address { public String street; public String state; public String city; @Ignore public String nothing; @ColumnInfo(name = &quot;post_code&quot;) public int postCode; } 那么我通过 @Embedded @Entity class User { @PrimaryKey public int id; public String firstName; @Embedded public Address address; } 表中就会有:names: id, firstName, street, state, city, and post_code 如果你想给@Embedded的类中所有元素前面加上统一的标志 @Embedded(prefix = &quot;address_&quot;) 表中就会有: names: id, firstName, address_street, address_state, address_city, and address_post_code 3.List&lt;Object&gt;这样的数据 解决方法google developer 真的给谷歌跪了,什么鬼文档 @Entity public class User { // 这里是用户的 Id @PrimaryKey public int id; //省略 ... } @Entity public class Book { //书的id @PrimaryKey public int bookId; //这里就是这本书与 \bUser\b的关系,这里的是User.id public int userId; public String name; public String desc; } //注意,什么注解也不要加 public class UserAndBooks { //加入所有的user的属性 @Embedded public User user; //这里定义User 和 Book的关系 @Relation(parentColumn = &quot;id&quot;, entityColumn = &quot;userId&quot;, entity = Book.class) public List&lt;Book&gt; books; } //文档上还讲了一个比较牛逼的功能,这里不讨论 public class UserAndAllPets { @Embedded public User user; @Relation(parentColumn = &quot;id&quot;, entityColumn = &quot;userId&quot;, entity = Book.class, projection = {&quot;name&quot;}) public List&lt;String&gt; bookNames; } //然后,dao是这样的 @Dao public interface UserDao { @Query(&quot;SELECT * FROM User&quot;) public List&lt;UserAndBooks&gt; loadUserWithBooks(); } PS:当然你存的时候,分辨别存User 和 Book 即可","categories":[{"name":"Android","slug":"Android","permalink":"https://www.wangzhumo.com/categories/Android/"}],"tags":[{"name":"Android","slug":"Android","permalink":"https://www.wangzhumo.com/tags/Android/"},{"name":"Room","slug":"Room","permalink":"https://www.wangzhumo.com/tags/Room/"}]},{"title":"Retrofit2 + Okhttp3 + Rxjava2 网络请求封装(下)","slug":"Retrofit2-Okhttp3-Rxjava2-2","date":"2017-12-25T04:51:47.000Z","updated":"2019-12-22T12:07:18.654Z","comments":true,"path":"2017/12/25/Retrofit2-Okhttp3-Rxjava2-2/","link":"","permalink":"https://www.wangzhumo.com/2017/12/25/Retrofit2-Okhttp3-Rxjava2-2/","excerpt":"","text":"//请求: RetrofitApis.getNetworkApis().getFriendsCircle(userBean.token, String.valueOf(45),null,lastId) .compose(new DefaultTransformer&lt;&gt;()) .subscribe(new Defaultubscriber&lt;List&lt;FriendItem&gt;&gt;() { @Override protected void onError(ApiException ex) { //请求错误,ex中可以拿到code 和 msg 便于展示给用户 } @Override public void onNext(List&lt;FriendItem&gt; friends) { //请求成功,friends就是数据 } @Override public void onComplete() { //没有错误的话,\b最后会走着 } }); compose() 转化subscribe() 订阅 DefaultTransformer.java /** * If you have any questions, you can contact by email {wangzhumoo@gmail.com} * @author 王诛魔 2017/11/3 下午5:06 * * 默认的切换线程,并返回实体类 */ public class DefaultTransformer&lt;T extends ResultResponse&lt;RP&gt;, RP&gt; implements FlowableTransformer&lt;T, RP&gt; { @Override public Publisher&lt;RP&gt; apply(Flowable&lt;T&gt; upstream) { return upstream .map(t -&gt; t.getResult()) .subscribeOn(Schedulers.io()) .observeOn(AndroidSchedulers.mainThread()); } } 1.map 将返回的ResultResponse&lt;&gt; 转化,直接取ResultResponse的泛型实体 {&quot;result&quot;:{} &quot;code&quot;:&quot;&quot;, &quot;msg&quot;:&quot;&quot;} 中的result 2.subscribeOn(Schedulers.io()) 网络请求的耗时操作,放在方便io操作的线程里面3.observeOn(AndroidSchedulers.mainThread()) 后面的操作,都在主线程进行 Defaultubscriber.java /** * If you have any questions, you can contact by email {wangzhumoo@gmail.com} * @author 王诛魔 2017/10/24 上午10:36 * * 用于没有网络时停止网络请求 */ public abstract class Defaultubscriber&lt;T&gt; extends DisposableSubscriber&lt;T&gt; { @CallSuper @Override public void onError(Throwable e) { if (e instanceof ApiException) { onError((ApiException) e); } else { onError(new ApiException(&quot;&quot;,&quot;&quot;)); } } @Override protected void onStart() { if (!SystemUtils.isNetworkConnected()) { onError(new ApiException(Utils.getString(R.string.net_error_title),&quot;999&quot;)); cancel(); return; } super.onStart(); } /** * 错误回调 * * @param ex 异常信息 */ protected abstract void onError(ApiException ex); } 1.extends DisposableSubscriber 便于通过CompositeDisposable管理请求,此处没有展示,不用管2.onStart() 中,判断是否有网络 没有网络 onError(new ApiException(Utils.getString(R.string.net_error), false));抛出没有网络的错误,由各个页面自行处理 cancel(); 取消 \b有网络则继续 3.重写的 onError()中. 是ApiException实例的,是自己抛出的异常,已经处理过了,直接onError给各个页面处理 不是的再处理一次,在分发给各个页面处理 ####未完待续…","categories":[{"name":"Android","slug":"Android","permalink":"https://www.wangzhumo.com/categories/Android/"}],"tags":[{"name":"Android","slug":"Android","permalink":"https://www.wangzhumo.com/tags/Android/"},{"name":"Okhttp","slug":"Okhttp","permalink":"https://www.wangzhumo.com/tags/Okhttp/"},{"name":"Rxjava","slug":"Rxjava","permalink":"https://www.wangzhumo.com/tags/Rxjava/"}]},{"title":"Retrofit2 + Okhttp3 + Rxjava2 网络请求封装(上)","slug":"Retrofit2-Okhttp3-Rxjava2-1","date":"2017-12-25T04:14:04.000Z","updated":"2019-12-22T12:07:17.028Z","comments":true,"path":"2017/12/25/Retrofit2-Okhttp3-Rxjava2-1/","link":"","permalink":"https://www.wangzhumo.com/2017/12/25/Retrofit2-Okhttp3-Rxjava2-1/","excerpt":"\b最终结构 net ├── RequestBuilder.java ├── RetrofitApis.java ├── base │ ├── ApiException.java │ ├── CustomGsonConverter.java │ ├── DefaultSubscriber.java │ └── DefaultTransformer.java └── response ├── BaseResponse.java └── ResultResponse.java NetworkApis.java","text":"\b最终结构 net ├── RequestBuilder.java ├── RetrofitApis.java ├── base │ ├── ApiException.java │ ├── CustomGsonConverter.java │ ├── DefaultSubscriber.java │ └── DefaultTransformer.java └── response ├── BaseResponse.java └── ResultResponse.java NetworkApis.java 1.添加依赖 implementation &quot;io.reactivex.rxjava2:rxjava:2.1.7&quot; implementation &quot;io.reactivex.rxjava2:rxandroid:2.0.1&quot; implementation &quot;com.squareup.okhttp3:okhttp:3.9.0&quot; implementation &quot;com.squareup.okhttp3:logging-interceptor:3.9.0&quot; implementation &quot;com.squareup.retrofit2:retrofit:2.3.0&quot; implementation &quot;com.squareup.retrofit2:converter-gson:2.3.0&quot; implementation &quot;com.squareup.retrofit2:adapter-rxjava2:2.3.0&quot; 2.请求服务构建 /** * If you have any questions, you can contact by email {wangzhumoo@gmail.com} * @author 王诛魔 2017/11/1 下午11:13 * */ public class RetrofitApis { private static OkHttpClient okHttpClient = null; private static NetworkApis networkApis = null; private static Gson gson = new Gson(); private static final String TAG = &quot;RetrofitApis&quot;; /** * 为HOST创建一个请求客户端 * @return */ public static NetworkApis getNetworkApis() { initOkhttp(); if (networkApis == null) { Retrofit retrofit = new Retrofit.Builder() .client(okHttpClient) .baseUrl(Constants.HOST) .addConverterFactory(CustomGsonConverter.create(gson)) .addCallAdapterFactory(RxJava2CallAdapterFactory.create()) .build(); networkApis = retrofit.create(NetworkApis.class); } return networkApis; } /** * 初始化一个OkHttpClient */ private static void initOkhttp(){ //没有创建就实例一个 if(okHttpClient == null){ final OkHttpClient.Builder builder = new OkHttpClient.Builder(); //设置log等级 if(BuildConfig.DEBUG){ HttpLoggingInterceptor interceptor = new HttpLoggingInterceptor(); //BODY 包含请求url 参数 response ,会打印在logcat interceptor.setLevel(HttpLoggingInterceptor.Level.BODY); builder.addInterceptor(interceptor); } //打开一个File用于缓存 File cacheFile = new File(Constants.PATH_CACHE); Cache cache = new Cache(cacheFile,1024*1024*50); //一个拦截器 Interceptor cacheInterceptor = new Interceptor() { @Override public Response intercept(Chain chain) throws IOException { Request.Builder builder = chain.request().newBuilder(); if(SystemUtils.isNetworkConnected()){ int maxAge = 0 ; //有网络,不缓存,最长保存时间为0 builder.removeHeader(&quot;Pragma&quot;) .header(&quot;Cache-Control&quot;, &quot;public, max-age=&quot; + maxAge) .build(); } else { // 无网络时，设置超时为2周 int maxStale = 60 * 60 * 24 * 14; builder.removeHeader(&quot;Pragma&quot;) .header(&quot;Cache-Control&quot;, &quot;public, only-if-cached, max-stale=&quot; + maxStale) .build(); throw new ApiException(false); } return chain.proceed(builder.build()); } }; //设置缓存拦截器 builder.addInterceptor(cacheInterceptor); builder.addNetworkInterceptor(cacheInterceptor); //这里通过Interceptor 可以实现添加公共参数,不详细说明了 //stetho,如果使用则需要添加 //builder.addNetworkInterceptor(new StethoInterceptor()); builder.cache(cache); //错误重连 builder.retryOnConnectionFailure(true); //设置超时 builder.connectTimeout(15, TimeUnit.SECONDS); builder.readTimeout(15, TimeUnit.SECONDS); builder.writeTimeout(15, TimeUnit.SECONDS); okHttpClient = builder.build(); } } } 以上; 使用 CustomGsonConverter.java / NetworkApis.java通过getNetworkApis()方法,向外提供了一个请求服务.其中 .addConverterFactory(CustomGsonConverter.create(gson))是使用自定义的Converter替代了默认提供的 CustomGsonConverter.java /** * If you have any questions, you can contact by email {wangzhumoo@gmail.com} * @author 王诛魔 2017/10/24 上午10:31 * * GsonConverter 用于在不解析返回正文的前提下获取请求成功失败和 返回信息 */ public class CustomGsonConverter extends Converter.Factory { private final Gson gson; private CustomGsonConverter(Gson gson) { if (gson == null) { throw new NullPointerException(&quot;gson == null&quot;); } this.gson = gson; } public static CustomGsonConverter create() { return create(new Gson()); } public static CustomGsonConverter create(Gson gson) { return new CustomGsonConverter(gson); } @Override public Converter&lt;ResponseBody, ?&gt; responseBodyConverter(Type type, Annotation[] annotations, Retrofit retrofit) { TypeAdapter&lt;?&gt; adapter = gson.getAdapter(TypeToken.get(type)); return new CustomGsonResponseBodyConverter&lt;&gt;(gson, adapter); } private class CustomGsonResponseBodyConverter&lt;T&gt; implements Converter&lt;ResponseBody, T&gt; { private final Gson gson; private final TypeAdapter&lt;T&gt; adapter; public CustomGsonResponseBodyConverter(Gson gson, TypeAdapter&lt;T&gt; adapter) { this.gson = gson; this.adapter = adapter; } @Override public T convert(ResponseBody value) throws IOException { String response = value.string(); BaseResponse baseResponse = gson.fromJson(response,BaseResponse.class); if (!baseResponse.isCodeSuccess()) { value.close(); throw new ApiException(baseResponse.error); } MediaType contentType = value.contentType(); Charset charset = contentType != null ? contentType.charset(UTF_8) : UTF_8; InputStream inputStream = new ByteArrayInputStream(response.getBytes()); Reader reader = new InputStreamReader(inputStream, charset); JsonReader jsonReader = gson.newJsonReader(reader); try { return adapter.read(jsonReader); } finally { value.close(); } } } @Nullable @Override public Converter&lt;?, RequestBody&gt; requestBodyConverter(Type type, Annotation[] parameterAnnotations, Annotation[] methodAnnotations, Retrofit retrofit) { return super.requestBodyConverter(type,parameterAnnotations,methodAnnotations,retrofit); } } requestBodyConverter没有重写,后面发现了一个bug,上传文件+文字参数时,可能会造成 Length出错.responseBodyConverter 重写,先把response解析,如果有问题则throw new ApiException(baseResponse.error);会主动走RxJava的 onError() 如果没有问题,则继续,好像有点多余…… ApiException.java 就是用于封装异常 /** * If you have any questions, you can contact by email {wangzhumoo@gmail.com} * @author 王诛魔 2017/10/24 上午10:29 * * 此类作为网络请求异常的基 */ public class ApiException extends IOException { String code; String msg; public ApiException(String code){ this.code = code; } public ApiException(String msg, String code){ super(msg); this.msg = msg; this.code = code; } public boolean getCode() { return code; } @Override public String getMessage() { return msg; } } 3.Response返回数据的封装 这里根据后台返回数据结构 我们的返回是 { &quot;result&quot;:{ }, &quot;msg&quot;:&quot;请求成功&quot;, &quot;code&quot;:&quot;0000&quot; } BaseResponse.java /** * If you have any questions, you can contact by email {wangzhumoo@gmail.com} * @author 王诛魔 2017/10/19 下午5:41 * */ public class BaseResponse{ public String code; public String msg; /** * API是否请求失败 * * @return 失败返回true, 成功返回false */ public boolean isCodeSuccess() { return &quot;0000&quot;.equals(code); } } 所有的返回数据类,都要继承它,便于CustomGsonConverter 中判断返回数据的正确性 ResultResponse.java /** * If you have any questions, you can contact by email {wangzhumoo@gmail.com} * @author 王诛魔 2017/10/19 下午5:37 */ public class ResultResponse&lt;T&gt; extends BaseResponse { private T result; public T getResult() { return result; } } 通过T\b泛型,指定返回result的结构,让gson解析成实体对象 T 可能是 实体对象 可能是 \bList&lt;实体对象&gt; …. 4.请求数据 NetworkApis.java /** * If you have any questions, you can contact by email {wangzhumoo@gmail.com} * @author 王诛魔 2017/10/19 下午5:40 * * 所有网络请求 */ public interface NetworkApis { /** * 获取朋友圈列表 * @param token * @return */ @POST(&quot;QCRL/qcrl?command=getFriendsCircle&quot;) @FormUrlEncoded Flowable&lt;ResultResponse&lt;List&lt;FriendItem&gt;&gt;&gt; getFriendsCircle( @Field(&quot;token&quot;) String token, @Field(&quot;number&quot;) String number, @Field(&quot;userId&quot;) String userId, @Field(&quot;lastDate&quot;) String lastId); /** * 删除 * @param token * @param circleId * @return */ @POST(&quot;QCRL/qcrl?command=updateFriendsCircle&quot;) @FormUrlEncoded Flowable&lt;ResultResponse&lt;String&gt;&gt; updateFriendsCircle( @Field(&quot;token&quot;) String token, @Field(&quot;circleId&quot;) String circleId); /** * 赞 * @param token * @param circleId * @param userId * @return */ @POST(&quot;QCRL/qcrl?command=addFavor&quot;) @FormUrlEncoded Flowable&lt;ResultResponse&lt;Object&gt;&gt; addFavor( @Field(&quot;token&quot;) String token, @Field(&quot;circleId&quot;) String circleId, @Field(&quot;toId&quot;) String userId); ... } 根据自己的接口编写即可@POST() 指请求方式为 POST 注意,括号中的网址,开头不可以使用/QCRL/…否则会直接拼到HOST后面,url可能会错误 @FormUrlEncoded 表示form表单提交,会Encoded编码参数 @Field 每一个参数","categories":[{"name":"Android","slug":"Android","permalink":"https://www.wangzhumo.com/categories/Android/"}],"tags":[{"name":"Android","slug":"Android","permalink":"https://www.wangzhumo.com/tags/Android/"},{"name":"Okhttp","slug":"Okhttp","permalink":"https://www.wangzhumo.com/tags/Okhttp/"},{"name":"Rxjava","slug":"Rxjava","permalink":"https://www.wangzhumo.com/tags/Rxjava/"}]},{"title":"Android项目的build.gradle通用设置","slug":"Android-build-gradle-config","date":"2017-12-25T03:57:59.000Z","updated":"2019-12-22T12:03:23.407Z","comments":true,"path":"2017/12/25/Android-build-gradle-config/","link":"","permalink":"https://www.wangzhumo.com/2017/12/25/Android-build-gradle-config/","excerpt":"","text":"apply plugin: &#39;com.android.application&#39; android { //开启dataBinding dataBinding{ enabled = true } defaultConfig { //开启multiDex multiDexEnabled true //使用jni ndk { //设置支持的SO库架构,这里的意思是只支持&#39;armeabi&#39;, &#39;armeabi-v7a&#39;, &#39;x86&#39; //这三种架构 abiFilters &#39;armeabi&#39;, &#39;armeabi-v7a&#39;, &#39;x86&#39; } } //设置一个编译的配置 signingConfigs { //名为release\b\b的配置项 release { //签名文件的位置,当前位置是根目录 storeFile file(&quot;/keyfile.jks&quot;) //storePassword storePassword &quot;xxxxxxxx&quot; //keyAlias keyAlias &quot;wangzhumo&quot; //keyPassword keyPassword &quot;xxxxxxxx&quot; //是否使用v2Signing v2SigningEnabled false } } //编译的版本 buildTypes { //debug时的配置 debug { minifyEnabled false //这里使用上面配置的签名,可以做到debug时,也使用的是正式签名,而不是debug的 keystore signingConfig signingConfigs.release //buildConfig 的一个参数,是否开启log buildConfigField &quot;boolean&quot;, &quot;LOG_DEBUG&quot;, &quot;true&quot; proguardFiles getDefaultProguardFile(&#39;proguard-android.txt&#39;), &#39;proguard-rules.pro&#39; } release { // 显示Log minifyEnabled false signingConfig signingConfigs.release buildConfigField &quot;boolean&quot;, &quot;LOG_DEBUG&quot;, &quot;false&quot; proguardFiles getDefaultProguardFile(&#39;proguard-android.txt&#39;), &#39;proguard-rules.pro&#39; } } //adb的配置项 adbOptions { //超时时间 timeOutInMs = 5 * 1000 //adb install -r /path..apk installOptions &#39;-r&#39; } flavorDimensions &#39;env&#39; productFlavors { //正式版本 envydemo{ dimension &#39;env&#39; //此处是versionName versionName &quot;V1.1&quot; //manifestPlaceholders //是manifest已经定义的参数,这里给该参数赋值 manifestPlaceholders = [UMENG_CHANNEL_VALUE: &quot;wangzhumoo&quot;] //buildConfig 的参数,App当前的HOST地址 buildConfigField &quot;String&quot;,&quot;SERVER_HOST&quot;,&#39;&quot;http://app....com/&quot;&#39; } envtest { dimension &#39;env&#39; versionName &quot;Test&quot; manifestPlaceholders = [UMENG_CHANNEL_VALUE: &quot;wangzhumoo&quot;] buildConfigField &quot;String&quot;,&quot;SERVER_HOST&quot;,&#39;&quot;http://app.test....com/&quot;&#39; } } //自定义apk名字 android.applicationVariants.all { variant -&gt; variant.outputs.all { //apk的名字 outputFileName = &quot;App_${variant.versionName}.apk&quot; } } android { //排除 configurations.all { resolutionStrategy.force &#39;com.google.code.findbugs:jsr305:1.3.9&#39; } } //使用java8 compileOptions { sourceCompatibility JavaVersion.VERSION_1_8 targetCompatibility JavaVersion.VERSION_1_8 } } 以上代码,删除了常见的部分. buildConfigField /** * 常量类 */ public class Constants { //取到在productFlavors.envyhcs配置的参数 //buildConfigField &quot;String&quot;,&quot;SERVER_HOST&quot;,&#39;&quot;http://app....com/&quot;&#39; public static final String BASE_URL = BuildConfig.SERVER_HOST; } manifestPlaceholders &lt;manifest&gt; &lt;application&gt; //取到在productFlavors.envyhcs配置的参数 //manifestPlaceholders = [UMENG_CHANNEL_VALUE: &quot;wangzhumo&quot;] &lt;meta-data android:name=&quot;UMENG_CHANNEL&quot; android:value=&quot;${UMENG_CHANNEL_VALUE}&quot; /&gt; &lt;/application&gt; &lt;/manifest&gt; Build Variants在build.gradle中配置了productFlavors{ envdemo{} , envtest{}} 其中dimension一个维度其中buildTypes一个维度 debug + evndemodebug + evntestrelease + evndemerelease + evntest 共4种,其他的并没有使用到,所以不做说明 可以\b选择debug默认的版本…","categories":[{"name":"Android","slug":"Android","permalink":"https://www.wangzhumo.com/categories/Android/"}],"tags":[{"name":"Android","slug":"Android","permalink":"https://www.wangzhumo.com/tags/Android/"},{"name":"Gradle","slug":"Gradle","permalink":"https://www.wangzhumo.com/tags/Gradle/"}]},{"title":"Android 项目统一管理依赖版本","slug":"Android-dependent-config","date":"2017-12-25T03:39:45.000Z","updated":"2019-12-22T12:03:26.464Z","comments":true,"path":"2017/12/25/Android-dependent-config/","link":"","permalink":"https://www.wangzhumo.com/2017/12/25/Android-dependent-config/","excerpt":"准备引入Arouter,做一个组件的demo,就开始慢慢的改造项目 . |-- app | |-- build.gradle | |-- libs | |-- src | | |-- androidTest | | |-- main | | `-- test | |-- opensource | |-- build.gradle | |-- libs | `-- src | `-- main |-- build.gradle |-- settings.gradle `-- versions.gradle app 为主项目opensource 作为library存在,将来会成为baseLib的依赖,其中是所有的三方依赖,开源代码等等","text":"准备引入Arouter,做一个组件的demo,就开始慢慢的改造项目 . |-- app | |-- build.gradle | |-- libs | |-- src | | |-- androidTest | | |-- main | | `-- test | |-- opensource | |-- build.gradle | |-- libs | `-- src | `-- main |-- build.gradle |-- settings.gradle `-- versions.gradle app 为主项目opensource 作为library存在,将来会成为baseLib的依赖,其中是所有的三方依赖,开源代码等等 1.根目录创建versions.gradle /versions.gradle ext.deps = [:] def versions = [:] versions.arch = &quot;1.0.0&quot; versions.support = &quot;27.0.1&quot; versions.dagger = &quot;2.13&quot; versions.stetho = &quot;1.5.0&quot; versions.dialogs = &quot;0.9.6.0&quot; versions.glide = &quot;4.3.1&quot; versions.gradle = &quot;3.0.1&quot; versions.rxJava = &quot;2.1.7&quot; versions.rxAndroid = &quot;2.0.1&quot; versions.rxRelay = &quot;2.0.0&quot; versions.rxBinding = &quot;2.0.0&quot; versions.paging = &quot;1.0.0-alpha3&quot; versions.okhttp = &quot;3.9.0&quot; versions.retrofit = &quot;2.3.0&quot; versions.kotlin = &quot;1.2.0&quot; versions.kotlinBind = &quot;3.0.1&quot; versions.gson = &quot;2.8.2&quot; versions.arouterVersion = &quot;1.2.4&quot; versions.arouterProcessor = &quot;1.1.4&quot; versions.atslRunner = &quot;1.0.1&quot; versions.atslRules = &quot;1.0.1&quot; versions.hamcrest = &quot;1.3&quot; versions.timber = &quot;4.5.1&quot; versions.mockwebserver = &quot;3.8.1&quot; versions.apache_commons = &quot;2.5&quot; versions.mockito = &quot;2.7.19&quot; versions.mockito_all = &quot;1.10.19&quot; versions.dexmaker = &quot;2.2.0&quot; versions.constraint = &quot;1.0.2&quot; versions.junit = &quot;4.12&quot; versions.espresso = &quot;3.0.1&quot; def deps = [:] def rxLib = [:] rxLib.rxJava = &quot;io.reactivex.rxjava2:rxjava:$versions.rxJava&quot; rxLib.rxAndroid = &quot;io.reactivex.rxjava2:rxandroid:$versions.rxAndroid&quot; rxLib.rxBinding = &quot;com.jakewharton.rxbinding2:rxbinding:$versions.rxBinding&quot; rxLib.rxBingingV4 = &quot;com.jakewharton.rxbinding2:rxbinding-support-v4:$versions.rxBinding&quot; rxLib.rxBingingRecycler = &quot;com.jakewharton.rxbinding2:rxbinding-recyclerview-v7:$versions.rxBinding&quot; rxLib.rxBingingV7 = &quot;com.jakewharton.rxbinding2:rxbinding-appcompat-v7:$versions.rxBinding&quot; rxLib.rxBingingDesign = &quot;com.jakewharton.rxbinding2:rxbinding-design:$versions.rxBinding&quot; rxLib.rxRelay = &quot;com.jakewharton.rxrelay2:rxrelay:$versions.rxRelay&quot; deps.rxLibs = rxLib def support = [:] support.annotations = &quot;com.android.support:support-annotations:$versions.support&quot; support.appCompat = &quot;com.android.support:appcompat-v7:$versions.support&quot; support.recyclerview = &quot;com.android.support:recyclerview-v7:$versions.support&quot; support.cardview = &quot;com.android.support:cardview-v7:$versions.support&quot; support.design = &quot;com.android.support:design:$versions.support&quot; support.v4 = &quot;com.android.support:support-v4:$versions.support&quot; support.coreUtils = &quot;com.android.support:support-core-utils:$versions.support&quot; deps.support = support def archLib = [:] archLib.archExtensions = &quot;android.arch.lifecycle:extensions:$versions.arch&quot; archLib.archRoomRuntime = &quot;android.arch.persistence.room:runtime:$versions.arch&quot; archLib.archRoomCompiler = &quot;android.arch.persistence.room:compiler:$versions.arch&quot; archLib.archLifecycleCommon = &quot;android.arch.lifecycle:common-java8:$versions.arch&quot; deps.archLibs = archLib def glide = [:] glide.glide = &quot;com.github.bumptech.glide:glide:$versions.glide&quot; glide.glideCompiler = &quot;com.github.bumptech.glide:compiler:$versions.glide&quot; deps.glide = glide def stethos = [:] stethos.stetho = &quot;com.facebook.stetho:stetho:$versions.stetho&quot; stethos.stethoHttp = &quot;com.facebook.stetho:stetho-okhttp3:$versions.stetho&quot; deps.stetho = stethos def okhttp = [:] okhttp.okhttp = &quot;com.squareup.okhttp3:okhttp:$versions.okhttp&quot; okhttp.okhttpLogging = &quot;com.squareup.okhttp3:logging-interceptor:$versions.okhttp&quot; deps.okhttp = okhttp def retrofit = [:] retrofit.retrofit = &quot;com.squareup.retrofit2:retrofit:$versions.retrofit&quot; retrofit.converterGson = &quot;com.squareup.retrofit2:converter-gson:$versions.retrofit&quot; retrofit.adapterRxjava = &quot;com.squareup.retrofit2:adapter-rxjava2:$versions.retrofit&quot; deps.retrofit = retrofit def arouter = [:] arouter.runtime = &quot;com.alibaba:arouter-api:$versions.arouterVersion&quot; arouter.compiler = &quot;com.alibaba:arouter-compiler:$versions.arouterProcessor&quot; deps.arouter = arouter def dagger = [:] dagger.dagger = &quot;com.google.dagger:dagger:$versions.dagger&quot; dagger.daggerAndroid = &quot;com.google.dagger:dagger-android:$versions.dagger&quot; dagger.daggerAndroidSupport = &quot;com.google.dagger:dagger-android-support:$versions.dagger&quot; dagger.daggerCompiler = &quot;com.google.dagger:dagger-compiler:$versions.dagger&quot; dagger.daggerAndroidCompiler = &quot;com.google.dagger:dagger-android-processor:$versions.dagger&quot; deps.dagger = dagger def kotlin = [:] kotlin.kotlinStdlib = &quot;org.jetbrains.kotlin:kotlin-stdlib-jre8:$versions.kotlin&quot; kotlin.kotlinPlugin = &quot;org.jetbrains.kotlin:kotlin-gradle-plugin:$versions.kotlin&quot; kotlin.kotlinDatabind = &quot;com.android.databinding:compiler:$versions.kotlinBind&quot; deps.kotlin = kotlin def espresso = [:] espresso.core = &quot;com.android.support.test.espresso:espresso-core:$versions.espresso&quot; espresso.contrib = &quot;com.android.support.test.espresso:espresso-contrib:$versions.espresso&quot; espresso.intents = &quot;com.android.support.test.espresso:espresso-intents:$versions.espresso&quot; deps.espresso = espresso def atsl = [:] atsl.runner = &quot;com.android.support.test:runner:$versions.atsl_runner&quot; atsl.rules = &quot;com.android.support.test:rules:$versions.atsl_runner&quot; deps.atsl = atsl deps.multidex = &quot;com.android.support:multidex:1.0.1&quot; deps.dialog = &quot;com.afollestad.material-dialogs:core:$versions.dialogs&quot; deps.gson = &quot;com.google.code.gson:gson:$versions.gson&quot; deps.paging = &quot;android.arch.paging:runtime:$versions.paging&quot; deps.dexmaker = &quot;com.linkedin.dexmaker:dexmaker-mockito:$versions.dexmaker&quot; deps.constraint = &quot;com.android.support.constraint:constraint-layout:$versions.constraint&quot; deps.timber = &quot;com.jakewharton.timber:timber:$versions.timber&quot; deps.gradlePlugin = &quot;com.android.tools.build:gradle:$versions.gradle&quot; deps.kotlinPlugin = &quot;org.jetbrains.kotlin:kotlin-gradle-plugin:$versions.kotlin&quot; ext.deps = deps def buildVersions = [:] buildVersions.minSDK = 14 buildVersions.targetSDK = 26 buildVersions.compileSDK = 27 buildVersions.buildTools = &quot;26.0.2&quot; ext.buildVersion = buildVersions def addRepos(RepositoryHandler handler) { handler.google() handler.jcenter() handler.mavenCentral() handler.maven { url &#39;https://oss.jfrog.org/libs-snapshot&#39; } handler.maven { url &#39;https://jitpack.io&#39; } } ext.addRepos = this.&amp;addRepos 其中声明了所有已经用到,或者可能使用的Lib版本,以及Android sdk tools 的版本. 2.将声明的版本,添加到项目中,方便引用 /build.gradle 项目的build.gradle中 buildscript { //加入引用 apply from: &#39;versions.gradle&#39; //添加rep addRepos(repositories) dependencies { //由versions.gradle管理的版本 classpath deps.gradlePlugin classpath deps.kotlinPlugin // NOTE: Do not place your application dependencies here; they belong // in the individual module build.gradle files } } allprojects { //添加rep addRepos(repositories) } 3.对Android Tools,SDK版本的控制项目/app/build.gradle android { //sdk的版本 compileSdkVersion buildVersion.compileSDK //tools的版本 buildToolsVersion buildVersion.buildTools defaultConfig { //sdk版本 minSdkVersion buildVersion.minSDK targetSdkVersion buildVersion.targetSDK versionCode 1 //也可以使用 versionName &quot;1.0&quot; } // } 4.其他Lib的依赖按照这样的格式即可 dependencies { //support api deps.support.appCompat api deps.support.recyclerview api deps.support.cardview api deps.support.design api deps.multidex api deps.constraint //rxjava api deps.rxLibs.rxJava api deps.rxLibs.rxAndroid api deps.rxLibs.rxRelay //http api deps.okhttp.okhttp api deps.okhttp.okhttpLogging api deps.retrofit.retrofit api deps.retrofit.converterGson api deps.retrofit.adapterRxjava api deps.gson //arch api deps.archLibs.archExtensions api deps.archLibs.archRoomRuntime api deps.archLibs.archLifecycleCommon annotationProcessor deps.archLibs.archRoomCompiler //stetho api deps.stetho.stetho api deps.stetho.stethoHttp //dialog api deps.dialog //glide api deps.glide.glide annotationProcessor deps.glide.glideCompiler }","categories":[{"name":"Android","slug":"Android","permalink":"https://www.wangzhumo.com/categories/Android/"}],"tags":[{"name":"Android","slug":"Android","permalink":"https://www.wangzhumo.com/tags/Android/"},{"name":"Gradle","slug":"Gradle","permalink":"https://www.wangzhumo.com/tags/Gradle/"},{"name":"组件化","slug":"组件化","permalink":"https://www.wangzhumo.com/tags/组件化/"}]},{"title":"常用的Google Chrome 浏览器插件","slug":"Google-Chrome-Plug-In","date":"2017-12-25T02:35:02.000Z","updated":"2019-12-22T12:09:55.172Z","comments":true,"path":"2017/12/25/Google-Chrome-Plug-In/","link":"","permalink":"https://www.wangzhumo.com/2017/12/25/Google-Chrome-Plug-In/","excerpt":"###几个比较常用的Chrome插件 1.AdBlock 最受欢迎的Chrome扩展，拥有超过4000万用户！屏蔽整个互联网上的广告。 推荐: ★★★","text":"###几个比较常用的Chrome插件 1.AdBlock 最受欢迎的Chrome扩展，拥有超过4000万用户！屏蔽整个互联网上的广告。 推荐: ★★★ 2.Insight.io for Github Improve GitHub code browsing experienc.通过插件可以在github的项目页面上,结构化的查看代码,甚至还有”引用”,”查找”等等功能.就像是把github项目页,变成了一个只能查看的ide.对了,还能很方便的下载单个文件 推荐: \b\b\b★★★★★ 3.Infinity新标签页 重新定义了新标签页，一个追求极简美学和一站式服务体验更少的东西体验更多的功能。 简洁,方便,实用 推荐:★★★★ 4.PostmanPostman makes API development faster, easier, and better. 更快…..哈哈超级方便,模拟请求的App,支持post get,可以测试文件上传等还有比较方便的一点是,可以生成当前请求的okhttp\b代码,虽然只能作参考….. 推荐:★★★★★ 和它一样的还有Restlet Client - REST API Testing 5.BaiduExporter可以方便的把网盘的下载地址导出到aria2/aria2-rpc，支持YAAW。配合Aria2GUI,可以高速下载百度云限速的文件.. 虽然还能用,但是作者说不维护了,还有替代品:Aria2c Integration没有用过,不知道是否可用. Aria2GUIGithub : https://github.com/aria2/aria2 推荐:★★★★★ 其他推荐:★★★ SingleFileArchive a complete page into a single HTML file可以将网页保存为单文件,方便保存 印象笔记·剪藏使用印象笔记扩展程序一键保存精彩网页内容到印象笔记帐户。 JSON FormatterChrome extension for printing JSON and JSONP nicely when you visit it ‘directly’ in a browser tab.Github : https://github.com/callumlocke/json-formatter","categories":[{"name":"Tools","slug":"Tools","permalink":"https://www.wangzhumo.com/categories/Tools/"}],"tags":[{"name":"tools","slug":"tools","permalink":"https://www.wangzhumo.com/tags/tools/"}]},{"title":"Jni使用指南,关于.so你应该知道的","slug":"jni-with-so","date":"2017-12-25T02:12:59.000Z","updated":"2019-12-22T12:09:28.265Z","comments":true,"path":"2017/12/25/jni-with-so/","link":"","permalink":"https://www.wangzhumo.com/2017/12/25/jni-with-so/","excerpt":"其实这些都是Android设备CPU的: armeabi: 早期的手机用的比较多,针对普通的或旧的arm v5 cpu,。 armeabiv-v7a:目前主流版本 2011年以后的生产的大部分设备,针对有浮点运算或高级扩展功能的arm v7 cpu. arm64-v8a: 8代、64位ARM处理器，64位支持. x86: 我们见到的模拟器大多就是这个。 x86_64: 64位的平板。 然后特意说一下x86系列的,是兼容arm的,但是性能损失特别大.","text":"其实这些都是Android设备CPU的: armeabi: 早期的手机用的比较多,针对普通的或旧的arm v5 cpu,。 armeabiv-v7a:目前主流版本 2011年以后的生产的大部分设备,针对有浮点运算或高级扩展功能的arm v7 cpu. arm64-v8a: 8代、64位ARM处理器，64位支持. x86: 我们见到的模拟器大多就是这个。 x86_64: 64位的平板。 然后特意说一下x86系列的,是兼容arm的,但是性能损失特别大. Android加载.so的原则同一目录下要么所有使用jni的项目都给加上.so文件,要么你就别给这个目录,也就是只要不齐全就都干掉比如你的lib结构是这样的 libs -armeabi -aaa.so -bbb.so -arm64-v8a -aaa.so 其实这种情况就是属于同一目录下,提供的.so文件不全…然而很容易出现,毕竟有些三方啊什么的,提供的.so文件并不齐全,这样的话同一个架构目录下会缺少一个或多个.so文件. Android在加载某个使用jni的功能时,你并没有提供x86的.so文件,但是你有x86这个目录,那就会去x86目录下去找,没有啊然后就异常了. Android加载.so的目录1.我自己用的是 也就是自己在app -&gt; src -&gt; main 下自己建立一个目录: jniLibs然后放进去即可. 2.就是通常放在libs目录下了别忘了在build.gradle文件中设置 jniLibs.srcDir Android排除某架构的.so android { ... defaultConfig { ... ndk { // 设置支持的 SO 库构架 abiFilters &#39;armeabi&#39;, &#39;armeabi-v7a&#39; // &#39;arm64-v8a&#39;, &#39;x86&#39;, &#39;x86_64&#39;, &#39;mips&#39;, &#39;mips64&#39; } } } 如果编译报 NDK integration is deprecated in the current plugin. gradle.properties 文件中添加： android.useDeprecatedNdk=true 应该还有其他方法排除,我也就知道这一种,如果有知道其他方法的,请告知一下,谢谢","categories":[],"tags":[{"name":"JNI，Android","slug":"JNI，Android","permalink":"https://www.wangzhumo.com/tags/JNI，Android/"}]},{"title":"EditText的输入属性InputType以及imeOptions","slug":"EditText-InputType-imeOptions","date":"2017-12-25T02:11:15.000Z","updated":"2019-12-22T12:10:37.765Z","comments":true,"path":"2017/12/25/EditText-InputType-imeOptions/","link":"","permalink":"https://www.wangzhumo.com/2017/12/25/EditText-InputType-imeOptions/","excerpt":"EditText的输入属性 android:imeOptions=&quot;flagNoExtractUi&quot; //使软键盘不全屏显示，只占用部分屏幕 android:imeOptions=&quot;actionNone&quot; //输入框右侧不带任何提示 android:imeOptions=&quot;actionGo&quot; //右下角按键内容为&#39;开始&#39; android:imeOptions=&quot;actionSearch&quot; //右下角按键为搜索 android:imeOptions=&quot;actionSend&quot; //右下角按键内容为&#39;发送&#39; android:imeOptions=&quot;actionNext&quot; //右下角按键内容为&#39;下一步&#39; android:imeOptions=&quot;actionDone&quot; //右下角按键内容为&#39;完成&#39;","text":"EditText的输入属性 android:imeOptions=&quot;flagNoExtractUi&quot; //使软键盘不全屏显示，只占用部分屏幕 android:imeOptions=&quot;actionNone&quot; //输入框右侧不带任何提示 android:imeOptions=&quot;actionGo&quot; //右下角按键内容为&#39;开始&#39; android:imeOptions=&quot;actionSearch&quot; //右下角按键为搜索 android:imeOptions=&quot;actionSend&quot; //右下角按键内容为&#39;发送&#39; android:imeOptions=&quot;actionNext&quot; //右下角按键内容为&#39;下一步&#39; android:imeOptions=&quot;actionDone&quot; //右下角按键内容为&#39;完成&#39; EditText的inputType属性 &lt;EditText android:inputType=&quot;phone&quot; //电话号码 android:inputType=&quot;none&quot; android:inputType=&quot;text&quot; //文本类型 android:inputType=&quot;textCapCharacters&quot; //字母大写 android:inputType=&quot;textCapWords&quot; //首字母大写 android:inputType=&quot;textCapSentences&quot; //仅第一个字母大写 android:inputType=&quot;textAutoCorrect&quot; //自动完成 android:inputType=&quot;textAutoComplete&quot; //自动完成 android:inputType=&quot;textMultiLine&quot; //多行输入 android:inputType=&quot;textImeMultiLine&quot; //输入法多行 android:inputType=&quot;textNoSuggestions&quot; //不提示 android:inputType=&quot;textUri&quot; //网址 android:inputType=&quot;textEmailAddress&quot; //电子邮件地址 android:inputType=&quot;textEmailSubject&quot; //邮件主题 android:inputType=&quot;textShortMessage&quot; //短讯 android:inputType=&quot;textLongMessage&quot; //长信息 android:inputType=&quot;textPersonName&quot; //人名 android:inputType=&quot;textPostalAddress&quot; //地址 android:inputType=&quot;textPassword&quot; //密码 android:inputType=&quot;textVisiblePassword&quot; //可见密码 android:inputType=&quot;textWebEditText&quot; //作为网页表单的文本 android:inputType=&quot;textFilter&quot; //文本筛选过滤 android:inputType=&quot;textPhonetic&quot; //拼音输入 android:inputType=&quot;number&quot; //数字 android:inputType=&quot;numberSigned&quot; //带符号数字格式 android:inputType=&quot;numberDecimal&quot; //带小数点的浮点格式 android:inputType=&quot;datetime&quot; //时间日期 android:inputType=&quot;date&quot; //日期键盘 android:inputType=&quot;time&quot; //时间键盘 /&gt;","categories":[{"name":"Android","slug":"Android","permalink":"https://www.wangzhumo.com/categories/Android/"}],"tags":[{"name":"Android","slug":"Android","permalink":"https://www.wangzhumo.com/tags/Android/"}]},{"title":"TextView中的文字颜色,点击,斜体等实现--SpannableString","slug":"textview-span","date":"2017-12-25T02:06:03.000Z","updated":"2019-12-22T12:20:46.923Z","comments":true,"path":"2017/12/25/textview-span/","link":"","permalink":"https://www.wangzhumo.com/2017/12/25/textview-span/","excerpt":"一般实现方式如下: String html = &quot;文字&lt;font color=\\&quot;red\\&quot;&gt;变色&lt;/font&gt;的效果&quot;; tvMainShow.setText(Html.fromHtml(html)); 使用Html的方式来实现,简单的还好,复杂一点的真的很不方便","text":"一般实现方式如下: String html = &quot;文字&lt;font color=\\&quot;red\\&quot;&gt;变色&lt;/font&gt;的效果&quot;; tvMainShow.setText(Html.fromHtml(html)); 使用Html的方式来实现,简单的还好,复杂一点的真的很不方便 Google显然早就已经想到了这样的问题,所以 SpannedString &amp; SpannableStringBuilder 就是干这个的 他们都实现了 CharSequence,眼熟么? setText(CharSequence text).也就是说,你可以直接赋值给TextView 他们两个的区别就是This is the class for text whose content is immutable but to which markup objects can be attached and detached. For mutable text, see SpannableStringBuilder文档说的很清楚了,就是CharSequence是固定长度的,一旦通过 new SpannableString(“设置文字”);则不可以更改文字内容,而SpannableStringBuilder是可以的,个人理解比较像String 和 StringBuilder 的关系 ###不多说了,开搞:1.设置文字 SpannableString spannableString = new SpannableString(&quot;文字的前景色与背景色&quot;); 2.通过setSpan来修改文字的样式 setSpan [Object what, int start, int end, int flags) flags:Spannable.SPAN_EXCLUSIVE_EXCLUSIVE：前后都不包括Spannable.SPAN_EXCLUSIVE_INCLUSIVE ：前面不包括Spannable.SPAN_INCLUSIVE_EXCLUSIVE ：前面包括Spannable.SPAN_INCLUSIVE_INCLUSIVE ：前后都包括 为了说明这四个参数,有例子如下: 代码如下: /* * * @author 王诛魔 2017/1/21 上午11:31 * @e-mail phyooos@163.com */ public class MainActivity extends AppCompatActivity { @BindView(R.id.edit_show) EditText etMainShow; @BindView(R.id.tab_view) TabLayout tabLayout; @Override public void onCreate(@Nullable Bundle savedInstanceState) { super.onCreate(savedInstanceState); setContentView(R.layout.activity_main); ButterKnife.bind(this); showText(Spannable.SPAN_EXCLUSIVE_EXCLUSIVE); tabLayout.setOnTabSelectedListener(new TabLayout.OnTabSelectedListener() { @Override public void onTabSelected(TabLayout.Tab tab) { switch (tab.getPosition()) { case 0: showText(Spannable.SPAN_EXCLUSIVE_EXCLUSIVE); break; case 1: showText(Spannable.SPAN_EXCLUSIVE_INCLUSIVE); break; case 2: showText(Spannable.SPAN_INCLUSIVE_EXCLUSIVE); break; case 3: showText(Spannable.SPAN_INCLUSIVE_INCLUSIVE); break; } } @Override public void onTabUnselected(TabLayout.Tab tab) { } @Override public void onTabReselected(TabLayout.Tab tab) { } }); } /** * 展示文字 */ private void showText(int type) { //构造SpannableString SpannableString spanString = new SpannableString(&quot;这里是王诛魔的简书文章&quot;); //字体颜色的Span ForegroundColorSpan span = new ForegroundColorSpan(Color.RED); //指定范围 spanString.setSpan(span, 3, 6, type); //设置给EditText显示出来 etMainShow.setText(spanString); } } 上面的代码中: //字体颜色的Span ForegroundColorSpan span = new ForegroundColorSpan(Color.RED); ForegroundColorSpan就是设置的文字样式,,这个是前景色,,也就是字体的颜色 //指定范围 spanString.setSpan(span, 3, 6, type); 这里的三个参数已经在上面说过了,通过上面的代码也会发现,其实3,6 其中下标3是包含的,而下标6就不会改变 3.至于Span的这些个样式在哪里找,请看文档:关键词:CharacterStyle https://developer.android.com/reference/android/text/style/CharacterStyle.html 说几个常用的吧: ForegroundColorSpan 字体颜色 BackgroundColorSpan 字体背景色设置 AbsoluteSizeSpan 字体大小 StyleSpan 粗体等 //字体由Typeface来控制 StyleSpan span = new StyleSpan(Typeface.BOLD_ITALIC); UnderlineSpan 下划线 ImageSpan 图片置换 ImageSpan https://developer.android.com/reference/android/text/style/ImageSpan.html 这个有一点不同,它是将文字中的指定部分替换为一个图片,至于如何构造请参考文档让我想起来了那个EmojiEditText的库,其实可以用这个ImageSpan实现一个简单的可以显示表情的TextView ClickableSpan 点击 //这个有些不同,需要 class CustomClickable extends ClickableSpan { @Override public void updateDrawState(TextPaint ds) { //这里其实还可以对可点击部分设置一些东西 } @Override public void onClick(View widget) { ...do something } } //对了,加上这行代码 TextView.setMovementMethod(LinkMovementMethod.getInstance()); //要不点不动哦 URLSpan 这个完全可以用ClickableSpan实现 SpannableStringBuilder SpannableString都说的这么明白了,SpannableStringBuilder就省了 ####End","categories":[{"name":"Android","slug":"Android","permalink":"https://www.wangzhumo.com/categories/Android/"}],"tags":[{"name":"Android","slug":"Android","permalink":"https://www.wangzhumo.com/tags/Android/"}]},{"title":"Flutter 安装","slug":"Flutter-install-net-error","date":"2017-12-25T02:03:55.000Z","updated":"2019-12-22T12:10:22.150Z","comments":true,"path":"2017/12/25/Flutter-install-net-error/","link":"","permalink":"https://www.wangzhumo.com/2017/12/25/Flutter-install-net-error/","excerpt":"使用系统Mac OS 已经没办法给大家看问题了,我在github上提了问题. github issue 使用命令 command `flutter doctor` 异常: exception SocketException: SocketException: Connection failed (OS Error: No route to host, errno = 65), address = android.googlesource.com, port = 443 总的来说就是下载 Downloading Gradle Wrapper…的时候连接不到外网,以至于失败","text":"使用系统Mac OS 已经没办法给大家看问题了,我在github上提了问题. github issue 使用命令 command `flutter doctor` 异常: exception SocketException: SocketException: Connection failed (OS Error: No route to host, errno = 65), address = android.googlesource.com, port = 443 总的来说就是下载 Downloading Gradle Wrapper…的时候连接不到外网,以至于失败 github上的这位小哥提醒了我@lishuhao @eseidelGoogleit’s reachable via https from ChromeMaybe his chrome use proxy but terminal not use proxy. 我确实开了ss,但是终端确实连接不到代理的,不走代理,那当然无解 ##解决: ####1.Mac下使用Homebrew安装 brew install polipo ####2.修改配置 ln -sfv /usr/local/opt/polipo/*.plist ~/Library/LaunchAgents vim /usr/local/opt/polipo/homebrew.mxcl.polipo.plist 在配置文件中添加&lt;string&gt;socksParentProxy=localhost:1086&lt;/string&gt; 其中1086这个端口号,自己去看 ####3.启动 launchctl load ~/Library/LaunchAgents/homebrew.mxcl.polipo.plist ####4.使用 $ http_proxy=http://localhost:8123 curl ip.gs Current IP / 当前 IP: 47.90.88.133 ISP / 运营商: ALIYUN City / 城市: Hong Kong Country / 国家: China IP.GS is now IP.SB, please visit https://ip.sb/ for more IP information, ip.gs will only use for curl purpose. / IP.GS 已更新至 IP.SB 请访问 https://ip.sb/ 获取更多信息, ip.gs 域名仅作 curl 使用 Please join Telegram group https://t.me/sbfans if you have any issues. / 如有问题，请加入 Telegram 群 https://t.me/sbfans 可以看到,现在我是香港的IP了,http_proxy=http://localhost:8123这个是提供默认的,至于怎么修改我没有看,也不知道 把代理设置为全局的 ~ ⌚ 11:42:51 $ export http_proxy=http://localhost:8123 ~ ⌚ 11:43:02 $ export https_proxy=http://localhost:8123 ~ ⌚ 11:43:09 $ curl https://www.google.com &lt;HTML&gt;&lt;HEAD&gt;&lt;meta http-equiv=&quot;content-type&quot; content=&quot;text/html;charset=utf-8&quot;&gt; &lt;TITLE&gt;302 Moved&lt;/TITLE&gt;&lt;/HEAD&gt;&lt;BODY&gt; &lt;H1&gt;302 Moved&lt;/H1&gt; The document has moved &lt;A HREF=&quot;https://www.google.com.hk/?gfe_rd=cr&amp;ei=5FaaWZDNOMLU8Af_nriwDw&quot;&gt;here&lt;/A&gt;. &lt;/BODY&gt;&lt;/HTML&gt; ~ ⌚ 11:43:33 $ curl www.google.com &lt;HTML&gt;&lt;HEAD&gt;&lt;meta http-equiv=&quot;content-type&quot; content=&quot;text/html;charset=utf-8&quot;&gt; &lt;TITLE&gt;302 Moved&lt;/TITLE&gt;&lt;/HEAD&gt;&lt;BODY&gt; &lt;H1&gt;302 Moved&lt;/H1&gt; The document has moved &lt;A HREF=&quot;http://www.google.com.hk/?gfe_rd=cr&amp;ei=6laaWZqEO8_U8AeLlID4CA&quot;&gt;here&lt;/A&gt;. &lt;/BODY&gt;&lt;/HTML&gt; ####5.End ##见证奇迹的时刻到了 ~/develop/flutter on  alpha! ⌚ 11:44:11 $ flutter doctor Downloading Gradle Wrapper... 1.3s [✓] Flutter (on Mac OS X 10.12.6 16G29, locale zh-Hans-CN, channel alpha) • Flutter at /Users/phyooos/develop/flutter • Framework revision b156a0f054 (9 days ago), 2017-08-11 22:01:40 -0700 • Engine revision fef7d827d6 • Tools Dart version 1.25.0-dev.9.0 [✓] Android toolchain - develop for Android devices (Android SDK 26.0.1) • Android SDK at /Users/phyooos/Library/Android/sdk • Platform android-26, build-tools 26.0.1 • ANDROID_HOME = /Users/phyooos/Library/Android/sdk • Java binary at: /Applications/Android Studio.app/Contents/jre/jdk/Contents/Home/bin/java • Java version OpenJDK Runtime Environment (build 1.8.0_112-release-b06) [-] iOS toolchain - develop for iOS devices ✗ Xcode installation is incomplete; a full installation is necessary for iOS development. Download at: https://developer.apple.com/xcode/download/ Or install Xcode via the App Store. Once installed, run: sudo xcode-select --switch /Applications/Xcode.app/Contents/Developer ✗ libimobiledevice and ideviceinstaller are not installed or require updating. To update, run: brew uninstall --ignore-dependencies libimobiledevice brew install --HEAD libimobiledevice brew install ideviceinstaller ✗ ios-deploy not installed. To install: brew install ios-deploy ✗ CocoaPods not installed. CocoaPods is used to retrieve the iOS platform side&#39;s plugin code that responds to your plugin usage on the Dart side. Without resolving iOS dependencies with CocoaPods, plugins will not work on iOS. For more info, see https://flutter.io/platform-plugins To install: brew install cocoapods pod setup [✓] Android Studio (version 2.3) • Android Studio at /Applications/Android Studio.app/Contents • Java version OpenJDK Runtime Environment (build 1.8.0_112-release-b06) [✓] IntelliJ IDEA Ultimate Edition (version 2017.1.3) • Flutter plugin version 16.0 • Dart plugin version 171.4424.63 [✓] Connected devices • None 我的Flutter就ok了","categories":[{"name":"Flutter","slug":"Flutter","permalink":"https://www.wangzhumo.com/categories/Flutter/"}],"tags":[{"name":"Flutter","slug":"Flutter","permalink":"https://www.wangzhumo.com/tags/Flutter/"}]},{"title":"BottomNavigationView使用指南","slug":"BottomNavigationView","date":"2017-12-25T01:40:44.000Z","updated":"2019-12-22T12:05:14.354Z","comments":true,"path":"2017/12/25/BottomNavigationView/","link":"","permalink":"https://www.wangzhumo.com/2017/12/25/BottomNavigationView/","excerpt":"最终效果: Android Support Library 25 \b以上的support包中增加了 BottomNavigationView所以你必须使用com.android.support:design:25.0.0以上的版本才能玩","text":"最终效果: Android Support Library 25 \b以上的support包中增加了 BottomNavigationView所以你必须使用com.android.support:design:25.0.0以上的版本才能玩 1.在 build.gradle 文件中增加依赖： compile &#39;com.android.support:design:25.0.0&#39; 2.在main_activity.xml中添加: &lt;android.support.design.widget.BottomNavigationView android:id=&quot;@+id/bottom_nav&quot; android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;@dimen/title_height&quot; android:layout_alignParentBottom=&quot;true&quot; app:menu=&quot;@menu/menu_tab_button&quot; app:itemIconTint=&quot;@color/nav_color_select&quot; app:itemTextColor=&quot;@color/nav_color_select&quot; app:itemBackground=&quot;@color/text_white_color&quot;&gt; &lt;/android.support.design.widget.BottomNavigationView&gt; 其中app:menu=&quot;@menu/menu_tab_button&quot;决定了展示几个item,都长什么样 其中,分别决定图标和文字选中和未选中item的状态,颜色 app:itemIconTint=&quot;@color/nav_color_select&quot; app:itemTextColor=&quot;@color/nav_color_select&quot; 其中app:itemBackground=&quot;@color/text_white_color&quot;则是整个view的背景颜色 3.menu_tab_button.xml的代码如下: &lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt; &lt;menu xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot; xmlns:app=&quot;http://schemas.android.com/apk/res-auto&quot;&gt; &lt;item android:id=&quot;@+id/mian_tab_statistics&quot; android:enabled=&quot;true&quot; android:checked=&quot;true&quot; //默认选中 android:title=&quot;@string/nav_tongji&quot; android:icon=&quot;@drawable/tongji&quot;/&gt; &lt;item android:id=&quot;@+id/mian_tab_paidui&quot; android:enabled=&quot;true&quot; android:title=&quot;@string/nav_paidui&quot; //文字内容 android:icon=&quot;@drawable/paidui&quot;/&gt; //icon图标 &lt;item android:id=&quot;@+id/mian_tab_find&quot; android:enabled=&quot;true&quot; android:title=&quot;@string/nav_faxiang&quot; android:icon=&quot;@drawable/faxian&quot;/&gt; &lt;item android:id=&quot;@+id/mian_tab_more&quot; android:enabled=&quot;true&quot; android:title=&quot;@string/nav_more&quot; android:icon=&quot;@drawable/more&quot;/&gt; &lt;/menu&gt; ###然而,你以为会这么简单?? shiftingMode教你做人() ###这个只会在item个数超过3个才会出现. 4.这让我如何是好?看了半天,在网上找到一个方法. /** * 一个关于BottomNavigationView的帮助类,用来关闭shiftingMode * @author 王诛魔 2017/2/10 下午6:35 * @e-mail phyooos@163.com */ public class BNVHelper { public static void disableShiftMode(BottomNavigationView navigationView) { BottomNavigationMenuView menuView = (BottomNavigationMenuView) navigationView.getChildAt(0); try { Field shiftingMode = menuView.getClass().getDeclaredField(&quot;mShiftingMode&quot;); shiftingMode.setAccessible(true); shiftingMode.setBoolean(menuView, false); shiftingMode.setAccessible(false); for (int i = 0; i &lt; menuView.getChildCount(); i++) { BottomNavigationItemView itemView = (BottomNavigationItemView) menuView.getChildAt(i); itemView.setShiftingMode(false); itemView.setChecked(itemView.getItemData().isChecked()); } } catch (NoSuchFieldException e) { // Log } catch (IllegalAccessException e) { // Log } } } 原作者@ChristmasJason:http://www.jianshu.com/p/e2a8791e80d6 然后我看了一下源码mShiftingMode 这个布尔值决定了是否启用shiftingMode,所以上面的方法就是shiftingMode.setBoolean(menuView, false); 然后就好了…… 提示:google说选中图标的颜色是这么改的,然而都是骗人的,这个应该是默认的设置,我也偷懒没有验证 app:itemIconTint=&quot;@color/nav_color_select&quot; app:itemTextColor=&quot;@color/nav_color_select&quot; 其实你配置了之后,就是这个东西来决定的,而不是app’s primary colornav_color_select.xml这就是个选择器,代码如下: &lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt; &lt;selector xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;&gt; &lt;item android:state_checked=&quot;true&quot; android:color=&quot;@color/colorPrimary&quot; /&gt; &lt;item android:state_pressed=&quot;true&quot; android:color=&quot;@color/colorPrimary&quot; /&gt; &lt;item android:color=&quot;@color/gray_light&quot; /&gt; &lt;/selector&gt; ####End,到这里你的导航条也应该ok了","categories":[{"name":"Android","slug":"Android","permalink":"https://www.wangzhumo.com/categories/Android/"}],"tags":[{"name":"Android","slug":"Android","permalink":"https://www.wangzhumo.com/tags/Android/"},{"name":"View","slug":"View","permalink":"https://www.wangzhumo.com/tags/View/"}]},{"title":"Android Studio 使用正式签名debug调试","slug":"Android-Studio-signature-debug","date":"2017-12-25T01:38:59.000Z","updated":"2019-12-22T12:27:17.282Z","comments":true,"path":"2017/12/25/Android-Studio-signature-debug/","link":"","permalink":"https://www.wangzhumo.com/2017/12/25/Android-Studio-signature-debug/","excerpt":"解决问题: 很多时候我们使用第三方登录什么的东西,需要我们提供正式签名,但是我们总是需要调试的.一般情况,我们不可能一次性OK,那么每一次调试都需要正式签名打包,并安装,然后再调试,这也太麻烦了,.","text":"解决问题: 很多时候我们使用第三方登录什么的东西,需要我们提供正式签名,但是我们总是需要调试的.一般情况,我们不可能一次性OK,那么每一次调试都需要正式签名打包,并安装,然后再调试,这也太麻烦了,. 所以,直接上代码: signingConfigs { release { keyAlias &#39;phyooos&#39; keyPassword &#39;phyooos&#39; storeFile file(&#39;phyooos.jks&#39;) storePassword &#39;phyooos&#39; } } buildTypes { release { minifyEnabled false signingConfig signingConfigs.release proguardFiles getDefaultProguardFile(&#39;proguard-android.txt&#39;), &#39;proguard-rules.pro&#39; } debug{ minifyEnabled false signingConfig signingConfigs.release proguardFiles getDefaultProguardFile(&#39;proguard-android.txt&#39;), &#39;proguard-rules.pro&#39; } } 解释一下: signingConfigs { release { keyAlias &#39;phyooos&#39; keyPassword &#39;phyooos&#39; storeFile file(&#39;phyooos.jks&#39;) storePassword &#39;phyooos&#39; } } 这一段代码写在项目app目录下&gt;gradle配置文件中&gt;android节点下,是我们自定义的一个配置 keyAlias ‘phyooos’ 这是签名文件的Alias keyPassword ‘phyooos’ 这是签名文件的密码 storeFile file(‘phyooos.jks’) 这个就是签名文件的地址,我放在app目录下了 storePassword ‘phyooos’ 这是store密码 buildTypes { release { minifyEnabled false signingConfig signingConfigs.release proguardFiles getDefaultProguardFile(&#39;proguard-android.txt&#39;), &#39;proguard-rules.pro&#39; } debug{ minifyEnabled false signingConfig signingConfigs.release proguardFiles getDefaultProguardFile(&#39;proguard-android.txt&#39;), &#39;proguard-rules.pro&#39; } } 这一段的意思就是debug调试以及正式打包都使用上面自定义的配置 The End 好了,愉快的玩耍吧","categories":[{"name":"Android Studio","slug":"Android-Studio","permalink":"https://www.wangzhumo.com/categories/Android-Studio/"}],"tags":[{"name":"Android","slug":"Android","permalink":"https://www.wangzhumo.com/tags/Android/"},{"name":"Android Studio","slug":"Android-Studio","permalink":"https://www.wangzhumo.com/tags/Android-Studio/"}]},{"title":"低功耗蓝牙iBeacon的开发笔记","slug":"Bluetooth-iBeacon","date":"2017-12-25T01:37:23.000Z","updated":"2019-12-22T12:26:25.044Z","comments":true,"path":"2017/12/25/Bluetooth-iBeacon/","link":"","permalink":"https://www.wangzhumo.com/2017/12/25/Bluetooth-iBeacon/","excerpt":"1.挣扎的开始各种百度,google,发现国内资料很少,有的也是商业公司提供的sdk,这并不符合我需要,google倒是不少,然而以我的英语水平,望洋兴叹罢了","text":"1.挣扎的开始各种百度,google,发现国内资料很少,有的也是商业公司提供的sdk,这并不符合我需要,google倒是不少,然而以我的英语水平,望洋兴叹罢了 首先你需要了解这些资料1、profile rofile可以理解为一种规范，一个标准的通信协议，它存在于从机中。蓝牙组织规定了一些标准的profile，例如 HID OVER GATT ，防丢器 ，心率计等。每个profile中会包含多个service，每个service代表从机的一种能力。 2、serviceservice可以理解为一个服务，在ble从机中，通过有多个服务，例如电量信息服务、系统信息服务等，每个service中又包含多个characteristic特征值。每个具体的characteristic特征值才是ble通信的主题。比如当前的电量是80%，所以会通过电量的characteristic特征值存在从机的profile里，这样主机就可以通过这个characteristic来读取80%这个数据 3、characteristiccharacteristic特征值，ble主从机的通信均是通过characteristic来实现，可以理解为一个标签，通过这个标签可以获取或者写入想要的内容。 4、UUIDUUID，统一识别码，我们刚才提到的service和characteristic，都需要一个唯一的uuid来标识S: 百度到的,我以一个过来人的身份保证这个很重要 2.资料,准备资料看这里: 这也是最重要的资料来源,谷歌SDK的例子里面有的项目 接上文,说完资料, 这是一个很好的demosdk\\samples\\android-22\\connectivity\\BluetoothLeGatt 该目录下为谷歌提供的demo,我的应用也是在它的基础上改进而成的.由以下部分组成: 一个服务 BluetoothLeService,主负责与蓝牙设备进行数据交换 两个activity:DeviceControlActivity,DeviceScanActivity 见名知意,一个负责扫描设备,而两外一个与设备进行交互 一个SampleGattAttributes 主要是存储了一些UUID,我对它进行了加强 3.BLE设备的使用步骤概况 首先要说明的一点是,要求Android版本为4.3及其以上 接着确认设备支持 /** * 支持BLE * check to determine whether BLE is supported on the device */ public void isSupported(){ if (!getPackageManager().hasSystemFeature(PackageManager.FEATURE_BLUETOOTH_LE)) { Toast.makeText(this, &quot;设备不支持BLE功能&quot;, Toast.LENGTH_SHORT).show(); } } 确认手机支持并打开蓝牙的状态下,你就可以进行设备的搜索了 有两种模式 //第一种 //serviceUuids 指定设备的UUID //callback 搜索的回调 startLeScan(final UUID[] serviceUuids, final LeScanCallback callback) //第二种 //其实就是不传入serviceUuids的,就是说搜索范围内所有蓝牙设备 public boolean startLeScan(LeScanCallback callback) { return startLeScan(null, callback); } 同时记得停止搜索,当然你也可以一直搜PS：其实我见到的app大部分是不停的搜索，这样的话会有一个广播数据持续刷新的效果,那么很多的距离判断什么的都是通过这种不停搜索的形式来工作的 //mBluetoothAdapter 请自行查看谷歌文档 //mLeScanCallback 这就是上面提过的LeScanCallback的实例 mBluetoothAdapter.stopLeScan(mLeScanCallback); 接着就是在回调中拿到各个设备数据了 /** * 搜索设备回调 */ private BluetoothAdapter.LeScanCallback mLeScanCallback = new BluetoothAdapter.LeScanCallback() { @Override public void onLeScan(final BluetoothDevice device, int rssi, byte[] scanRecord) { } }; 这里有几个值得说一下的东西 BluetoothDevice device 该可以看的很清楚, device中包含了设备的基本信息 rssi信号质量,也有人告诉我是质量不过我这次并没有使用到 byte[] scanRecord (重头戏)广播响应包数据一般包括两个部分,我使用的主要是ServiceData域在这里需要注意的是，这两个部分都存在于广播数据，而且并不是两部分都有，有可能是只有一个部分，所以一定要看情设备的硬件规范，因为这涉及到后面解析广播数据 要知道，我们都是拿byte[]数组中的某些部分对应特定值,一旦对应关系打乱，那么数据解析就没什么正确性可言了这些广播数据都是依据一定的规则指定 的,所以这时候你需要设备厂商的文档来查看对应的数据,以及其结构PS:需要注意的一点是,这些数据都是byte[],你需要将它们转化(一般常用的做法是,先转化为16进制的字符串,而后再进行读取解析) 4.读取蓝牙设备内部数据这里涉及到两个重要部分service 以及 characteristic 一般来说 一个Service eg: FF01-XXXXXXXXXXX-XXXXX 下面可能有很多的characteristicMarjor : FF16 -XXXXXXPower : FF17 - XXX….一堆的characteristic 如果需要给指定的项目写入一个数据 条件： 1.此特征在哪个Service下，即该service的UUID 2.该特征的UUID 3.该特征的写入格式，16进制还是其他的东西 //代码片段1 //此方法获取对应特征值的对象BluetoothGattCharacteristic的实体 public BluetoothGattCharacteristic getCharacteristic(String service,String charact) { if (mBluetoothGatt == null) return null; if(mBluetoothGatt.getService(UUID.fromString(service))==null){return null ;} return mBluetoothGatt.getService(UUID.fromString(service)).getCharacteristic(UUID.fromString(charact)); } //代码片段2 if(!TextUtils.isEmpty(value)){//输入非空 byte[] arrayOfByte= new byte[2];//传入数据规定为2个byte arrayOfByte[0] = ((byte)Integer.parseInt((value).substring(0, 2), 16)); arrayOfByte[1] = ((byte)Integer.parseInt((value).substring(2, 4), 16)); //上面操作，先切，再转为16进制 characteristic.setValue(arrayOfByte); //characteristic实体就是片段1代码获取到的 gattServer.writeCharacteristic(characteristic); //所有的操作都封装在一个service中，gattServer为其实体对象 } //片段3就是服务中的写入方法 /** * 写入一个数据 * @param characteristic */ public void writeCharacteristic(BluetoothGattCharacteristic characteristic) { mBluetoothGatt.setCharacteristicNotification(characteristic, true); mBluetoothGatt.writeCharacteristic(characteristic); } //代码片段4 这是回调， //在连接时就作为参数传入了 mBluetoothGatt = device.connectGatt(this, false, mGattCallback); private final BluetoothGattCallback mGattCallback = new BluetoothGattCallback() { @Override public void onConnectionStateChange(BluetoothGatt gatt, int status, int newState) { if (newState == BluetoothProfile.STATE_CONNECTED) { Log.e(TAG, &quot;连接至 GATT server.&quot;); } else if (newState == BluetoothProfile.STATE_DISCONNECTED) { Log.e(TAG, &quot;断开 GATT server.&quot;); } } @Override public void onServicesDiscovered(BluetoothGatt gatt, int status) { if (status == BluetoothGatt.GATT_SUCCESS) { Log.e(TAG, &quot;建立连接成功&quot;); } else { Log.e(TAG, &quot;连接状态异常: &quot; + status); } } @Override public void onCharacteristicWrite(BluetoothGatt gatt, BluetoothGattCharacteristic characteristic, int status) { if (status == BluetoothGatt.GATT_SUCCESS) { Log.e(TAG, &quot;写入数据成功&quot;); } } @Override public void onCharacteristicRead(BluetoothGatt gatt, BluetoothGattCharacteristic characteristic, int status) { if (status == BluetoothGatt.GATT_SUCCESS) { Log.e(TAG, &quot;读取数据成功&quot;); } } @Override public void onCharacteristicChanged(BluetoothGatt gatt, BluetoothGattCharacteristic characteristic) { Log.e(TAG, &quot;连接状态发生改变&quot;); }; } PS:这里的例子是写入，其实读取的操作与此类似，操作完成后在回调里面判断状态以及读取数据即可","categories":[{"name":"Android","slug":"Android","permalink":"https://www.wangzhumo.com/categories/Android/"}],"tags":[{"name":"Android","slug":"Android","permalink":"https://www.wangzhumo.com/tags/Android/"}]},{"title":"Android Studio 基本设置","slug":"Android-Studio-Config","date":"2017-12-25T01:35:39.000Z","updated":"2019-12-22T12:27:52.727Z","comments":true,"path":"2017/12/25/Android-Studio-Config/","link":"","permalink":"https://www.wangzhumo.com/2017/12/25/Android-Studio-Config/","excerpt":"","text":"1.常用的快捷键 ALT + Enter 自动提示 ALT + Ins get set 构造方法 重写方法以及一些插件如这里的 GsonFormat 以及 Butterknife Ctrl + Alt + F 全局变量 Ctrl +Shift + Enter 加; 以及if 的(){} Ctrl + P 以及 Ctrl + Q 方法参数以及文档 Ctrl +O 继承重写的方法 Ctrl + / Ctrl +Shift + / 注释 Ctrl + Alt + L 格式化 Ctrl + D Ctrl + Y 复制 删除行 Ctrl + Shift + U 大小写 Shift Shift Ctrl + F 全局 当前 搜索 Ctrl + U 到父类 Ctrl + Alt + B 找到子类 Ctrl + H 类结构 Ctrl+Shift + H 方法层次 Ctrl + Alt + H 调用层次 Alt + F7 find use 非常好用的功能 Shift + F6 重命名 logt + Enter Tag loge logd … 打印log 2.自动生成代码 Ctrl + J 里面相当多的模版代码 if 判空 ifn for 循环 for foreach foreach setVisibility gone findViewById fbc instanceof inst 这些比较常用 3.自动导入包Settings&gt;Editor&gt;General&gt;Auto import 4.其他设置已经导出 ps : 在百度云里有","categories":[{"name":"Android Studio","slug":"Android-Studio","permalink":"https://www.wangzhumo.com/categories/Android-Studio/"}],"tags":[{"name":"Android Studio","slug":"Android-Studio","permalink":"https://www.wangzhumo.com/tags/Android-Studio/"}]},{"title":"Android Studio 导入 Vitamio及横竖屏切换","slug":"Android-Studio-Vitamio","date":"2017-12-25T01:28:42.000Z","updated":"2019-12-22T12:04:24.525Z","comments":true,"path":"2017/12/25/Android-Studio-Vitamio/","link":"","permalink":"https://www.wangzhumo.com/2017/12/25/Android-Studio-Vitamio/","excerpt":"##建议不要使用Vitamio,各种深坑 https://github.com/Bilibili/ijkplayer看看bilibili的开源播放器 ##Vitamio官方:https://www.vitamio.org/GitHub:https://github.com/yixia/VitamioBundle Vitamio 能够流畅播放720P甚至1080P高清MKV，FLV，MP4，MOV，TS，RMVB等常见格式的视频，支持 MMS, RTSP, RTMP, HLS(m3u8) 等常见的多种视频流媒体协议，包括点播与直播。","text":"##建议不要使用Vitamio,各种深坑 https://github.com/Bilibili/ijkplayer看看bilibili的开源播放器 ##Vitamio官方:https://www.vitamio.org/GitHub:https://github.com/yixia/VitamioBundle Vitamio 能够流畅播放720P甚至1080P高清MKV，FLV，MP4，MOV，TS，RMVB等常见格式的视频，支持 MMS, RTSP, RTMP, HLS(m3u8) 等常见的多种视频流媒体协议，包括点播与直播。 ###下载Vitamio 地址https://www.vitamio.org/Download/ ###解压并导入Android 找到到文件夹VitamioBundle File &gt; New &gt; New Module 导入完成后是这样的 ###导入到自己的项目 (即不使用Vitamio的libiary,强迫症专属) ####A.在自己的目录下建立io.vov.vitamio 并导入所有的类,以及将jniLibs目录拷贝到main目录下,还有相关的资源文件 ####B.在AndroidManifest.xml文件中写入 &lt;activity android:name=&quot;io.vov.vitamio.activity.InitActivity&quot; android:configChanges=&quot;orientation|screenSize|smallestScreenSize|keyboard|keyboardHidden|navigation&quot; android:launchMode=&quot;singleTop&quot; android:theme=&quot;@android:style/Theme.NoTitleBar&quot; android:windowSoftInputMode=&quot;stateAlwaysHidden&quot;/&gt; 并加入相应的权限 ####C.在你喜欢的地方初始化Vitamio 开玩笑的,放在activity或者是Application的onCreate中 Vitamio.isInitialized(application.getApplicationContext()); ###Vatimio的使用 ####A.界面的搭建 可以看到 整个页面主要分上下两层,主要是为了视屏全屏的时候能方便的隐藏整个下面的布局 ####B.使用在此之前为了方便的使用视屏全屏播放,对MediaController(package io.vov.vitamio.widget)做一个小小的改造:添加一个构造:主要用于把视屏,进度条等放到一个View中,便于全屏展示 //这个全屏的操作可把我难坏了,看到这个真的是为原作者的机智点赞 public MediaController(Context context,boolean fromXml,View container) { super(context); initController(context); mFromXml = fromXml; mRoot = makeControllerView(); //这个地方的FrameLayout.LayoutpParams是因为布局文件中要把MediaController的视图作为childView加到一个FrameLayout中去 LayoutParams p = new LayoutParams(LayoutParams.FILL_PARENT, LayoutParams.WRAP_CONTENT); //想怎样布局MediaController就尽情的发挥这个LayoutParams吧 p.gravity = Gravity.BOTTOM; mRoot.setLayoutParams(p); ((FrameLayout)container).addView(mRoot); } 接着你就可以愉快的玩耍了:在oncreate中调用 initVitamioView(); //初始化控件 private void initVitamioView() { //VideoView mVideoView = (VideoView) findViewById(R.id.buffer); //这个就是包裹整个视屏模块的FrameLayout fl_controller = (FrameLayout) findViewById(R.id.fl_controller); //缓冲时出现的进度条 pb = (ProgressBar) findViewById(R.id.probar); //播放进度,并可以拖动调节视屏播放位置 downloadRateView = (TextView) findViewById(R.id.download_rate); loadRateView = (TextView) findViewById(R.id.load_rate); //设置视屏setVideoURI可以缓冲并播放 //setVideoPath()缓冲完再播放 mVideoView.setVideoURI(Uri.parse(TextUtils.isEmpty(path)?defaultPath:path)); //这里使用自定义的那个MediaController构造 mMediaController= new MediaController(this, true, fl_controller); //这里的监听其实是在MediaController中自己定义的,主要就是全屏的切换按钮 mMediaController.setOnControllerClick(new MediaController.OnControllerClick() { @Override public void OnClick(int type) { if (type == 0) { //表示点击切换全屏按钮 if (isPortrait) { //不是全屏,切换为全屏 //代码块1 } else { //是全屏,近来就切为原来的大小 //代码块2 } } } }); //类似绑定 mVideoView.setMediaController(mMediaController); //隐藏控制模块 mMediaController.setVisibility(View.GONE); mVideoView.requestFocus(); //设置对视屏信息的监听 mVideoView.setOnInfoListener(this); //视屏缓冲的监听 mVideoView.setOnBufferingUpdateListener(this); //视屏OK mVideoView.setOnPreparedListener(new MediaPlayer.OnPreparedListener() { @Override public void onPrepared(MediaPlayer mediaPlayer) { //设置播放速度 mediaPlayer.setPlaybackSpeed(1.0f); } }); } 补充代码块1 RelativeLayout.LayoutParams fl_lp = new RelativeLayout.LayoutParams(displayheight, displayWidth); fl_controller.setLayoutParams(fl_lp); //设置横屏 setRequestedOrientation(ActivityInfo.SCREEN_ORIENTATION_LANDSCAPE); //这样mVideoView会自己充满全屏 mVideoView.setVideoLayout(VideoView.VIDEO_LAYOUT_SCALE, 0); isPortrait = false; 代码块2 RelativeLayout.LayoutParams fl_lp = new RelativeLayout.LayoutParams( LinearLayout.LayoutParams.MATCH_PARENT, DensityUtils.dip2px(ClassRoomActivity.this,200) ); fl_controller.setLayoutParams(fl_lp); setRequestedOrientation(ActivityInfo.SCREEN_ORIENTATION_PORTRAIT); isPortrait = true; /* * 横竖屏切换的时候回走这个回调 * */ @Override public void onConfigurationChanged(Configuration newConfig) { //屏幕切换时，设置全屏 if (this.getResources().getConfiguration().orientation == Configuration.ORIENTATION_LANDSCAPE) { //隐藏下面的布局和标题 tLBelow.setVisibility(View.GONE); mTitlebar.setVisibility(View.GONE); } if (this.getResources().getConfiguration().orientation == Configuration.ORIENTATION_PORTRAIT) { //显示下面的布局和标题 tLBelow.setVisibility(View.VISIBLE); mTitlebar.setVisibility(View.VISIBLE); } super.onConfigurationChanged(newConfig); } ####C.两个重要的监听(上面已经注册过了) //缓冲的监听 @Override public void onBufferingUpdate(MediaPlayer mp, int percent) { //显示缓冲进度 loadRateView.setText(percent + &quot;%&quot;); } //视屏信息监听 @Override public boolean onInfo(MediaPlayer mp, int what, int extra) { switch (what) { //开始缓冲 case MediaPlayer.MEDIA_INFO_BUFFERING_START: if (mVideoView.isPlaying()) { mVideoView.pause(); pb.setVisibility(View.VISIBLE); downloadRateView.setText(&quot;&quot;); loadRateView.setText(&quot;&quot;); downloadRateView.setVisibility(View.VISIBLE); loadRateView.setVisibility(View.VISIBLE); } break; //停止缓冲,这里自动开始播放 case MediaPlayer.MEDIA_INFO_BUFFERING_END: mVideoView.start(); pb.setVisibility(View.GONE); downloadRateView.setVisibility(View.GONE); loadRateView.setVisibility(View.GONE); break; case MediaPlayer.MEDIA_INFO_DOWNLOAD_RATE_CHANGED: //缓冲的...那个啥 change downloadRateView.setText(&quot;&quot; + extra + &quot;kb/s&quot; + &quot; &quot;); break; } return true; } ###4.就这样 对了,完事记得 @Override protected void onDestroy() { mVideoView.stopPlayback(); super.onDestroy(); } 基本就是这样了,其他的问题自己解决一下就好了…","categories":[{"name":"Android Studio","slug":"Android-Studio","permalink":"https://www.wangzhumo.com/categories/Android-Studio/"}],"tags":[{"name":"Android","slug":"Android","permalink":"https://www.wangzhumo.com/tags/Android/"},{"name":"Android Studio","slug":"Android-Studio","permalink":"https://www.wangzhumo.com/tags/Android-Studio/"}]},{"title":"Linux 学习笔记","slug":"Linux-learn","date":"2017-12-24T15:50:59.000Z","updated":"2019-11-07T10:54:11.315Z","comments":true,"path":"2017/12/24/Linux-learn/","link":"","permalink":"https://www.wangzhumo.com/2017/12/24/Linux-learn/","excerpt":"netstat -an 查看所有网络连接 more命令 选项 -num 指定屏幕的行数（以整数表示） +num 从行号num开始显示 -d 让more给用户显示信息[Press space to continue, &#39;q&#39; to quit.] -f 使more计数逻辑行，而不是屏幕行（长行不会断到下一行） -s 把重复的空行压缩成一个空行 -u 防止下划线 交互基于VIM","text":"netstat -an 查看所有网络连接 more命令 选项 -num 指定屏幕的行数（以整数表示） +num 从行号num开始显示 -d 让more给用户显示信息[Press space to continue, &#39;q&#39; to quit.] -f 使more计数逻辑行，而不是屏幕行（长行不会断到下一行） -s 把重复的空行压缩成一个空行 -u 防止下划线 交互基于VIM 字符界面 1.字符界面占用资源少 2.减少了出错,被攻击的可能 一切皆文件 用户 硬件 文件…. 分区 swap 内存的两倍 / 根分区 /boot boot分区 200m即可 (作为启动盘使用,启动需要空间) /home /etc … 安装日志 /root/install.log 记录了安装在系统中的软件包和版本信息 /root/install.log.syslog 安装过程的记录 /root/anaconda-ks.cfg 记录安装过程中的配置信息(用于网络批量安装) linux起始符 [root@hadoop ~]# root 用户名 hadoop 当前用户的主机名 &quot;~&quot; 当前的目录, &quot;~&quot;表示家目录 &quot;#&quot; 超级用户的提示符 &quot;$&quot; 普通用户的提示符 -rw-r–r– drwxr-xr-x. 2 wzm wzm 4096 6月 21 16:19 Desktop #一共10位 drwxr-xr-x #d 第一位 文件类型( -文件 d目录 |软链接文件 c b ) #rwx r-x r-x 后面的每三位是一组 第一个三位 所属者u 第二个三位 所属组g 第三个三位 其他人o #acf权限 r读 w写 x执行 目录 / 根目录 /etc 配置文件目录 /bin 系统命令的目录 (普通用户即可读取) /sbin 系统命令的目录 (超级用户即可读取) /usr/bin 系统命令的目录 (普通用户即可读取) /usr/sbin系统命令的目录 (超级用户即可读取) /home 普通用户的家目录 /root 超级用户的家目录 /usr 系统软件资源目录 /boot 启动目录 /var 系统相关文档 /sys 直接写入内存 /proc 直接写入内存 /dev 设备文件目录 /lib 系统库 保存目录 /mnt 系统挂载目录 /media 挂载目录 linux 常用命令 control + L 清屏 文件命令 基本命令格式 命令 [选项] [参数] #ls ls -a 显示所有文件 -l 显示详细信息,目录下所有内容 -d 查看目录属性,目录本身 -h 人性化显示文件大小 -i 显示inode 文件的id号 ll ll -l # 目录文件处理 #mkdir 创建目录 mkdir -p 递归创建,创建多级目录 #cd 切换目录 cd ~ 当前用户的家目录 - 进入上次进入的目录 .. 进入上级目录 . 进入当前目录 #pwd pwd 显示当前目录全路径 #rm -rf [文件或目录] rm -f 强制删除 -r 删除目录 #cp cp -r 复制目录 -p 连带文件的属性一起复制 -d 如果文件为链接文件,则复制链接属性 -a 相当于-pdr #mv mv [源地址] [目标地址] 软链接命令(源文件一定写巨绝对路径) #ln [源] [目标] ln 不能跨分区,不能是一个目录 相当于一个文件 文件id号相同 -s 软链接 类似windows里面的快捷方式 有自己的id号 其实是去查看自己的存储点, 存储点里面是源文件的id号, 然后又用源文件id号去找源文件的存储点 搜索命令 locate 文件搜索命令 whereis 与 which find 文件搜索命令 grep 字符串搜索命令 locate #locate locate [文件名] 在后台数据库中按文件名搜索 位置在: /var/lib/mlocate #updatedb updatedb 更新数据库 whereis #whereis whereis [命令名] -b 之查找可执行文件 -m 只查找帮助文件 which 查看 #which which [文件名] 搜索命令所在目录路径已经别名 find #find #避大范围搜索,会非常消耗系统资源 #如果不用通配符,则会搜索与文件名完全一致的文件 find [搜素范围] [搜索条件] find [搜素范围] -name [名字] -iname [名字] 不区分大小写 -user [所有者] 按所有者搜索 -nouser 查找没有所有者的文件 -mtime [] 修改文件内容的时间 -atime [] 文件访问时间 -ctime [] 改变文件属性的时间 [-10 10 +10 10天内 10天当天 +10天前] -size [大小] 当前目录下查找大小是 25k的文件 [-25k 25k +25k] [-2M 2M +2M] -inum [id号] -a and 逻辑与,同时满足两个条件 eg find /etc -size +25k -a -size -50k -o or 逻辑或,两个条件满足一个条件即可 -exec [一个命令] {} \\; 搜索出来的结果再执行一次命令 eg find /etc -size +25k -a -size -50k -exec ls -lh {} \\; #通配符 * 匹配任何内容 ? 匹配任意一个字符 [] 匹配任意一个中口号内的字符 eg: abc abd find /home -name ab[cd] grep #grep grep &quot;size&quot; system.log grep是包含匹配 在 system.log 中查找&quot;size&quot; 帮助命令 man [命令] whatis [命令] man -f [命令] 命令的帮助级别 man -k [命令] 模糊匹配 apropos [命令] 模糊匹配 [命令] --help 内核的命令查看帮助 help [命令] 压缩与解压缩 常用压缩格式 .zip .gz .bz2 .tar.gz .tar.bz2 zip zip [压缩文件名字] [源文件] zip -r [压缩文件名字] [源目录] #解压缩 unzip [zip文件] gz gzip [源文件] #压缩为.gz格式的压缩文件,源文件会消失 gzip -c [源文件] &gt; 压缩文件 #压缩为.gz格式 ,源文件保留 gzip -r [源目录] #压缩目录下所有的子文件,但是不能压缩目录 #解压缩 gzip -d [压缩文件] gunzip [压缩文件] gzp -d -r [目录] 解压目录下所有的文件 tar #tar tar -cvf [打包文件名] [源文件] -c 打包 -v 显示过程 -f 指定打包后的文件名 eg tar -cvf jp.tar jp #解压缩 tar -xvf [压缩文件] .tar.gz tar -zcvf [压缩文件名] [源文件] #解压缩 tar -zxvf [压缩包名.tar.gz] 关机和重启 shutdown [选项] 时间 -c 取消前一个关机命令 -h 关机 -r 重启 logout 退出登录 其他的命令 w 显示所有的登录用户 last 所有登录信息 lastlog 所有用户登录信息 其他快捷键 control + c 强制终止当前命令 control + l 清屏 control + a 光标移动到行首 control + e 光标移动到行尾 control + u 从光标位置删除到行首 control + z 把命令放入到后台 control + r 在历史记录中搜索 输出重定向 #标准的输出重定向 命令 &gt; 文件 覆盖的方式写入 命令 &gt;&gt; 文件 追加的方式写入 #错误输出重定向 错误命令 2&gt; 文件 覆盖的方式写入错误提示 错误命令 2&gt;&gt; 文件 追加的方式写入错误提示 #正确和错误的同时输出 命令 &gt;&gt; 文件 2&gt;&amp;1 命令 &amp;&gt;&gt; 文件 #正确错误分开输出 命令 &gt;&gt; 文件 2&gt;&gt; 文件 -输入重定向 wc [选项] [文件名] -c 统计字节数 -w 统计单词数 -l 统计行数 wc 在终端输入文字 control + D 统计结果 wc [文件名] 文件内容输入到终端 管道符 多命令执行(前一条命令的结果不会传入) [命令1] ; [命令2] 顺序执行 [命令1] &amp;&amp; [命令2] 命令1执行正确 命令2执行 命令1执行错误 命令2不会执行 [命令1] || [命令2] 当命令1执行不正确 命令2执行 命令1执行正确 命令2就不会执行 管道符(前一条命令的结果传入下一个命令) # | [命令1] | [命令2] 命令2会去操作命令1执行的结果 通配符 ? 任意一个字符 * 任意内容 [] 匹配括号中的某一个字符 [-] 匹配括号中的任意一个字符 - 代表一个范围 [a-z] [1-3] [^] 表示匹配不是括号中的字符 比如[^0-9] 指匹配不是数字的字符 &#39;&#39; 单引号 在单引号中所有字符都没有特殊含义 &quot;&quot; 双引号 除了&quot;$&quot; 和 &quot;`&quot; &quot;\\&quot; 其他字符都没有特殊意义 `` 反引号 是系统命令内容 $() 用来引用系统命令 # shell中表示注释 $ 调用变量的值 \\ 转义符","categories":[{"name":"Server","slug":"Server","permalink":"https://www.wangzhumo.com/categories/Server/"}],"tags":[{"name":"Server，Linux","slug":"Server，Linux","permalink":"https://www.wangzhumo.com/tags/Server，Linux/"}]},{"title":"Facebook/Stetho——Android开发调试神器","slug":"Facebook-Stetho","date":"2017-12-24T15:47:55.000Z","updated":"2019-12-22T12:28:57.092Z","comments":true,"path":"2017/12/24/Facebook-Stetho/","link":"","permalink":"https://www.wangzhumo.com/2017/12/24/Facebook-Stetho/","excerpt":"一、简介Stetho是一个Android应用调试工具。集成后，开发人员可以通过Chrome的开发工具查看App相关的信息和调试；可视化操作，不需要自己使用adb也不需要root权限。","text":"一、简介Stetho是一个Android应用调试工具。集成后，开发人员可以通过Chrome的开发工具查看App相关的信息和调试；可视化操作，不需要自己使用adb也不需要root权限。 二、APP集成1.下载最新的jar，或者通过Gradle引入stetho的libraay compile &#39;com.facebook.stetho:stetho:1.3.1&#39; 2.只需要在 Application的 onCreate 方法中调用 public class MyApplication extends Application { public void onCreate() { super.onCreate(); Stetho.initializeWithDefaults(this); } } 3.如果还想查看网络请求的话，需要引入另外的Library compile &#39;com.facebook.stetho:stetho-okhttp3:1.3.1&#39; 4.使用okhttp 还需要添加 StethoInterceptor OkHttpClient client = new OkHttpClient.Builder() .addNetworkInterceptor(new StethoInterceptor()) .build(); 三、使用配置完成之后，在Chrome地址栏输入chrome://inspect chrome://inspect/#devices chrome会检测到我们的app，点击 inspect 进入查看页面","categories":[{"name":"Android","slug":"Android","permalink":"https://www.wangzhumo.com/categories/Android/"}],"tags":[{"name":"Android","slug":"Android","permalink":"https://www.wangzhumo.com/tags/Android/"}]},{"title":"String.format的参数表","slug":"string-format","date":"2017-12-23T02:56:53.000Z","updated":"2019-12-22T12:30:52.346Z","comments":true,"path":"2017/12/23/string-format/","link":"","permalink":"https://www.wangzhumo.com/2017/12/23/string-format/","excerpt":"","text":"String.format()%s 字符串类型 &quot;mingrisoft&quot; %c 字符类型 &#39;m&#39; %b 布尔类型 true %d 整数类型（十进制） 99 %x 整数类型（十六进制） FF %o 整数类型（八进制） 77 %f 浮点类型 99.99 %a 十六进制浮点类型 FF.35AE %e 指数类型 9.38e+5 %g 通用浮点类型（f和e类型中较短的） %h 散列码 %% 百分比类型 ％ %n 换行符 %tx 日期与时间类型（x代表不同的日期与时间转换符","categories":[{"name":"Java","slug":"Java","permalink":"https://www.wangzhumo.com/categories/Java/"}],"tags":[{"name":"Java","slug":"Java","permalink":"https://www.wangzhumo.com/tags/Java/"}]},{"title":"透明度对照表","slug":"transparency-table","date":"2017-12-23T02:55:00.000Z","updated":"2019-12-22T12:29:40.916Z","comments":true,"path":"2017/12/23/transparency-table/","link":"","permalink":"https://www.wangzhumo.com/2017/12/23/transparency-table/","excerpt":"","text":"透明度对照表100% — FF 95% — F2 90% — E6 85% — D9 80% — CC 75% — BF 70% — B3 65% — A6 60% — 99 55% — 8C 50% — 80 45% — 73 40% — 66 35% — 59 30% — 4D 25% — 40 20% — 33 15% — 26 10% — 1A 5% — 0D 0% — 00","categories":[{"name":"Tools","slug":"Tools","permalink":"https://www.wangzhumo.com/categories/Tools/"}],"tags":[{"name":"Android","slug":"Android","permalink":"https://www.wangzhumo.com/tags/Android/"}]},{"title":"常用正则表达式记录","slug":"Regular-Expression","date":"2017-07-31T05:09:38.000Z","updated":"2019-12-22T12:25:04.729Z","comments":true,"path":"2017/07/31/Regular-Expression/","link":"","permalink":"https://www.wangzhumo.com/2017/07/31/Regular-Expression/","excerpt":"常用的正则表达式","text":"常用的正则表达式 常用正则 说明 正则表达式 网址（URL） [a-zA-z]+://[^\\s]* IP地址(IP Address) `((2[0-4]\\d 25[0-5] [01]?\\d\\d?).){3}(2[0-4]\\d 25[0-5] [01]?\\d\\d?)` 电子邮件(Email) \\w+([-+.]\\w+)*@\\w+([-.]\\w+)*\\.\\w+([-.]\\w+)* QQ号码 [1-9]\\d{4,} HTML标记(包含内容或自闭合) `&lt;(.)(.)&gt;.*&lt;\\/\\1&gt; &lt;(.*) \\/&gt;` 密码(由数字/大写字母/小写字母/标点符号组成，四种都必有，8位以上) (?=^.{8,}$)(?=.*\\d)(?=.*\\W+)(?=.*[A-Z])(?=.*[a-z])(?!.*\\n).*$ 日期(年-月-日) `(\\d{4} \\d{2})-((1[0-2]) (0?[1-9]))-(([12][0-9]) (3[01]) (0?[1-9]))` 日期(月/日/年) `((1[0-2]) (0?[1-9]))/(([12][0-9]) (3[01]) (0?[1-9]))/(\\d{4} \\d{2})` 时间(小时:分钟, 24小时制) `((1 0?)[0-9] 2[0-3]):([0-5][0-9])` 汉字(字符) [\\u4e00-\\u9fa5] 中文及全角标点符号(字符) [\\u3000-\\u301e\\ufe10-\\ufe19\\ufe30-\\ufe44\\ufe50-\\ufe6b\\uff01-\\uffee] 中国大陆固定电话号码 `(\\d{4}- \\d{3}-)?(\\d{8} \\d{7})` 中国大陆手机号码 1\\d{10} 中国大陆邮政编码 [1-9]\\d{5} 中国大陆身份证号(15位或18位) \\d{15}(\\d\\d[0-9xX])? 非负整数(正整数或零) \\d+ 正整数 [0-9]*[1-9][0-9]* 负整数 -[0-9]*[1-9][0-9]* 整数 -?\\d+ 小数 (-?\\d+)(\\.\\d+)? 不包含abc的单词 \\b((?!abc)\\w)+\\b 字符转义正则表达式中的反斜杠字符 () 指示其后跟的字符是特殊字符（如下表所示），或应按原义解释该字符。 转义字符 描述 模式 匹配 转义字符\\a 描述与报警 (bell) 符 \\u0007 匹配。 模式\\a 匹配“Error!”+“\\u0007”中的 “\\u0007” 转义字符\\b 描述在字符类中，与退格键 \\u0008 匹配。 模式[\\b]{3,} 匹配“\\b\\b\\b\\b”中的“\\b\\b\\b\\b” 转义字符\\t 描述与制表符 \\u0009 匹配。 模式(\\w+)\\t 匹配“item1\\titem2\\t”中的“item1\\t”和“item2\\t” 转义字符\\r 描述与回车符 \\u000D 匹配。 （\\r 与换行符 \\n 不是等效的。） 模式\\r\\n(\\w+) 匹配“\\r\\nThese are\\ntwo lines.”中的“\\r\\nThese” 转义字符\\v 描述与垂直制表符 \\u000B 匹配。 模式[\\v]{2,} 匹配“\\v\\v\\v”中的“\\v\\v\\v” 转义字符\\f 描述与换页符 \\u000C 匹配。 模式[\\f]{2,} 匹配“\\f\\f\\f”中的“\\f\\f\\f” 转义字符\\n 描述与换行符 \\u000A 匹配。 模式\\r\\n(\\w+) 匹配“\\r\\nThese are\\ntwo lines.”中的“\\r\\nThese” 转义字符\\e 描述与转义符 \\u001B 匹配。 模式\\e 匹配“\\x001B”中的“\\x001B” 转义字符\\nnn 描述使用八进制表示形式指定字符（nnn 由二位或三位数字组成）。 模式\\w\\040\\w 匹配“a bc d”中的“a b”和“c d” 转义字符\\xnn 描述使用十六进制表示形式指定字符（nn 恰好由两位数字组成）。 模式\\w\\x20\\w 匹配“a bc d”中的“a b”和“c d” 转义字符\\cX\\cx 描述匹配 X 或 x 指定的 ASCII 控件字符，其中 X 或 x 是控件字符的字母。 模式\\cC 匹配“\\x0003”中的“\\x0003”(Ctrl-C) 转义字符\\unnnn 描述使用十六进制表示形式匹配 Unicode 字符（由 nnnn 正确表示的四位数）。 模式\\w\\u0020\\w 匹配“a bc d”中的“a b”和“c d” 转义字符\\ 描述在后面带有不识别为本主题的此表和其他表中的转义符的字符时，与该字符匹配。 例如，* 与 \\x2A 相同，而 . 与 \\x2E 相同。 这允许正则表达式引擎区分语言元素（如 或 ?） 和字符文本（用 \\ 或 \\? 表示）。 模式\\d+[+-x*]\\d+ 匹配“(2+2) 39”中的“2+2”和“3*9” 字符类字符类与一组字符中的任何一个字符匹配。 字符类 描述 模式 匹配 字符类[character_group] 描述匹配 character_group 中的任何单个字符。 默认情况下，匹配区分大小写。 模式[ae] 匹配“gray”中的“a”“lane”中的“a”和“e” 字符类[^character_group] 描述求反：与不在 character_group 中的任何单个字符匹配。 默认情况下，character_group 中的字符区分大小写。 模式[^aei] 匹配“reign”中的“r”、“g”和“n” 字符类[第一个-last] 描述字符范围：与从第一个到最后一个的范围中的任何单个字符匹配。 模式[A-Z] 匹配“AB123”中的“A”和“B” 字符类. 描述通配符：与除 \\n 之外的任何单个字符匹配。若要匹配文本句点字符（. 或 \\u002E），你必须在该字符前面加上转义符 (.)。 模式a.e 匹配“nave”中的“ave”“water”中的“ate” 字符类\\p{name} 描述与 name 指定的 Unicode 通用类别或命名块中的任何单个字符匹配。 模式\\p{Lu}\\p{IsCyrillic} 匹配“City Lights”中的“C”和“L”“ДЖem”中的“Д”和“Ж” 字符类\\P{name} 描述与不在 name 指定的 Unicode 通用类别或命名块中的任何单个字符匹配。 模式\\P{Lu}\\P{IsCyrillic} 匹配“City”中的“i”、“t”和“y”“ДЖem”中的“e”和“m” 字符类\\w 描述与任何单词字符匹配。 模式\\w 匹配“ID A1.3”中的“I”、“D”、“A”、“1”和“3” 字符类\\W 描述与任何非单词字符匹配。 模式\\W 匹配“ID A1.3”中的“ ”、“.” 字符类\\s 描述与任何空白字符匹配。 模式\\w\\s 匹配“ID A1.3”中的“D” 字符类\\S 描述与任何非空白字符匹配。 模式\\s\\S 匹配” _” in “int __ctr” 字符类\\d 描述与任何十进制数字匹配。 模式\\d 匹配“4 = IV”中的“4” 字符类\\D 描述匹配不是十进制数的任意字符。 模式\\D 匹配“4 = IV”中的“ ”、“=”、“ ”、“I”和“V” 定位点定位点或原子零宽度断言会使匹配成功或失败，具体取决于字符串中的当前位置，但它们不会使引擎在字符串中前进或使用字符 断言 描述 模式 匹配 断言^ 描述匹配必须从字符串或一行的开头开始。 模式^\\d{3} 匹配“901”“901-” 断言$ 描述匹配必须出现在字符串的末尾或出现在行或字符串末尾的 \\n 之前。 模式-\\d{3}$ 匹配“-333”“-333” 断言\\A 描述匹配必须出现在字符串的开头。 模式\\A\\d{3} 匹配“901”“901-” 断言\\Z 描述匹配必须出现在字符串的末尾或出现在字符串末尾的 \\n 之前。 模式-\\d{3}\\Z 匹配“-333”“-333” 断言\\z 描述匹配必须出现在字符串的末尾。 模式-\\d{3}\\z 匹配“-333”“-333” 断言\\G 描述匹配必须出现在上一个匹配结束的地方。 模式\\G(\\d) 匹配“(1)(3)(5)7”中的“(1)”、“(3)”、“(5)” 断言\\b 描述匹配必须出现在 \\w（字母数字）和 \\W（非字母数字）字符之间的边界上。 模式\\b\\w+\\s\\w+\\b 匹配“them theme them them”中的“them theme”、“them them” 断言\\B 描述匹配不得出现在 \\b 边界上。 模式\\Bend\\w*\\b 匹配“end sends endure lender”中的“ends”和“ender” 分组构造分组构造描述了正则表达式的子表达式，通常用于捕获输入字符串的子字符串。 分组构造包括下表中列出的语言元素。 分组构造 描述 模式 匹配 分组构造(子表达式) 描述捕获匹配的子表达式并将其分配到一个从 1 开始的序号中。 模式(\\w)\\1 匹配“deep”中的“ee” 分组构造(?&lt; 名称 &gt; 子表达式) 描述将匹配的子表达式捕获到一个命名组中。 模式(?\\w)\\k 匹配“deep”中的“ee” 分组构造(?&lt; 名称 1 - 名称 2 &gt; 子表达式) 描述定义平衡组定义。 有关详细信息，请参阅正则表达式中的分组构造中的“平衡组定义”部分。 模式(((?’Open’()[^()])+((?’Close-Open’))[^()])+)*(?(Open)(?!))$ 匹配“3+2^((1-3)(3-1))”中的“((1-3)(3-1))” 分组构造(?: 子表达式) 描述定义非捕获组。 模式Write(?:Line)? 匹配“Console.WriteLine()”中的“WriteLine”“Console.Write(value)”中的“Write” 分组构造(?imnsx-imnsx: 子表达式) 描述应用或禁用子表达式中指定的选项。 有关详细信息，请参阅正则表达式选项。 模式A\\d{2}(?i:\\w+)\\b 匹配“A12xl A12XL a12xl”中的“A12xl”和“A12XL” 分组构造(?= 子表达式) 描述零宽度正预测先行断言。 模式\\w+(?=.) 匹配“He is. The dog ran. The sun is out.”中的“is”、“ran”和“out” 分组构造(?! 子表达式) 描述零宽度负预测先行断言。 模式\\b(?!un)\\w+\\b 匹配“unsure sure unity used”中的“sure”和“used” 分组构造(?&lt;= 子表达式) 描述零宽度正回顾后发断言。 模式(?&lt;=19)\\d{2}\\b 匹配“1851 1999 1950 1905 2003”中的“99”、“50”和“05” 分组构造(?&lt;! 子表达式) 描述零宽度负回顾后发断言。 模式(?&lt;!19)\\d{2}\\b 匹配“1851 1999 1950 1905 2003”中的“51”和“03” 分组构造(?&gt; 子表达式) 描述非回溯（也称为“贪婪”）子表达式。 模式13579 匹配“1ABB 3ABBC 5AB 5AC”中的“1ABB”、“3ABB”和“5AB” 数量词 限定符 描述 模式 匹配 限定符* 描述匹配上一个元素零次或多次。 模式\\d*.\\d 匹配“.0”，“19.9”和“219.9” 限定符+ 描述匹配上一个元素一次或多次。 模式”be+” 匹配“been”中的“bee”，“bent”中的“be” 限定符? 描述匹配上一个元素零次或一次。 模式”rai?n” 匹配“ran”和“rain” 限定符{n} 描述匹配上一个元素恰好 n 次。 模式”,\\d{3}” 匹配“1,043.6”中的“,043”，“9,876,543,210”中的“,876”、“,543”和“,210” 限定符{n,} 描述匹配上一个元素至少 n 次。 模式”\\d{2,}” 匹配“166”，“29”和“1930” 限定符{n,m} 描述匹配上一个元素至少 n 次，但不多于 m 次。 模式”\\d{3,5}” 匹配“166”、“17668”“193024”中的“19302” 限定符*? 描述匹配上一个元素零次或多次，但次数尽可能少。 模式\\d*?.\\d 匹配“.0”，“19.9”和“219.9” 限定符+? 描述匹配上一个元素一次或多次，但次数尽可能少。 模式”be+?” 匹配“been”中的“be”，“bent”中的“be” 限定符?? 描述匹配上一个元素零次或一次，但次数尽可能少。 模式”rai??n” 匹配“ran”和“rain” 限定符{n}? 描述匹配前面的元素恰好 n 次。 模式”,\\d{3}?” 匹配“1,043.6”中的“,043”，“9,876,543,210”中的“,876”、“,543”和“,210” 限定符{n,}? 描述匹配上一个元素至少 n 次，但次数尽可能少。 模式”\\d{2,}?” 匹配“166”，“29”和“1930” 限定符{n,m}? 描述匹配上一个元素的次数介于 n 和 m 之间，但次数尽可能少。 模式”\\d{3,5}?” 匹配“166”、“17668”“193024”中的“193”、“024”","categories":[{"name":"Other","slug":"Other","permalink":"https://www.wangzhumo.com/categories/Other/"}],"tags":[{"name":"Regular","slug":"Regular","permalink":"https://www.wangzhumo.com/tags/Regular/"}]}]}